/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const qc = globalThis, wu = qc.ShadowRoot && (qc.ShadyCSS === void 0 || qc.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Su = Symbol(), pd = /* @__PURE__ */ new WeakMap();
let Md = class {
    constructor(E, j, K) {
        if (this._$cssResult$ = !0, K !== Su) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = E, this.t = j;
    }
    get styleSheet() {
        let E = this.o;
        const j = this.t;
        if (wu && E === void 0) {
            const K = j !== void 0 && j.length === 1;
            K && (E = pd.get(j)), E === void 0 && ((this.o = E = new CSSStyleSheet()).replaceSync(this.cssText), K && pd.set(j, E));
        }
        return E;
    }
    toString() {
        return this.cssText;
    }
};
const xm = (Q) => new Md(typeof Q == "string" ? Q : Q + "", void 0, Su), Id = (Q, ...E) => {
    const j = Q.length === 1 ? Q[0] : E.reduce((K, se, Te) => K + ((M) => {
        if (M._$cssResult$ === !0) return M.cssText;
        if (typeof M == "number") return M;
        throw Error("Value passed to 'css' function must be a 'css' function result: " + M + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
    })(se) + Q[Te + 1], Q[0]);
    return new Md(j, Q, Su);
}, bm = (Q, E) => {
    if (wu) Q.adoptedStyleSheets = E.map((j) => j instanceof CSSStyleSheet ? j : j.styleSheet);
    else for (const j of E) {
        const K = document.createElement("style"), se = qc.litNonce;
        se !== void 0 && K.setAttribute("nonce", se), K.textContent = j.cssText, Q.appendChild(K);
    }
}, dd = wu ? (Q) => Q : (Q) => Q instanceof CSSStyleSheet ? ((E) => {
    let j = "";
    for (const K of E.cssRules) j += K.cssText;
    return xm(j);
})(Q) : Q;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: wm, defineProperty: Sm, getOwnPropertyDescriptor: Tm, getOwnPropertyNames: Pm, getOwnPropertySymbols: Mm, getPrototypeOf: Im } = Object, on = globalThis, fd = on.trustedTypes, Cm = fd ? fd.emptyScript : "", _u = on.reactiveElementPolyfillSupport, Ml = (Q, E) => Q, Wc = {
    toAttribute(Q, E) {
        switch (E) {
            case Boolean:
                Q = Q ? Cm : null;
                break;
            case Object:
            case Array:
                Q = Q == null ? Q : JSON.stringify(Q);
        }
        return Q;
    }, fromAttribute(Q, E) {
        let j = Q;
        switch (E) {
            case Boolean:
                j = Q !== null;
                break;
            case Number:
                j = Q === null ? null : Number(Q);
                break;
            case Object:
            case Array:
                try {
                    j = JSON.parse(Q);
                } catch {
                    j = null;
                }
        }
        return j;
    }
}, Tu = (Q, E) => !wm(Q, E), md = { attribute: !0, type: String, converter: Wc, reflect: !1, useDefault: !1, hasChanged: Tu };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), on.litPropertyMetadata ?? (on.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let ho = class extends HTMLElement {
    static addInitializer(E) {
        this._$Ei(), (this.l ?? (this.l = [])).push(E);
    }
    static get observedAttributes() {
        return this.finalize(), this._$Eh && [...this._$Eh.keys()];
    }
    static createProperty(E, j = md) {
        if (j.state && (j.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(E) && ((j = Object.create(j)).wrapped = !0), this.elementProperties.set(E, j), !j.noAccessor) {
            const K = Symbol(), se = this.getPropertyDescriptor(E, K, j);
            se !== void 0 && Sm(this.prototype, E, se);
        }
    }
    static getPropertyDescriptor(E, j, K) {
        const { get: se, set: Te } = Tm(this.prototype, E) ?? {
            get() {
                return this[j];
            }, set(M) {
                this[j] = M;
            }
        };
        return {
            get: se, set(M) {
                const c = se == null ? void 0 : se.call(this);
                Te == null || Te.call(this, M), this.requestUpdate(E, c, K);
            }, configurable: !0, enumerable: !0
        };
    }
    static getPropertyOptions(E) {
        return this.elementProperties.get(E) ?? md;
    }
    static _$Ei() {
        if (this.hasOwnProperty(Ml("elementProperties"))) return;
        const E = Im(this);
        E.finalize(), E.l !== void 0 && (this.l = [...E.l]), this.elementProperties = new Map(E.elementProperties);
    }
    static finalize() {
        if (this.hasOwnProperty(Ml("finalized"))) return;
        if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(Ml("properties"))) {
            const j = this.properties, K = [...Pm(j), ...Mm(j)];
            for (const se of K) this.createProperty(se, j[se]);
        }
        const E = this[Symbol.metadata];
        if (E !== null) {
            const j = litPropertyMetadata.get(E);
            if (j !== void 0) for (const [K, se] of j) this.elementProperties.set(K, se);
        }
        this._$Eh = /* @__PURE__ */ new Map();
        for (const [j, K] of this.elementProperties) {
            const se = this._$Eu(j, K);
            se !== void 0 && this._$Eh.set(se, j);
        }
        this.elementStyles = this.finalizeStyles(this.styles);
    }
    static finalizeStyles(E) {
        const j = [];
        if (Array.isArray(E)) {
            const K = new Set(E.flat(1 / 0).reverse());
            for (const se of K) j.unshift(dd(se));
        } else E !== void 0 && j.push(dd(E));
        return j;
    }
    static _$Eu(E, j) {
        const K = j.attribute;
        return K === !1 ? void 0 : typeof K == "string" ? K : typeof E == "string" ? E.toLowerCase() : void 0;
    }
    constructor() {
        super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
    }
    _$Ev() {
        var E;
        this._$ES = new Promise((j) => this.enableUpdating = j), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (E = this.constructor.l) == null || E.forEach((j) => j(this));
    }
    addController(E) {
        var j;
        (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(E), this.renderRoot !== void 0 && this.isConnected && ((j = E.hostConnected) == null || j.call(E));
    }
    removeController(E) {
        var j;
        (j = this._$EO) == null || j.delete(E);
    }
    _$E_() {
        const E = /* @__PURE__ */ new Map(), j = this.constructor.elementProperties;
        for (const K of j.keys()) this.hasOwnProperty(K) && (E.set(K, this[K]), delete this[K]);
        E.size > 0 && (this._$Ep = E);
    }
    createRenderRoot() {
        const E = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
        return bm(E, this.constructor.elementStyles), E;
    }
    connectedCallback() {
        var E;
        this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (E = this._$EO) == null || E.forEach((j) => {
            var K;
            return (K = j.hostConnected) == null ? void 0 : K.call(j);
        });
    }
    enableUpdating(E) {
    }
    disconnectedCallback() {
        var E;
        (E = this._$EO) == null || E.forEach((j) => {
            var K;
            return (K = j.hostDisconnected) == null ? void 0 : K.call(j);
        });
    }
    attributeChangedCallback(E, j, K) {
        this._$AK(E, K);
    }
    _$ET(E, j) {
        var Te;
        const K = this.constructor.elementProperties.get(E), se = this.constructor._$Eu(E, K);
        if (se !== void 0 && K.reflect === !0) {
            const M = (((Te = K.converter) == null ? void 0 : Te.toAttribute) !== void 0 ? K.converter : Wc).toAttribute(j, K.type);
            this._$Em = E, M == null ? this.removeAttribute(se) : this.setAttribute(se, M), this._$Em = null;
        }
    }
    _$AK(E, j) {
        var Te, M;
        const K = this.constructor, se = K._$Eh.get(E);
        if (se !== void 0 && this._$Em !== se) {
            const c = K.getPropertyOptions(se), Fe = typeof c.converter == "function" ? { fromAttribute: c.converter } : ((Te = c.converter) == null ? void 0 : Te.fromAttribute) !== void 0 ? c.converter : Wc;
            this._$Em = se, this[se] = Fe.fromAttribute(j, c.type) ?? ((M = this._$Ej) == null ? void 0 : M.get(se)) ?? null, this._$Em = null;
        }
    }
    requestUpdate(E, j, K) {
        var se;
        if (E !== void 0) {
            const Te = this.constructor, M = this[E];
            if (K ?? (K = Te.getPropertyOptions(E)), !((K.hasChanged ?? Tu)(M, j) || K.useDefault && K.reflect && M === ((se = this._$Ej) == null ? void 0 : se.get(E)) && !this.hasAttribute(Te._$Eu(E, K)))) return;
            this.C(E, j, K);
        }
        this.isUpdatePending === !1 && (this._$ES = this._$EP());
    }
    C(E, j, { useDefault: K, reflect: se, wrapped: Te }, M) {
        K && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(E) && (this._$Ej.set(E, M ?? j ?? this[E]), Te !== !0 || M !== void 0) || (this._$AL.has(E) || (this.hasUpdated || K || (j = void 0), this._$AL.set(E, j)), se === !0 && this._$Em !== E && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(E));
    }
    async _$EP() {
        this.isUpdatePending = !0;
        try {
            await this._$ES;
        } catch (j) {
            Promise.reject(j);
        }
        const E = this.scheduleUpdate();
        return E != null && await E, !this.isUpdatePending;
    }
    scheduleUpdate() {
        return this.performUpdate();
    }
    performUpdate() {
        var K;
        if (!this.isUpdatePending) return;
        if (!this.hasUpdated) {
            if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
                for (const [Te, M] of this._$Ep) this[Te] = M;
                this._$Ep = void 0;
            }
            const se = this.constructor.elementProperties;
            if (se.size > 0) for (const [Te, M] of se) {
                const { wrapped: c } = M, Fe = this[Te];
                c !== !0 || this._$AL.has(Te) || Fe === void 0 || this.C(Te, void 0, M, Fe);
            }
        }
        let E = !1;
        const j = this._$AL;
        try {
            E = this.shouldUpdate(j), E ? (this.willUpdate(j), (K = this._$EO) == null || K.forEach((se) => {
                var Te;
                return (Te = se.hostUpdate) == null ? void 0 : Te.call(se);
            }), this.update(j)) : this._$EM();
        } catch (se) {
            throw E = !1, this._$EM(), se;
        }
        E && this._$AE(j);
    }
    willUpdate(E) {
    }
    _$AE(E) {
        var j;
        (j = this._$EO) == null || j.forEach((K) => {
            var se;
            return (se = K.hostUpdated) == null ? void 0 : se.call(K);
        }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(E)), this.updated(E);
    }
    _$EM() {
        this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
    }
    get updateComplete() {
        return this.getUpdateComplete();
    }
    getUpdateComplete() {
        return this._$ES;
    }
    shouldUpdate(E) {
        return !0;
    }
    update(E) {
        this._$Eq && (this._$Eq = this._$Eq.forEach((j) => this._$ET(j, this[j]))), this._$EM();
    }
    updated(E) {
    }
    firstUpdated(E) {
    }
};
ho.elementStyles = [], ho.shadowRootOptions = { mode: "open" }, ho[Ml("elementProperties")] = /* @__PURE__ */ new Map(), ho[Ml("finalized")] = /* @__PURE__ */ new Map(), _u == null || _u({ ReactiveElement: ho }), (on.reactiveElementVersions ?? (on.reactiveElementVersions = [])).push("2.1.0");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Il = globalThis, Xc = Il.trustedTypes, gd = Xc ? Xc.createPolicy("lit-html", { createHTML: (Q) => Q }) : void 0, Cd = "$lit$", sn = `lit$${Math.random().toFixed(9).slice(2)}$`, Ad = "?" + sn, Am = `<${Ad}>`, os = document, kl = () => os.createComment(""), zl = (Q) => Q === null || typeof Q != "object" && typeof Q != "function", Pu = Array.isArray, km = (Q) => Pu(Q) || typeof (Q == null ? void 0 : Q[Symbol.iterator]) == "function", yu = `[ 	
\f\r]`, Pl = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, _d = /-->/g, yd = />/g, rs = RegExp(`>|${yu}(?:([^\\s"'>=/]+)(${yu}*=${yu}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), vd = /'/g, xd = /"/g, kd = /^(?:script|style|textarea|title)$/i, zm = (Q) => (E, ...j) => ({ _$litType$: Q, strings: E, values: j }), Em = zm(1), uo = Symbol.for("lit-noChange"), oi = Symbol.for("lit-nothing"), bd = /* @__PURE__ */ new WeakMap(), ns = os.createTreeWalker(os, 129);
function zd(Q, E) {
    if (!Pu(Q) || !Q.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return gd !== void 0 ? gd.createHTML(E) : E;
}
const Rm = (Q, E) => {
    const j = Q.length - 1, K = [];
    let se, Te = E === 2 ? "<svg>" : E === 3 ? "<math>" : "", M = Pl;
    for (let c = 0; c < j; c++) {
        const Fe = Q[c];
        let ht, _t, ct = -1, Ue = 0;
        for (; Ue < Fe.length && (M.lastIndex = Ue, _t = M.exec(Fe), _t !== null);) Ue = M.lastIndex, M === Pl ? _t[1] === "!--" ? M = _d : _t[1] !== void 0 ? M = yd : _t[2] !== void 0 ? (kd.test(_t[2]) && (se = RegExp("</" + _t[2], "g")), M = rs) : _t[3] !== void 0 && (M = rs) : M === rs ? _t[0] === ">" ? (M = se ?? Pl, ct = -1) : _t[1] === void 0 ? ct = -2 : (ct = M.lastIndex - _t[2].length, ht = _t[1], M = _t[3] === void 0 ? rs : _t[3] === '"' ? xd : vd) : M === xd || M === vd ? M = rs : M === _d || M === yd ? M = Pl : (M = rs, se = void 0);
        const de = M === rs && Q[c + 1].startsWith("/>") ? " " : "";
        Te += M === Pl ? Fe + Am : ct >= 0 ? (K.push(ht), Fe.slice(0, ct) + Cd + Fe.slice(ct) + sn + de) : Fe + sn + (ct === -2 ? c : de);
    }
    return [zd(Q, Te + (Q[j] || "<?>") + (E === 2 ? "</svg>" : E === 3 ? "</math>" : "")), K];
};
class El {
    constructor({ strings: E, _$litType$: j }, K) {
        let se;
        this.parts = [];
        let Te = 0, M = 0;
        const c = E.length - 1, Fe = this.parts, [ht, _t] = Rm(E, j);
        if (this.el = El.createElement(ht, K), ns.currentNode = this.el.content, j === 2 || j === 3) {
            const ct = this.el.content.firstChild;
            ct.replaceWith(...ct.childNodes);
        }
        for (; (se = ns.nextNode()) !== null && Fe.length < c;) {
            if (se.nodeType === 1) {
                if (se.hasAttributes()) for (const ct of se.getAttributeNames()) if (ct.endsWith(Cd)) {
                    const Ue = _t[M++], de = se.getAttribute(ct).split(sn), $e = /([.?@])?(.*)/.exec(Ue);
                    Fe.push({ type: 1, index: Te, name: $e[2], strings: de, ctor: $e[1] === "." ? Lm : $e[1] === "?" ? Bm : $e[1] === "@" ? Fm : Jc }), se.removeAttribute(ct);
                } else ct.startsWith(sn) && (Fe.push({ type: 6, index: Te }), se.removeAttribute(ct));
                if (kd.test(se.tagName)) {
                    const ct = se.textContent.split(sn), Ue = ct.length - 1;
                    if (Ue > 0) {
                        se.textContent = Xc ? Xc.emptyScript : "";
                        for (let de = 0; de < Ue; de++) se.append(ct[de], kl()), ns.nextNode(), Fe.push({ type: 2, index: ++Te });
                        se.append(ct[Ue], kl());
                    }
                }
            } else if (se.nodeType === 8) if (se.data === Ad) Fe.push({ type: 2, index: Te });
            else {
                let ct = -1;
                for (; (ct = se.data.indexOf(sn, ct + 1)) !== -1;) Fe.push({ type: 7, index: Te }), ct += sn.length - 1;
            }
            Te++;
        }
    }
    static createElement(E, j) {
        const K = os.createElement("template");
        return K.innerHTML = E, K;
    }
}
function po(Q, E, j = Q, K) {
    var M, c;
    if (E === uo) return E;
    let se = K !== void 0 ? (M = j._$Co) == null ? void 0 : M[K] : j._$Cl;
    const Te = zl(E) ? void 0 : E._$litDirective$;
    return (se == null ? void 0 : se.constructor) !== Te && ((c = se == null ? void 0 : se._$AO) == null || c.call(se, !1), Te === void 0 ? se = void 0 : (se = new Te(Q), se._$AT(Q, j, K)), K !== void 0 ? (j._$Co ?? (j._$Co = []))[K] = se : j._$Cl = se), se !== void 0 && (E = po(Q, se._$AS(Q, E.values), se, K)), E;
}
class Dm {
    constructor(E, j) {
        this._$AV = [], this._$AN = void 0, this._$AD = E, this._$AM = j;
    }
    get parentNode() {
        return this._$AM.parentNode;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    u(E) {
        const { el: { content: j }, parts: K } = this._$AD, se = ((E == null ? void 0 : E.creationScope) ?? os).importNode(j, !0);
        ns.currentNode = se;
        let Te = ns.nextNode(), M = 0, c = 0, Fe = K[0];
        for (; Fe !== void 0;) {
            if (M === Fe.index) {
                let ht;
                Fe.type === 2 ? ht = new Dl(Te, Te.nextSibling, this, E) : Fe.type === 1 ? ht = new Fe.ctor(Te, Fe.name, Fe.strings, this, E) : Fe.type === 6 && (ht = new Nm(Te, this, E)), this._$AV.push(ht), Fe = K[++c];
            }
            M !== (Fe == null ? void 0 : Fe.index) && (Te = ns.nextNode(), M++);
        }
        return ns.currentNode = os, se;
    }
    p(E) {
        let j = 0;
        for (const K of this._$AV) K !== void 0 && (K.strings !== void 0 ? (K._$AI(E, K, j), j += K.strings.length - 2) : K._$AI(E[j])), j++;
    }
}
class Dl {
    get _$AU() {
        var E;
        return ((E = this._$AM) == null ? void 0 : E._$AU) ?? this._$Cv;
    }
    constructor(E, j, K, se) {
        this.type = 2, this._$AH = oi, this._$AN = void 0, this._$AA = E, this._$AB = j, this._$AM = K, this.options = se, this._$Cv = (se == null ? void 0 : se.isConnected) ?? !0;
    }
    get parentNode() {
        let E = this._$AA.parentNode;
        const j = this._$AM;
        return j !== void 0 && (E == null ? void 0 : E.nodeType) === 11 && (E = j.parentNode), E;
    }
    get startNode() {
        return this._$AA;
    }
    get endNode() {
        return this._$AB;
    }
    _$AI(E, j = this) {
        E = po(this, E, j), zl(E) ? E === oi || E == null || E === "" ? (this._$AH !== oi && this._$AR(), this._$AH = oi) : E !== this._$AH && E !== uo && this._(E) : E._$litType$ !== void 0 ? this.$(E) : E.nodeType !== void 0 ? this.T(E) : km(E) ? this.k(E) : this._(E);
    }
    O(E) {
        return this._$AA.parentNode.insertBefore(E, this._$AB);
    }
    T(E) {
        this._$AH !== E && (this._$AR(), this._$AH = this.O(E));
    }
    _(E) {
        this._$AH !== oi && zl(this._$AH) ? this._$AA.nextSibling.data = E : this.T(os.createTextNode(E)), this._$AH = E;
    }
    $(E) {
        var Te;
        const { values: j, _$litType$: K } = E, se = typeof K == "number" ? this._$AC(E) : (K.el === void 0 && (K.el = El.createElement(zd(K.h, K.h[0]), this.options)), K);
        if (((Te = this._$AH) == null ? void 0 : Te._$AD) === se) this._$AH.p(j);
        else {
            const M = new Dm(se, this), c = M.u(this.options);
            M.p(j), this.T(c), this._$AH = M;
        }
    }
    _$AC(E) {
        let j = bd.get(E.strings);
        return j === void 0 && bd.set(E.strings, j = new El(E)), j;
    }
    k(E) {
        Pu(this._$AH) || (this._$AH = [], this._$AR());
        const j = this._$AH;
        let K, se = 0;
        for (const Te of E) se === j.length ? j.push(K = new Dl(this.O(kl()), this.O(kl()), this, this.options)) : K = j[se], K._$AI(Te), se++;
        se < j.length && (this._$AR(K && K._$AB.nextSibling, se), j.length = se);
    }
    _$AR(E = this._$AA.nextSibling, j) {
        var K;
        for ((K = this._$AP) == null ? void 0 : K.call(this, !1, !0, j); E && E !== this._$AB;) {
            const se = E.nextSibling;
            E.remove(), E = se;
        }
    }
    setConnected(E) {
        var j;
        this._$AM === void 0 && (this._$Cv = E, (j = this._$AP) == null || j.call(this, E));
    }
}
class Jc {
    get tagName() {
        return this.element.tagName;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    constructor(E, j, K, se, Te) {
        this.type = 1, this._$AH = oi, this._$AN = void 0, this.element = E, this.name = j, this._$AM = se, this.options = Te, K.length > 2 || K[0] !== "" || K[1] !== "" ? (this._$AH = Array(K.length - 1).fill(new String()), this.strings = K) : this._$AH = oi;
    }
    _$AI(E, j = this, K, se) {
        const Te = this.strings;
        let M = !1;
        if (Te === void 0) E = po(this, E, j, 0), M = !zl(E) || E !== this._$AH && E !== uo, M && (this._$AH = E);
        else {
            const c = E;
            let Fe, ht;
            for (E = Te[0], Fe = 0; Fe < Te.length - 1; Fe++) ht = po(this, c[K + Fe], j, Fe), ht === uo && (ht = this._$AH[Fe]), M || (M = !zl(ht) || ht !== this._$AH[Fe]), ht === oi ? E = oi : E !== oi && (E += (ht ?? "") + Te[Fe + 1]), this._$AH[Fe] = ht;
        }
        M && !se && this.j(E);
    }
    j(E) {
        E === oi ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, E ?? "");
    }
}
class Lm extends Jc {
    constructor() {
        super(...arguments), this.type = 3;
    }
    j(E) {
        this.element[this.name] = E === oi ? void 0 : E;
    }
}
class Bm extends Jc {
    constructor() {
        super(...arguments), this.type = 4;
    }
    j(E) {
        this.element.toggleAttribute(this.name, !!E && E !== oi);
    }
}
class Fm extends Jc {
    constructor(E, j, K, se, Te) {
        super(E, j, K, se, Te), this.type = 5;
    }
    _$AI(E, j = this) {
        if ((E = po(this, E, j, 0) ?? oi) === uo) return;
        const K = this._$AH, se = E === oi && K !== oi || E.capture !== K.capture || E.once !== K.once || E.passive !== K.passive, Te = E !== oi && (K === oi || se);
        se && this.element.removeEventListener(this.name, this, K), Te && this.element.addEventListener(this.name, this, E), this._$AH = E;
    }
    handleEvent(E) {
        var j;
        typeof this._$AH == "function" ? this._$AH.call(((j = this.options) == null ? void 0 : j.host) ?? this.element, E) : this._$AH.handleEvent(E);
    }
}
class Nm {
    constructor(E, j, K) {
        this.element = E, this.type = 6, this._$AN = void 0, this._$AM = j, this.options = K;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AI(E) {
        po(this, E);
    }
}
const vu = Il.litHtmlPolyfillSupport;
vu == null || vu(El, Dl), (Il.litHtmlVersions ?? (Il.litHtmlVersions = [])).push("3.3.0");
const Om = (Q, E, j) => {
    const K = (j == null ? void 0 : j.renderBefore) ?? E;
    let se = K._$litPart$;
    if (se === void 0) {
        const Te = (j == null ? void 0 : j.renderBefore) ?? null;
        K._$litPart$ = se = new Dl(E.insertBefore(kl(), Te), Te, void 0, j ?? {});
    }
    return se._$AI(Q), se;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ss = globalThis;
let Cl = class extends ho {
    constructor() {
        super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
    }
    createRenderRoot() {
        var j;
        const E = super.createRenderRoot();
        return (j = this.renderOptions).renderBefore ?? (j.renderBefore = E.firstChild), E;
    }
    update(E) {
        const j = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(E), this._$Do = Om(j, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
        var E;
        super.connectedCallback(), (E = this._$Do) == null || E.setConnected(!0);
    }
    disconnectedCallback() {
        var E;
        super.disconnectedCallback(), (E = this._$Do) == null || E.setConnected(!1);
    }
    render() {
        return uo;
    }
};
var Pd;
Cl._$litElement$ = !0, Cl.finalized = !0, (Pd = ss.litElementHydrateSupport) == null || Pd.call(ss, { LitElement: Cl });
const xu = ss.litElementPolyfillSupport;
xu == null || xu({ LitElement: Cl });
(ss.litElementVersions ?? (ss.litElementVersions = [])).push("4.2.0");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const jm = (Q) => (E, j) => {
    j !== void 0 ? j.addInitializer(() => {
        customElements.define(Q, E);
    }) : customElements.define(Q, E);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const $m = { attribute: !0, type: String, converter: Wc, reflect: !1, hasChanged: Tu }, Um = (Q = $m, E, j) => {
    const { kind: K, metadata: se } = j;
    let Te = globalThis.litPropertyMetadata.get(se);
    if (Te === void 0 && globalThis.litPropertyMetadata.set(se, Te = /* @__PURE__ */ new Map()), K === "setter" && ((Q = Object.create(Q)).wrapped = !0), Te.set(j.name, Q), K === "accessor") {
        const { name: M } = j;
        return {
            set(c) {
                const Fe = E.get.call(this);
                E.set.call(this, c), this.requestUpdate(M, Fe, Q);
            }, init(c) {
                return c !== void 0 && this.C(M, void 0, Q, c), c;
            }
        };
    }
    if (K === "setter") {
        const { name: M } = j;
        return function (c) {
            const Fe = this[M];
            E.call(this, c), this.requestUpdate(M, Fe, Q);
        };
    }
    throw Error("Unsupported decorator location: " + K);
};
function fo(Q) {
    return (E, j) => typeof j == "object" ? Um(Q, E, j) : ((K, se, Te) => {
        const M = se.hasOwnProperty(Te);
        return se.constructor.createProperty(Te, K), M ? Object.getOwnPropertyDescriptor(se, Te) : void 0;
    })(Q, E, j);
}
function Vm(Q) {
    return Q && Q.__esModule && Object.prototype.hasOwnProperty.call(Q, "default") ? Q.default : Q;
}
var Hc = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.5.0/LICENSE.txt
 */
var Zm = Hc.exports, wd;
function Gm() {
    return wd || (wd = 1, function (Q, E) {
        (function (j, K) {
            Q.exports = K();
        })(Zm, function () {
            var j = {}, K = {};
            function se(M, c, Fe) {
                if (K[M] = Fe, M === "index") {
                    var ht = "var sharedModule = {}; (" + K.shared + ")(sharedModule); (" + K.worker + ")(sharedModule);", _t = {};
                    return K.shared(_t), K.index(j, _t), typeof window < "u" && j.setWorkerUrl(window.URL.createObjectURL(new Blob([ht], { type: "text/javascript" }))), j;
                }
            }
            se("shared", ["exports"], function (M) {
                function c(a, t, r, n) {
                    return new (r || (r = Promise))(function (l, p) {
                        function d(v) {
                            try {
                                _(n.next(v));
                            } catch (b) {
                                p(b);
                            }
                        }
                        function m(v) {
                            try {
                                _(n.throw(v));
                            } catch (b) {
                                p(b);
                            }
                        }
                        function _(v) {
                            var b;
                            v.done ? l(v.value) : (b = v.value, b instanceof r ? b : new r(function (S) {
                                S(b);
                            })).then(d, m);
                        }
                        _((n = n.apply(a, t || [])).next());
                    });
                }
                function Fe(a) {
                    return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
                }
                var ht, _t;
                function ct() {
                    if (_t) return ht;
                    function a(t, r) {
                        this.x = t, this.y = r;
                    }
                    return _t = 1, ht = a, a.prototype = {
                        clone: function () {
                            return new a(this.x, this.y);
                        }, add: function (t) {
                            return this.clone()._add(t);
                        }, sub: function (t) {
                            return this.clone()._sub(t);
                        }, multByPoint: function (t) {
                            return this.clone()._multByPoint(t);
                        }, divByPoint: function (t) {
                            return this.clone()._divByPoint(t);
                        }, mult: function (t) {
                            return this.clone()._mult(t);
                        }, div: function (t) {
                            return this.clone()._div(t);
                        }, rotate: function (t) {
                            return this.clone()._rotate(t);
                        }, rotateAround: function (t, r) {
                            return this.clone()._rotateAround(t, r);
                        }, matMult: function (t) {
                            return this.clone()._matMult(t);
                        }, unit: function () {
                            return this.clone()._unit();
                        }, perp: function () {
                            return this.clone()._perp();
                        }, round: function () {
                            return this.clone()._round();
                        }, mag: function () {
                            return Math.sqrt(this.x * this.x + this.y * this.y);
                        }, equals: function (t) {
                            return this.x === t.x && this.y === t.y;
                        }, dist: function (t) {
                            return Math.sqrt(this.distSqr(t));
                        }, distSqr: function (t) {
                            var r = t.x - this.x, n = t.y - this.y;
                            return r * r + n * n;
                        }, angle: function () {
                            return Math.atan2(this.y, this.x);
                        }, angleTo: function (t) {
                            return Math.atan2(this.y - t.y, this.x - t.x);
                        }, angleWith: function (t) {
                            return this.angleWithSep(t.x, t.y);
                        }, angleWithSep: function (t, r) {
                            return Math.atan2(this.x * r - this.y * t, this.x * t + this.y * r);
                        }, _matMult: function (t) {
                            var r = t[2] * this.x + t[3] * this.y;
                            return this.x = t[0] * this.x + t[1] * this.y, this.y = r, this;
                        }, _add: function (t) {
                            return this.x += t.x, this.y += t.y, this;
                        }, _sub: function (t) {
                            return this.x -= t.x, this.y -= t.y, this;
                        }, _mult: function (t) {
                            return this.x *= t, this.y *= t, this;
                        }, _div: function (t) {
                            return this.x /= t, this.y /= t, this;
                        }, _multByPoint: function (t) {
                            return this.x *= t.x, this.y *= t.y, this;
                        }, _divByPoint: function (t) {
                            return this.x /= t.x, this.y /= t.y, this;
                        }, _unit: function () {
                            return this._div(this.mag()), this;
                        }, _perp: function () {
                            var t = this.y;
                            return this.y = this.x, this.x = -t, this;
                        }, _rotate: function (t) {
                            var r = Math.cos(t), n = Math.sin(t), l = n * this.x + r * this.y;
                            return this.x = r * this.x - n * this.y, this.y = l, this;
                        }, _rotateAround: function (t, r) {
                            var n = Math.cos(t), l = Math.sin(t), p = r.y + l * (this.x - r.x) + n * (this.y - r.y);
                            return this.x = r.x + n * (this.x - r.x) - l * (this.y - r.y), this.y = p, this;
                        }, _round: function () {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
                        }
                    }, a.convert = function (t) {
                        return t instanceof a ? t : Array.isArray(t) ? new a(t[0], t[1]) : t;
                    }, ht;
                }
                typeof SuppressedError == "function" && SuppressedError;
                var Ue, de, $e = Fe(ct()), lr = function () {
                    if (de) return Ue;
                    function a(t, r, n, l) {
                        this.cx = 3 * t, this.bx = 3 * (n - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (l - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = n, this.p2y = l;
                    }
                    return de = 1, Ue = a, a.prototype = {
                        sampleCurveX: function (t) {
                            return ((this.ax * t + this.bx) * t + this.cx) * t;
                        }, sampleCurveY: function (t) {
                            return ((this.ay * t + this.by) * t + this.cy) * t;
                        }, sampleCurveDerivativeX: function (t) {
                            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
                        }, solveCurveX: function (t, r) {
                            if (r === void 0 && (r = 1e-6), t < 0) return 0;
                            if (t > 1) return 1;
                            for (var n = t, l = 0; l < 8; l++) {
                                var p = this.sampleCurveX(n) - t;
                                if (Math.abs(p) < r) return n;
                                var d = this.sampleCurveDerivativeX(n);
                                if (Math.abs(d) < 1e-6) break;
                                n -= p / d;
                            }
                            var m = 0, _ = 1;
                            for (n = t, l = 0; l < 20 && (p = this.sampleCurveX(n), !(Math.abs(p - t) < r)); l++) t > p ? m = n : _ = n, n = 0.5 * (_ - m) + m;
                            return n;
                        }, solve: function (t, r) {
                            return this.sampleCurveY(this.solveCurveX(t, r));
                        }
                    }, Ue;
                }(), cr = Fe(lr);
                let wr, Qr;
                function ln() {
                    return wr == null && (wr = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), wr;
                }
                function bi() {
                    if (Qr == null && (Qr = !1, ln())) {
                        const t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
                        if (t) {
                            for (let n = 0; n < 5 * 5; n++) {
                                const l = 4 * n;
                                t.fillStyle = `rgb(${l},${l + 1},${l + 2})`, t.fillRect(n % 5, Math.floor(n / 5), 1, 1);
                            }
                            const r = t.getImageData(0, 0, 5, 5).data;
                            for (let n = 0; n < 5 * 5 * 4; n++) if (n % 4 != 3 && r[n] !== n) {
                                Qr = !0;
                                break;
                            }
                        }
                    }
                    return Qr || !1;
                }
                var Zt = 1e-6, Rt = typeof Float32Array < "u" ? Float32Array : Array;
                function hr() {
                    var a = new Rt(9);
                    return Rt != Float32Array && (a[1] = 0, a[2] = 0, a[3] = 0, a[5] = 0, a[6] = 0, a[7] = 0), a[0] = 1, a[4] = 1, a[8] = 1, a;
                }
                function Dt(a) {
                    return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
                }
                function cs() {
                    var a = new Rt(3);
                    return Rt != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0), a;
                }
                function hs(a) {
                    return Math.hypot(a[0], a[1], a[2]);
                }
                function Br(a, t, r) {
                    var n = new Rt(3);
                    return n[0] = a, n[1] = t, n[2] = r, n;
                }
                Math.hypot || (Math.hypot = function () {
                    for (var a = 0, t = arguments.length; t--;) a += arguments[t] * arguments[t];
                    return Math.sqrt(a);
                });
                var ur, Ji = hs;
                function mi(a, t, r) {
                    var n = t[0], l = t[1], p = t[2], d = t[3];
                    return a[0] = r[0] * n + r[4] * l + r[8] * p + r[12] * d, a[1] = r[1] * n + r[5] * l + r[9] * p + r[13] * d, a[2] = r[2] * n + r[6] * l + r[10] * p + r[14] * d, a[3] = r[3] * n + r[7] * l + r[11] * p + r[15] * d, a;
                }
                function cn() {
                    var a = new Rt(4);
                    return Rt != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0), a[3] = 1, a;
                }
                function Sa() {
                    var a = new Rt(2);
                    return Rt != Float32Array && (a[0] = 0, a[1] = 0), a;
                }
                function hn(a, t) {
                    var r = new Rt(2);
                    return r[0] = a, r[1] = t, r;
                }
                cs(), ur = new Rt(4), Rt != Float32Array && (ur[0] = 0, ur[1] = 0, ur[2] = 0, ur[3] = 0), cs(), Br(1, 0, 0), Br(0, 1, 0), cn(), cn(), hr(), Sa();
                const yt = 8192;
                function Fr(a, t, r) {
                    return t * (yt / (a.tileSize * Math.pow(2, r - a.tileID.overscaledZ)));
                }
                function pr(a, t) {
                    return (a % t + t) % t;
                }
                function Ta(a, t, r) {
                    return a * (1 - r) + t * r;
                }
                function Qi(a) {
                    if (a <= 0) return 0;
                    if (a >= 1) return 1;
                    const t = a * a, r = t * a;
                    return 4 * (a < 0.5 ? r : 3 * (a - t) + r - 0.75);
                }
                function us(a, t, r, n) {
                    const l = new cr(a, t, r, n);
                    return (p) => l.solve(p);
                }
                const er = us(0.25, 0.1, 0.25, 1);
                function li(a, t, r) {
                    return Math.min(r, Math.max(t, a));
                }
                function Nr(a, t, r) {
                    const n = r - t, l = ((a - t) % n + n) % n + t;
                    return l === t ? r : l;
                }
                function Di(a, ...t) {
                    for (const r of t) for (const n in r) a[n] = r[n];
                    return a;
                }
                let Pa = 1;
                function ea(a, t, r) {
                    const n = {};
                    for (const l in a) n[l] = t.call(this, a[l], l, a);
                    return n;
                }
                function un(a, t, r) {
                    const n = {};
                    for (const l in a) t.call(this, a[l], l, a) && (n[l] = a[l]);
                    return n;
                }
                function Li(a) {
                    return Array.isArray(a) ? a.map(Li) : typeof a == "object" && a ? ea(a, Li) : a;
                }
                const Bi = {};
                function wi(a) {
                    Bi[a] || (typeof console < "u" && console.warn(a), Bi[a] = !0);
                }
                function bt(a, t, r) {
                    return (r.y - a.y) * (t.x - a.x) > (t.y - a.y) * (r.x - a.x);
                }
                function dr(a) {
                    return typeof WorkerGlobalScope < "u" && a !== void 0 && a instanceof WorkerGlobalScope;
                }
                let Or = null;
                function Gi(a) {
                    return typeof ImageBitmap < "u" && a instanceof ImageBitmap;
                }
                const pn = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
                function dn(a, t, r, n, l) {
                    return c(this, void 0, void 0, function* () {
                        if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
                        const p = new VideoFrame(a, { timestamp: 0 });
                        try {
                            const d = p == null ? void 0 : p.format;
                            if (!d || !d.startsWith("BGR") && !d.startsWith("RGB")) throw new Error(`Unrecognized format ${d}`);
                            const m = d.startsWith("BGR"), _ = new Uint8ClampedArray(n * l * 4);
                            if (yield p.copyTo(_, function (v, b, S, I, A) {
                                const k = 4 * Math.max(1, 0), D = (Math.max(0, S) - S) * I * 4 + k, N = 4 * I, G = Math.max(0, b), ie = Math.max(0, S);
                                return { rect: { x: G, y: ie, width: Math.min(v.width, b + I) - G, height: Math.min(v.height, S + A) - ie }, layout: [{ offset: D, stride: N }] };
                            }(a, t, r, n, l)), m) for (let v = 0; v < _.length; v += 4) {
                                const b = _[v];
                                _[v] = _[v + 2], _[v + 2] = b;
                            }
                            return _;
                        } finally {
                            p.close();
                        }
                    });
                }
                let Fi, fr;
                function ta(a, t, r, n) {
                    return a.addEventListener(t, r, n), {
                        unsubscribe: () => {
                            a.removeEventListener(t, r, n);
                        }
                    };
                }
                function ia(a) {
                    return a * Math.PI / 180;
                }
                function Sr(a) {
                    return a / Math.PI * 180;
                }
                const Ma = { touchstart: !0, touchmove: !0, touchmoveWindow: !0, touchend: !0, touchcancel: !0 }, Ia = { dblclick: !0, click: !0, mouseover: !0, mouseout: !0, mousedown: !0, mousemove: !0, mousemoveWindow: !0, mouseup: !0, mouseupWindow: !0, contextmenu: !0, wheel: !0 }, Ca = "AbortError";
                function Tr() {
                    return new Error(Ca);
                }
                const Pr = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
                function jr(a) {
                    return Pr.REGISTERED_PROTOCOLS[a.substring(0, a.indexOf("://"))];
                }
                const Aa = "global-dispatcher";
                class qi extends Error {
                    constructor(t, r, n, l) {
                        super(`AJAXError: ${r} (${t}): ${n}`), this.status = t, this.statusText = r, this.url = n, this.body = l;
                    }
                }
                const Ai = () => dr(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, mr = function (a, t) {
                    if (/:\/\//.test(a.url) && !/^https?:|^file:/.test(a.url)) {
                        const n = jr(a.url);
                        if (n) return n(a, t);
                        if (dr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: a, targetMapId: Aa }, t);
                    }
                    if (!(/^file:/.test(r = a.url) || /^file:/.test(Ai()) && !/^\w+:/.test(r))) {
                        if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function (n, l) {
                            return c(this, void 0, void 0, function* () {
                                const p = new Request(n.url, { method: n.method || "GET", body: n.body, credentials: n.credentials, headers: n.headers, cache: n.cache, referrer: Ai(), signal: l.signal });
                                let d, m;
                                n.type !== "json" || p.headers.has("Accept") || p.headers.set("Accept", "application/json");
                                try {
                                    d = yield fetch(p);
                                } catch (v) {
                                    throw new qi(0, v.message, n.url, new Blob());
                                }
                                if (!d.ok) {
                                    const v = yield d.blob();
                                    throw new qi(d.status, d.statusText, n.url, v);
                                }
                                m = n.type === "arrayBuffer" || n.type === "image" ? d.arrayBuffer() : n.type === "json" ? d.json() : d.text();
                                const _ = yield m;
                                if (l.signal.aborted) throw Tr();
                                return { data: _, cacheControl: d.headers.get("Cache-Control"), expires: d.headers.get("Expires") };
                            });
                        }(a, t);
                        if (dr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: a, mustQueue: !0, targetMapId: Aa }, t);
                    }
                    var r;
                    return function (n, l) {
                        return new Promise((p, d) => {
                            var m;
                            const _ = new XMLHttpRequest();
                            _.open(n.method || "GET", n.url, !0), n.type !== "arrayBuffer" && n.type !== "image" || (_.responseType = "arraybuffer");
                            for (const v in n.headers) _.setRequestHeader(v, n.headers[v]);
                            n.type === "json" && (_.responseType = "text", !((m = n.headers) === null || m === void 0) && m.Accept || _.setRequestHeader("Accept", "application/json")), _.withCredentials = n.credentials === "include", _.onerror = () => {
                                d(new Error(_.statusText));
                            }, _.onload = () => {
                                if (!l.signal.aborted) if ((_.status >= 200 && _.status < 300 || _.status === 0) && _.response !== null) {
                                    let v = _.response;
                                    if (n.type === "json") try {
                                        v = JSON.parse(_.response);
                                    } catch (b) {
                                        return void d(b);
                                    }
                                    p({ data: v, cacheControl: _.getResponseHeader("Cache-Control"), expires: _.getResponseHeader("Expires") });
                                } else {
                                    const v = new Blob([_.response], { type: _.getResponseHeader("Content-Type") });
                                    d(new qi(_.status, _.statusText, n.url, v));
                                }
                            }, l.signal.addEventListener("abort", () => {
                                _.abort(), d(Tr());
                            }), _.send(n.body);
                        });
                    }(a, t);
                };
                function oe(a) {
                    if (!a || a.indexOf("://") <= 0 || a.indexOf("data:image/") === 0 || a.indexOf("blob:") === 0) return !0;
                    const t = new URL(a), r = window.location;
                    return t.protocol === r.protocol && t.host === r.host;
                }
                function L(a, t, r) {
                    r[a] && r[a].indexOf(t) !== -1 || (r[a] = r[a] || [], r[a].push(t));
                }
                function B(a, t, r) {
                    if (r && r[a]) {
                        const n = r[a].indexOf(t);
                        n !== -1 && r[a].splice(n, 1);
                    }
                }
                class $ {
                    constructor(t, r = {}) {
                        Di(this, r), this.type = t;
                    }
                }
                class W extends $ {
                    constructor(t, r = {}) {
                        super("error", Di({ error: t }, r));
                    }
                }
                class re {
                    on(t, r) {
                        return this._listeners = this._listeners || {}, L(t, r, this._listeners), {
                            unsubscribe: () => {
                                this.off(t, r);
                            }
                        };
                    }
                    off(t, r) {
                        return B(t, r, this._listeners), B(t, r, this._oneTimeListeners), this;
                    }
                    once(t, r) {
                        return r ? (this._oneTimeListeners = this._oneTimeListeners || {}, L(t, r, this._oneTimeListeners), this) : new Promise((n) => this.once(t, n));
                    }
                    fire(t, r) {
                        typeof t == "string" && (t = new $(t, r || {}));
                        const n = t.type;
                        if (this.listens(n)) {
                            t.target = this;
                            const l = this._listeners && this._listeners[n] ? this._listeners[n].slice() : [];
                            for (const m of l) m.call(this, t);
                            const p = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : [];
                            for (const m of p) B(n, m, this._oneTimeListeners), m.call(this, t);
                            const d = this._eventedParent;
                            d && (Di(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), d.fire(t));
                        } else t instanceof W && console.error(t.error);
                        return this;
                    }
                    listens(t) {
                        return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);
                    }
                    setEventedParent(t, r) {
                        return this._eventedParent = t, this._eventedParentData = r, this;
                    }
                }
                var O = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
                const pe = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
                function ne(a, t) {
                    const r = {};
                    for (const n in a) n !== "ref" && (r[n] = a[n]);
                    return pe.forEach((n) => {
                        n in t && (r[n] = t[n]);
                    }), r;
                }
                function ce(a, t) {
                    if (Array.isArray(a)) {
                        if (!Array.isArray(t) || a.length !== t.length) return !1;
                        for (let r = 0; r < a.length; r++) if (!ce(a[r], t[r])) return !1;
                        return !0;
                    }
                    if (typeof a == "object" && a !== null && t !== null) {
                        if (typeof t != "object" || Object.keys(a).length !== Object.keys(t).length) return !1;
                        for (const r in a) if (!ce(a[r], t[r])) return !1;
                        return !0;
                    }
                    return a === t;
                }
                function fe(a, t) {
                    a.push(t);
                }
                function le(a, t, r) {
                    fe(r, { command: "addSource", args: [a, t[a]] });
                }
                function Pe(a, t, r) {
                    fe(t, { command: "removeSource", args: [a] }), r[a] = !0;
                }
                function Re(a, t, r, n) {
                    Pe(a, r, n), le(a, t, r);
                }
                function De(a, t, r) {
                    let n;
                    for (n in a[r]) if (Object.prototype.hasOwnProperty.call(a[r], n) && n !== "data" && !ce(a[r][n], t[r][n])) return !1;
                    for (n in t[r]) if (Object.prototype.hasOwnProperty.call(t[r], n) && n !== "data" && !ce(a[r][n], t[r][n])) return !1;
                    return !0;
                }
                function Ze(a, t, r, n, l, p) {
                    a = a || {}, t = t || {};
                    for (const d in a) Object.prototype.hasOwnProperty.call(a, d) && (ce(a[d], t[d]) || r.push({ command: p, args: [n, d, t[d], l] }));
                    for (const d in t) Object.prototype.hasOwnProperty.call(t, d) && !Object.prototype.hasOwnProperty.call(a, d) && (ce(a[d], t[d]) || r.push({ command: p, args: [n, d, t[d], l] }));
                }
                function Ye(a) {
                    return a.id;
                }
                function Xe(a, t) {
                    return a[t.id] = t, a;
                }
                class ve {
                    constructor(t, r, n, l) {
                        this.message = (t ? `${t}: ` : "") + n, l && (this.identifier = l), r != null && r.__line__ && (this.line = r.__line__);
                    }
                }
                function gt(a, ...t) {
                    for (const r of t) for (const n in r) a[n] = r[n];
                    return a;
                }
                class nt extends Error {
                    constructor(t, r) {
                        super(r), this.message = r, this.key = t;
                    }
                }
                class dt {
                    constructor(t, r = []) {
                        this.parent = t, this.bindings = {};
                        for (const [n, l] of r) this.bindings[n] = l;
                    }
                    concat(t) {
                        return new dt(this, t);
                    }
                    get(t) {
                        if (this.bindings[t]) return this.bindings[t];
                        if (this.parent) return this.parent.get(t);
                        throw new Error(`${t} not found in scope.`);
                    }
                    has(t) {
                        return !!this.bindings[t] || !!this.parent && this.parent.has(t);
                    }
                }
                const We = { kind: "null" }, Se = { kind: "number" }, qe = { kind: "string" }, Je = { kind: "boolean" }, Lt = { kind: "color" }, Bt = { kind: "projectionDefinition" }, ki = { kind: "object" }, Qe = { kind: "value" }, ka = { kind: "collator" }, fn = { kind: "formatted" }, ra = { kind: "padding" }, mn = { kind: "colorArray" }, Mr = { kind: "numberArray" }, aa = { kind: "resolvedImage" }, $t = { kind: "variableAnchorOffsetCollection" };
                function Ni(a, t) {
                    return { kind: "array", itemType: a, N: t };
                }
                function It(a) {
                    if (a.kind === "array") {
                        const t = It(a.itemType);
                        return typeof a.N == "number" ? `array<${t}, ${a.N}>` : a.itemType.kind === "value" ? "array" : `array<${t}>`;
                    }
                    return a.kind;
                }
                const gn = [We, Se, qe, Je, Lt, Bt, fn, ki, Ni(Qe), ra, Mr, mn, aa, $t];
                function za(a, t) {
                    if (t.kind === "error") return null;
                    if (a.kind === "array") {
                        if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !za(a.itemType, t.itemType)) && (typeof a.N != "number" || a.N === t.N)) return null;
                    } else {
                        if (a.kind === t.kind) return null;
                        if (a.kind === "value") {
                            for (const r of gn) if (!za(r, t)) return null;
                        }
                    }
                    return `Expected ${It(a)} but found ${It(t)} instead.`;
                }
                function mo(a, t) {
                    return t.some((r) => r.kind === a.kind);
                }
                function na(a, t) {
                    return t.some((r) => r === "null" ? a === null : r === "array" ? Array.isArray(a) : r === "object" ? a && !Array.isArray(a) && typeof a == "object" : r === typeof a);
                }
                function Ir(a, t) {
                    return a.kind === "array" && t.kind === "array" ? a.itemType.kind === t.itemType.kind && typeof a.N == "number" : a.kind === t.kind;
                }
                const Ll = 0.96422, go = 0.82521, Bl = 4 / 29, Ea = 6 / 29, Fl = 3 * Ea * Ea, Qc = Ea * Ea * Ea, eh = Math.PI / 180, th = 180 / Math.PI;
                function Nl(a) {
                    return (a %= 360) < 0 && (a += 360), a;
                }
                function _o([a, t, r, n]) {
                    let l, p;
                    const d = yo((0.2225045 * (a = sa(a)) + 0.7168786 * (t = sa(t)) + 0.0606169 * (r = sa(r))) / 1);
                    a === t && t === r ? l = p = d : (l = yo((0.4360747 * a + 0.3850649 * t + 0.1430804 * r) / Ll), p = yo((0.0139322 * a + 0.0971045 * t + 0.7141733 * r) / go));
                    const m = 116 * d - 16;
                    return [m < 0 ? 0 : m, 500 * (l - d), 200 * (d - p), n];
                }
                function sa(a) {
                    return a <= 0.04045 ? a / 12.92 : Math.pow((a + 0.055) / 1.055, 2.4);
                }
                function yo(a) {
                    return a > Qc ? Math.pow(a, 1 / 3) : a / Fl + Bl;
                }
                function Ol([a, t, r, n]) {
                    let l = (a + 16) / 116, p = isNaN(t) ? l : l + t / 500, d = isNaN(r) ? l : l - r / 200;
                    return l = 1 * vo(l), p = Ll * vo(p), d = go * vo(d), [oa(3.1338561 * p - 1.6168667 * l - 0.4906146 * d), oa(-0.9787684 * p + 1.9161415 * l + 0.033454 * d), oa(0.0719453 * p - 0.2289914 * l + 1.4052427 * d), n];
                }
                function oa(a) {
                    return (a = a <= 304e-5 ? 12.92 * a : 1.055 * Math.pow(a, 1 / 2.4) - 0.055) < 0 ? 0 : a > 1 ? 1 : a;
                }
                function vo(a) {
                    return a > Ea ? a * a * a : Fl * (a - Bl);
                }
                const ih = Object.hasOwn || function (a, t) {
                    return Object.prototype.hasOwnProperty.call(a, t);
                };
                function _n(a, t) {
                    return ih(a, t) ? a[t] : void 0;
                }
                function yn(a) {
                    return parseInt(a.padEnd(2, a), 16) / 255;
                }
                function xo(a, t) {
                    return Si(t ? a / 100 : a, 0, 1);
                }
                function Si(a, t, r) {
                    return Math.min(Math.max(t, a), r);
                }
                function ut(a) {
                    return !a.some(Number.isNaN);
                }
                const Ra = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
                function Ti(a, t, r) {
                    return a + r * (t - a);
                }
                function la(a, t, r) {
                    return a.map((n, l) => Ti(n, t[l], r));
                }
                class st {
                    constructor(t, r, n, l = 1, p = !0) {
                        this.r = t, this.g = r, this.b = n, this.a = l, p || (this.r *= l, this.g *= l, this.b *= l, l || this.overwriteGetter("rgb", [t, r, n, l]));
                    }
                    static parse(t) {
                        if (t instanceof st) return t;
                        if (typeof t != "string") return;
                        const r = function (n) {
                            if ((n = n.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
                            const l = _n(Ra, n);
                            if (l) {
                                const [d, m, _] = l;
                                return [d / 255, m / 255, _ / 255, 1];
                            }
                            if (n.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(n)) {
                                const d = n.length < 6 ? 1 : 2;
                                let m = 1;
                                return [yn(n.slice(m, m += d)), yn(n.slice(m, m += d)), yn(n.slice(m, m += d)), yn(n.slice(m, m + d) || "ff")];
                            }
                            if (n.startsWith("rgb")) {
                                const d = n.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                                if (d) {
                                    const [m, _, v, b, S, I, A, k, D, N, G, ie] = d, H = [b || " ", A || " ", N].join("");
                                    if (H === "  " || H === "  /" || H === ",," || H === ",,,") {
                                        const C = [v, I, D].join(""), F = C === "%%%" ? 100 : C === "" ? 255 : 0;
                                        if (F) {
                                            const X = [Si(+_ / F, 0, 1), Si(+S / F, 0, 1), Si(+k / F, 0, 1), G ? xo(+G, ie) : 1];
                                            if (ut(X)) return X;
                                        }
                                    }
                                    return;
                                }
                            }
                            const p = n.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                            if (p) {
                                const [d, m, _, v, b, S, I, A, k] = p, D = [_ || " ", b || " ", I].join("");
                                if (D === "  " || D === "  /" || D === ",," || D === ",,,") {
                                    const N = [+m, Si(+v, 0, 100), Si(+S, 0, 100), A ? xo(+A, k) : 1];
                                    if (ut(N)) return function ([G, ie, H, C]) {
                                        function F(X) {
                                            const ue = (X + G / 30) % 12, Me = ie * Math.min(H, 1 - H);
                                            return H - Me * Math.max(-1, Math.min(ue - 3, 9 - ue, 1));
                                        }
                                        return G = Nl(G), ie /= 100, H /= 100, [F(0), F(8), F(4), C];
                                    }(N);
                                }
                            }
                        }(t);
                        return r ? new st(...r, !1) : void 0;
                    }
                    get rgb() {
                        const { r: t, g: r, b: n, a: l } = this, p = l || 1 / 0;
                        return this.overwriteGetter("rgb", [t / p, r / p, n / p, l]);
                    }
                    get hcl() {
                        return this.overwriteGetter("hcl", function (t) {
                            const [r, n, l, p] = _o(t), d = Math.sqrt(n * n + l * l);
                            return [Math.round(1e4 * d) ? Nl(Math.atan2(l, n) * th) : NaN, d, r, p];
                        }(this.rgb));
                    }
                    get lab() {
                        return this.overwriteGetter("lab", _o(this.rgb));
                    }
                    overwriteGetter(t, r) {
                        return Object.defineProperty(this, t, { value: r }), r;
                    }
                    toString() {
                        const [t, r, n, l] = this.rgb;
                        return `rgba(${[t, r, n].map((p) => Math.round(255 * p)).join(",")},${l})`;
                    }
                    static interpolate(t, r, n, l = "rgb") {
                        switch (l) {
                            case "rgb": {
                                const [p, d, m, _] = la(t.rgb, r.rgb, n);
                                return new st(p, d, m, _, !1);
                            }
                            case "hcl": {
                                const [p, d, m, _] = t.hcl, [v, b, S, I] = r.hcl;
                                let A, k;
                                if (isNaN(p) || isNaN(v)) isNaN(p) ? isNaN(v) ? A = NaN : (A = v, m !== 1 && m !== 0 || (k = b)) : (A = p, S !== 1 && S !== 0 || (k = d));
                                else {
                                    let H = v - p;
                                    v > p && H > 180 ? H -= 360 : v < p && p - v > 180 && (H += 360), A = p + n * H;
                                }
                                const [D, N, G, ie] = function ([H, C, F, X]) {
                                    return H = isNaN(H) ? 0 : H * eh, Ol([F, Math.cos(H) * C, Math.sin(H) * C, X]);
                                }([A, k ?? Ti(d, b, n), Ti(m, S, n), Ti(_, I, n)]);
                                return new st(D, N, G, ie, !1);
                            }
                            case "lab": {
                                const [p, d, m, _] = Ol(la(t.lab, r.lab, n));
                                return new st(p, d, m, _, !1);
                            }
                        }
                    }
                }
                st.black = new st(0, 0, 0, 1), st.white = new st(1, 1, 1, 1), st.transparent = new st(0, 0, 0, 0), st.red = new st(1, 0, 0, 1);
                class vn {
                    constructor(t, r, n) {
                        this.sensitivity = t ? r ? "variant" : "case" : r ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
                    }
                    compare(t, r) {
                        return this.collator.compare(t, r);
                    }
                    resolvedLocale() {
                        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
                    }
                }
                const xn = ["bottom", "center", "top"];
                class Da {
                    constructor(t, r, n, l, p, d) {
                        this.text = t, this.image = r, this.scale = n, this.fontStack = l, this.textColor = p, this.verticalAlign = d;
                    }
                }
                class zi {
                    constructor(t) {
                        this.sections = t;
                    }
                    static fromString(t) {
                        return new zi([new Da(t, null, null, null, null, null)]);
                    }
                    isEmpty() {
                        return this.sections.length === 0 || !this.sections.some((t) => t.text.length !== 0 || t.image && t.image.name.length !== 0);
                    }
                    static factory(t) {
                        return t instanceof zi ? t : zi.fromString(t);
                    }
                    toString() {
                        return this.sections.length === 0 ? "" : this.sections.map((t) => t.text).join("");
                    }
                }
                class ci {
                    constructor(t) {
                        this.values = t.slice();
                    }
                    static parse(t) {
                        if (t instanceof ci) return t;
                        if (typeof t == "number") return new ci([t, t, t, t]);
                        if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
                            for (const r of t) if (typeof r != "number") return;
                            switch (t.length) {
                                case 1:
                                    t = [t[0], t[0], t[0], t[0]];
                                    break;
                                case 2:
                                    t = [t[0], t[1], t[0], t[1]];
                                    break;
                                case 3:
                                    t = [t[0], t[1], t[2], t[1]];
                            }
                            return new ci(t);
                        }
                    }
                    toString() {
                        return JSON.stringify(this.values);
                    }
                    static interpolate(t, r, n) {
                        return new ci(la(t.values, r.values, n));
                    }
                }
                class Ut {
                    constructor(t) {
                        this.values = t.slice();
                    }
                    static parse(t) {
                        if (t instanceof Ut) return t;
                        if (typeof t == "number") return new Ut([t]);
                        if (Array.isArray(t)) {
                            for (const r of t) if (typeof r != "number") return;
                            return new Ut(t);
                        }
                    }
                    toString() {
                        return JSON.stringify(this.values);
                    }
                    static interpolate(t, r, n) {
                        return new Ut(la(t.values, r.values, n));
                    }
                }
                class hi {
                    constructor(t) {
                        this.values = t.slice();
                    }
                    static parse(t) {
                        if (t instanceof hi) return t;
                        if (typeof t == "string") {
                            const n = st.parse(t);
                            return n ? new hi([n]) : void 0;
                        }
                        if (!Array.isArray(t)) return;
                        const r = [];
                        for (const n of t) {
                            if (typeof n != "string") return;
                            const l = st.parse(n);
                            if (!l) return;
                            r.push(l);
                        }
                        return new hi(r);
                    }
                    toString() {
                        return JSON.stringify(this.values);
                    }
                    static interpolate(t, r, n, l = "rgb") {
                        const p = [];
                        if (t.values.length != r.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${r.values.length}), cannot interpolate.`);
                        for (let d = 0; d < t.values.length; d++) p.push(st.interpolate(t.values[d], r.values[d], n, l));
                        return new hi(p);
                    }
                }
                class St extends Error {
                    constructor(t) {
                        super(t), this.name = "RuntimeError";
                    }
                    toJSON() {
                        return this.message;
                    }
                }
                const La = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
                class Pi {
                    constructor(t) {
                        this.values = t.slice();
                    }
                    static parse(t) {
                        if (t instanceof Pi) return t;
                        if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
                            for (let r = 0; r < t.length; r += 2) {
                                const n = t[r], l = t[r + 1];
                                if (typeof n != "string" || !La.has(n) || !Array.isArray(l) || l.length !== 2 || typeof l[0] != "number" || typeof l[1] != "number") return;
                            }
                            return new Pi(t);
                        }
                    }
                    toString() {
                        return JSON.stringify(this.values);
                    }
                    static interpolate(t, r, n) {
                        const l = t.values, p = r.values;
                        if (l.length !== p.length) throw new St(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${r.toString()}`);
                        const d = [];
                        for (let m = 0; m < l.length; m += 2) {
                            if (l[m] !== p[m]) throw new St(`Cannot interpolate values containing mismatched anchors. from[${m}]: ${l[m]}, to[${m}]: ${p[m]}`);
                            d.push(l[m]);
                            const [_, v] = l[m + 1], [b, S] = p[m + 1];
                            d.push([Ti(_, b, n), Ti(v, S, n)]);
                        }
                        return new Pi(d);
                    }
                }
                class Oi {
                    constructor(t) {
                        this.name = t.name, this.available = t.available;
                    }
                    toString() {
                        return this.name;
                    }
                    static fromString(t) {
                        return t ? new Oi({ name: t, available: !1 }) : null;
                    }
                }
                class Ei {
                    constructor(t, r, n) {
                        this.from = t, this.to = r, this.transition = n;
                    }
                    static interpolate(t, r, n) {
                        return new Ei(t, r, n);
                    }
                    static parse(t) {
                        return t instanceof Ei ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new Ei(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new Ei(t.from, t.to, t.transition) : typeof t == "string" ? new Ei(t, t, 1) : void 0;
                    }
                }
                function bn(a, t, r, n) {
                    return typeof a == "number" && a >= 0 && a <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? n === void 0 || typeof n == "number" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[a, t, r, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n == "number" ? [a, t, r, n] : [a, t, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
                }
                function vt(a) {
                    if (a === null || typeof a == "string" || typeof a == "boolean" || typeof a == "number" || a instanceof Ei || a instanceof st || a instanceof vn || a instanceof zi || a instanceof ci || a instanceof Ut || a instanceof hi || a instanceof Pi || a instanceof Oi) return !0;
                    if (Array.isArray(a)) {
                        for (const t of a) if (!vt(t)) return !1;
                        return !0;
                    }
                    if (typeof a == "object") {
                        for (const t in a) if (!vt(a[t])) return !1;
                        return !0;
                    }
                    return !1;
                }
                function Ft(a) {
                    if (a === null) return We;
                    if (typeof a == "string") return qe;
                    if (typeof a == "boolean") return Je;
                    if (typeof a == "number") return Se;
                    if (a instanceof st) return Lt;
                    if (a instanceof Ei) return Bt;
                    if (a instanceof vn) return ka;
                    if (a instanceof zi) return fn;
                    if (a instanceof ci) return ra;
                    if (a instanceof Ut) return Mr;
                    if (a instanceof hi) return mn;
                    if (a instanceof Pi) return $t;
                    if (a instanceof Oi) return aa;
                    if (Array.isArray(a)) {
                        const t = a.length;
                        let r;
                        for (const n of a) {
                            const l = Ft(n);
                            if (r) {
                                if (r === l) continue;
                                r = Qe;
                                break;
                            }
                            r = l;
                        }
                        return Ni(r || Qe, t);
                    }
                    return ki;
                }
                function ot(a) {
                    const t = typeof a;
                    return a === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(a) : a instanceof st || a instanceof Ei || a instanceof zi || a instanceof ci || a instanceof Ut || a instanceof hi || a instanceof Pi || a instanceof Oi ? a.toString() : JSON.stringify(a);
                }
                class Ke {
                    constructor(t, r) {
                        this.type = t, this.value = r;
                    }
                    static parse(t, r) {
                        if (t.length !== 2) return r.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                        if (!vt(t[1])) return r.error("invalid value");
                        const n = t[1];
                        let l = Ft(n);
                        const p = r.expectedType;
                        return l.kind !== "array" || l.N !== 0 || !p || p.kind !== "array" || typeof p.N == "number" && p.N !== 0 || (l = p), new Ke(l, n);
                    }
                    evaluate() {
                        return this.value;
                    }
                    eachChild() {
                    }
                    outputDefined() {
                        return !0;
                    }
                }
                const Ba = { string: qe, number: Se, boolean: Je, object: ki };
                class et {
                    constructor(t, r) {
                        this.type = t, this.args = r;
                    }
                    static parse(t, r) {
                        if (t.length < 2) return r.error("Expected at least one argument.");
                        let n, l = 1;
                        const p = t[0];
                        if (p === "array") {
                            let m, _;
                            if (t.length > 2) {
                                const v = t[1];
                                if (typeof v != "string" || !(v in Ba) || v === "object") return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
                                m = Ba[v], l++;
                            } else m = Qe;
                            if (t.length > 3) {
                                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return r.error('The length argument to "array" must be a positive integer literal', 2);
                                _ = t[2], l++;
                            }
                            n = Ni(m, _);
                        } else {
                            if (!Ba[p]) throw new Error(`Types doesn't contain name = ${p}`);
                            n = Ba[p];
                        }
                        const d = [];
                        for (; l < t.length; l++) {
                            const m = r.parse(t[l], l, Qe);
                            if (!m) return null;
                            d.push(m);
                        }
                        return new et(n, d);
                    }
                    evaluate(t) {
                        for (let r = 0; r < this.args.length; r++) {
                            const n = this.args[r].evaluate(t);
                            if (!za(this.type, Ft(n))) return n;
                            if (r === this.args.length - 1) throw new St(`Expected value to be of type ${It(this.type)}, but found ${It(Ft(n))} instead.`);
                        }
                        throw new Error();
                    }
                    eachChild(t) {
                        this.args.forEach(t);
                    }
                    outputDefined() {
                        return this.args.every((t) => t.outputDefined());
                    }
                }
                const ps = { "to-boolean": Je, "to-color": Lt, "to-number": Se, "to-string": qe };
                class gi {
                    constructor(t, r) {
                        this.type = t, this.args = r;
                    }
                    static parse(t, r) {
                        if (t.length < 2) return r.error("Expected at least one argument.");
                        const n = t[0];
                        if (!ps[n]) throw new Error(`Can't parse ${n} as it is not part of the known types`);
                        if ((n === "to-boolean" || n === "to-string") && t.length !== 2) return r.error("Expected one argument.");
                        const l = ps[n], p = [];
                        for (let d = 1; d < t.length; d++) {
                            const m = r.parse(t[d], d, Qe);
                            if (!m) return null;
                            p.push(m);
                        }
                        return new gi(l, p);
                    }
                    evaluate(t) {
                        switch (this.type.kind) {
                            case "boolean":
                                return !!this.args[0].evaluate(t);
                            case "color": {
                                let r, n;
                                for (const l of this.args) {
                                    if (r = l.evaluate(t), n = null, r instanceof st) return r;
                                    if (typeof r == "string") {
                                        const p = t.parseColor(r);
                                        if (p) return p;
                                    } else if (Array.isArray(r) && (n = r.length < 3 || r.length > 4 ? `Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : bn(r[0], r[1], r[2], r[3]), !n)) return new st(r[0] / 255, r[1] / 255, r[2] / 255, r[3]);
                                }
                                throw new St(n || `Could not parse color from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
                            }
                            case "padding": {
                                let r;
                                for (const n of this.args) {
                                    r = n.evaluate(t);
                                    const l = ci.parse(r);
                                    if (l) return l;
                                }
                                throw new St(`Could not parse padding from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
                            }
                            case "numberArray": {
                                let r;
                                for (const n of this.args) {
                                    r = n.evaluate(t);
                                    const l = Ut.parse(r);
                                    if (l) return l;
                                }
                                throw new St(`Could not parse numberArray from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
                            }
                            case "colorArray": {
                                let r;
                                for (const n of this.args) {
                                    r = n.evaluate(t);
                                    const l = hi.parse(r);
                                    if (l) return l;
                                }
                                throw new St(`Could not parse colorArray from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
                            }
                            case "variableAnchorOffsetCollection": {
                                let r;
                                for (const n of this.args) {
                                    r = n.evaluate(t);
                                    const l = Pi.parse(r);
                                    if (l) return l;
                                }
                                throw new St(`Could not parse variableAnchorOffsetCollection from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
                            }
                            case "number": {
                                let r = null;
                                for (const n of this.args) {
                                    if (r = n.evaluate(t), r === null) return 0;
                                    const l = Number(r);
                                    if (!isNaN(l)) return l;
                                }
                                throw new St(`Could not convert ${JSON.stringify(r)} to number.`);
                            }
                            case "formatted":
                                return zi.fromString(ot(this.args[0].evaluate(t)));
                            case "resolvedImage":
                                return Oi.fromString(ot(this.args[0].evaluate(t)));
                            case "projectionDefinition":
                                return this.args[0].evaluate(t);
                            default:
                                return ot(this.args[0].evaluate(t));
                        }
                    }
                    eachChild(t) {
                        this.args.forEach(t);
                    }
                    outputDefined() {
                        return this.args.every((t) => t.outputDefined());
                    }
                }
                const bo = ["Unknown", "Point", "LineString", "Polygon"];
                class wo {
                    constructor() {
                        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
                    }
                    id() {
                        return this.feature && "id" in this.feature ? this.feature.id : null;
                    }
                    geometryType() {
                        return this.feature ? typeof this.feature.type == "number" ? bo[this.feature.type] : this.feature.type : null;
                    }
                    geometry() {
                        return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
                    }
                    canonicalID() {
                        return this.canonical;
                    }
                    properties() {
                        return this.feature && this.feature.properties || {};
                    }
                    parseColor(t) {
                        let r = this._parseColorCache.get(t);
                        return r || (r = st.parse(t), this._parseColorCache.set(t, r)), r;
                    }
                }
                class wn {
                    constructor(t, r, n = [], l, p = new dt(), d = []) {
                        this.registry = t, this.path = n, this.key = n.map((m) => `[${m}]`).join(""), this.scope = p, this.errors = d, this.expectedType = l, this._isConstant = r;
                    }
                    parse(t, r, n, l, p = {}) {
                        return r ? this.concat(r, n, l)._parse(t, p) : this._parse(t, p);
                    }
                    _parse(t, r) {
                        function n(l, p, d) {
                            return d === "assert" ? new et(p, [l]) : d === "coerce" ? new gi(p, [l]) : l;
                        }
                        if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
                            if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                            const l = t[0];
                            if (typeof l != "string") return this.error(`Expression name must be a string, but found ${typeof l} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                            const p = this.registry[l];
                            if (p) {
                                let d = p.parse(t, this);
                                if (!d) return null;
                                if (this.expectedType) {
                                    const m = this.expectedType, _ = d.type;
                                    if (m.kind !== "string" && m.kind !== "number" && m.kind !== "boolean" && m.kind !== "object" && m.kind !== "array" || _.kind !== "value") {
                                        if (m.kind === "projectionDefinition" && ["string", "array"].includes(_.kind) || ["color", "formatted", "resolvedImage"].includes(m.kind) && ["value", "string"].includes(_.kind) || ["padding", "numberArray"].includes(m.kind) && ["value", "number", "array"].includes(_.kind) || m.kind === "colorArray" && ["value", "string", "array"].includes(_.kind) || m.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(_.kind)) d = n(d, m, r.typeAnnotation || "coerce");
                                        else if (this.checkSubtype(m, _)) return null;
                                    } else d = n(d, m, r.typeAnnotation || "assert");
                                }
                                if (!(d instanceof Ke) && d.type.kind !== "resolvedImage" && this._isConstant(d)) {
                                    const m = new wo();
                                    try {
                                        d = new Ke(d.type, d.evaluate(m));
                                    } catch (_) {
                                        return this.error(_.message), null;
                                    }
                                }
                                return d;
                            }
                            return this.error(`Unknown expression "${l}". If you wanted a literal array, use ["literal", [...]].`, 0);
                        }
                        return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
                    }
                    concat(t, r, n) {
                        const l = typeof t == "number" ? this.path.concat(t) : this.path, p = n ? this.scope.concat(n) : this.scope;
                        return new wn(this.registry, this._isConstant, l, r || null, p, this.errors);
                    }
                    error(t, ...r) {
                        const n = `${this.key}${r.map((l) => `[${l}]`).join("")}`;
                        this.errors.push(new nt(n, t));
                    }
                    checkSubtype(t, r) {
                        const n = za(t, r);
                        return n && this.error(n), n;
                    }
                }
                class Fa {
                    constructor(t, r) {
                        this.type = r.type, this.bindings = [].concat(t), this.result = r;
                    }
                    evaluate(t) {
                        return this.result.evaluate(t);
                    }
                    eachChild(t) {
                        for (const r of this.bindings) t(r[1]);
                        t(this.result);
                    }
                    static parse(t, r) {
                        if (t.length < 4) return r.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
                        const n = [];
                        for (let p = 1; p < t.length - 1; p += 2) {
                            const d = t[p];
                            if (typeof d != "string") return r.error(`Expected string, but found ${typeof d} instead.`, p);
                            if (/[^a-zA-Z0-9_]/.test(d)) return r.error("Variable names must contain only alphanumeric characters or '_'.", p);
                            const m = r.parse(t[p + 1], p + 1);
                            if (!m) return null;
                            n.push([d, m]);
                        }
                        const l = r.parse(t[t.length - 1], t.length - 1, r.expectedType, n);
                        return l ? new Fa(n, l) : null;
                    }
                    outputDefined() {
                        return this.result.outputDefined();
                    }
                }
                class Sn {
                    constructor(t, r) {
                        this.type = r.type, this.name = t, this.boundExpression = r;
                    }
                    static parse(t, r) {
                        if (t.length !== 2 || typeof t[1] != "string") return r.error("'var' expression requires exactly one string literal argument.");
                        const n = t[1];
                        return r.scope.has(n) ? new Sn(n, r.scope.get(n)) : r.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1);
                    }
                    evaluate(t) {
                        return this.boundExpression.evaluate(t);
                    }
                    eachChild() {
                    }
                    outputDefined() {
                        return !1;
                    }
                }
                class So {
                    constructor(t, r, n) {
                        this.type = t, this.index = r, this.input = n;
                    }
                    static parse(t, r) {
                        if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                        const n = r.parse(t[1], 1, Se), l = r.parse(t[2], 2, Ni(r.expectedType || Qe));
                        return n && l ? new So(l.type.itemType, n, l) : null;
                    }
                    evaluate(t) {
                        const r = this.index.evaluate(t), n = this.input.evaluate(t);
                        if (r < 0) throw new St(`Array index out of bounds: ${r} < 0.`);
                        if (r >= n.length) throw new St(`Array index out of bounds: ${r} > ${n.length - 1}.`);
                        if (r !== Math.floor(r)) throw new St(`Array index must be an integer, but found ${r} instead.`);
                        return n[r];
                    }
                    eachChild(t) {
                        t(this.index), t(this.input);
                    }
                    outputDefined() {
                        return !1;
                    }
                }
                class ds {
                    constructor(t, r) {
                        this.type = Je, this.needle = t, this.haystack = r;
                    }
                    static parse(t, r) {
                        if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                        const n = r.parse(t[1], 1, Qe), l = r.parse(t[2], 2, Qe);
                        return n && l ? mo(n.type, [Je, qe, Se, We, Qe]) ? new ds(n, l) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${It(n.type)} instead`) : null;
                    }
                    evaluate(t) {
                        const r = this.needle.evaluate(t), n = this.haystack.evaluate(t);
                        if (!n) return !1;
                        if (!na(r, ["boolean", "string", "number", "null"])) throw new St(`Expected first argument to be of type boolean, string, number or null, but found ${It(Ft(r))} instead.`);
                        if (!na(n, ["string", "array"])) throw new St(`Expected second argument to be of type array or string, but found ${It(Ft(n))} instead.`);
                        return n.indexOf(r) >= 0;
                    }
                    eachChild(t) {
                        t(this.needle), t(this.haystack);
                    }
                    outputDefined() {
                        return !0;
                    }
                }
                class Tn {
                    constructor(t, r, n) {
                        this.type = Se, this.needle = t, this.haystack = r, this.fromIndex = n;
                    }
                    static parse(t, r) {
                        if (t.length <= 2 || t.length >= 5) return r.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                        const n = r.parse(t[1], 1, Qe), l = r.parse(t[2], 2, Qe);
                        if (!n || !l) return null;
                        if (!mo(n.type, [Je, qe, Se, We, Qe])) return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${It(n.type)} instead`);
                        if (t.length === 4) {
                            const p = r.parse(t[3], 3, Se);
                            return p ? new Tn(n, l, p) : null;
                        }
                        return new Tn(n, l);
                    }
                    evaluate(t) {
                        const r = this.needle.evaluate(t), n = this.haystack.evaluate(t);
                        if (!na(r, ["boolean", "string", "number", "null"])) throw new St(`Expected first argument to be of type boolean, string, number or null, but found ${It(Ft(r))} instead.`);
                        let l;
                        if (this.fromIndex && (l = this.fromIndex.evaluate(t)), na(n, ["string"])) {
                            const p = n.indexOf(r, l);
                            return p === -1 ? -1 : [...n.slice(0, p)].length;
                        }
                        if (na(n, ["array"])) return n.indexOf(r, l);
                        throw new St(`Expected second argument to be of type array or string, but found ${It(Ft(n))} instead.`);
                    }
                    eachChild(t) {
                        t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
                    }
                    outputDefined() {
                        return !1;
                    }
                }
                class ca {
                    constructor(t, r, n, l, p, d) {
                        this.inputType = t, this.type = r, this.input = n, this.cases = l, this.outputs = p, this.otherwise = d;
                    }
                    static parse(t, r) {
                        if (t.length < 5) return r.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if (t.length % 2 != 1) return r.error("Expected an even number of arguments.");
                        let n, l;
                        r.expectedType && r.expectedType.kind !== "value" && (l = r.expectedType);
                        const p = {}, d = [];
                        for (let v = 2; v < t.length - 1; v += 2) {
                            let b = t[v];
                            const S = t[v + 1];
                            Array.isArray(b) || (b = [b]);
                            const I = r.concat(v);
                            if (b.length === 0) return I.error("Expected at least one branch label.");
                            for (const k of b) {
                                if (typeof k != "number" && typeof k != "string") return I.error("Branch labels must be numbers or strings.");
                                if (typeof k == "number" && Math.abs(k) > Number.MAX_SAFE_INTEGER) return I.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                                if (typeof k == "number" && Math.floor(k) !== k) return I.error("Numeric branch labels must be integer values.");
                                if (n) {
                                    if (I.checkSubtype(n, Ft(k))) return null;
                                } else n = Ft(k);
                                if (p[String(k)] !== void 0) return I.error("Branch labels must be unique.");
                                p[String(k)] = d.length;
                            }
                            const A = r.parse(S, v, l);
                            if (!A) return null;
                            l = l || A.type, d.push(A);
                        }
                        const m = r.parse(t[1], 1, Qe);
                        if (!m) return null;
                        const _ = r.parse(t[t.length - 1], t.length - 1, l);
                        return _ ? m.type.kind !== "value" && r.concat(1).checkSubtype(n, m.type) ? null : new ca(n, l, m, p, d, _) : null;
                    }
                    evaluate(t) {
                        const r = this.input.evaluate(t);
                        return (Ft(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(t);
                    }
                    eachChild(t) {
                        t(this.input), this.outputs.forEach(t), t(this.otherwise);
                    }
                    outputDefined() {
                        return this.outputs.every((t) => t.outputDefined()) && this.otherwise.outputDefined();
                    }
                }
                class ei {
                    constructor(t, r, n) {
                        this.type = t, this.branches = r, this.otherwise = n;
                    }
                    static parse(t, r) {
                        if (t.length < 4) return r.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
                        if (t.length % 2 != 0) return r.error("Expected an odd number of arguments.");
                        let n;
                        r.expectedType && r.expectedType.kind !== "value" && (n = r.expectedType);
                        const l = [];
                        for (let d = 1; d < t.length - 1; d += 2) {
                            const m = r.parse(t[d], d, Je);
                            if (!m) return null;
                            const _ = r.parse(t[d + 1], d + 1, n);
                            if (!_) return null;
                            l.push([m, _]), n = n || _.type;
                        }
                        const p = r.parse(t[t.length - 1], t.length - 1, n);
                        if (!p) return null;
                        if (!n) throw new Error("Can't infer output type");
                        return new ei(n, l, p);
                    }
                    evaluate(t) {
                        for (const [r, n] of this.branches) if (r.evaluate(t)) return n.evaluate(t);
                        return this.otherwise.evaluate(t);
                    }
                    eachChild(t) {
                        for (const [r, n] of this.branches) t(r), t(n);
                        t(this.otherwise);
                    }
                    outputDefined() {
                        return this.branches.every(([t, r]) => r.outputDefined()) && this.otherwise.outputDefined();
                    }
                }
                class ha {
                    constructor(t, r, n, l) {
                        this.type = t, this.input = r, this.beginIndex = n, this.endIndex = l;
                    }
                    static parse(t, r) {
                        if (t.length <= 2 || t.length >= 5) return r.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                        const n = r.parse(t[1], 1, Qe), l = r.parse(t[2], 2, Se);
                        if (!n || !l) return null;
                        if (!mo(n.type, [Ni(Qe), qe, Qe])) return r.error(`Expected first argument to be of type array or string, but found ${It(n.type)} instead`);
                        if (t.length === 4) {
                            const p = r.parse(t[3], 3, Se);
                            return p ? new ha(n.type, n, l, p) : null;
                        }
                        return new ha(n.type, n, l);
                    }
                    evaluate(t) {
                        const r = this.input.evaluate(t), n = this.beginIndex.evaluate(t);
                        let l;
                        if (this.endIndex && (l = this.endIndex.evaluate(t)), na(r, ["string"])) return [...r].slice(n, l).join("");
                        if (na(r, ["array"])) return r.slice(n, l);
                        throw new St(`Expected first argument to be of type array or string, but found ${It(Ft(r))} instead.`);
                    }
                    eachChild(t) {
                        t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
                    }
                    outputDefined() {
                        return !1;
                    }
                }
                function Pn(a, t) {
                    const r = a.length - 1;
                    let n, l, p = 0, d = r, m = 0;
                    for (; p <= d;) if (m = Math.floor((p + d) / 2), n = a[m], l = a[m + 1], n <= t) {
                        if (m === r || t < l) return m;
                        p = m + 1;
                    } else {
                        if (!(n > t)) throw new St("Input is not a number.");
                        d = m - 1;
                    }
                    return 0;
                }
                class $r {
                    constructor(t, r, n) {
                        this.type = t, this.input = r, this.labels = [], this.outputs = [];
                        for (const [l, p] of n) this.labels.push(l), this.outputs.push(p);
                    }
                    static parse(t, r) {
                        if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
                        const n = r.parse(t[1], 1, Se);
                        if (!n) return null;
                        const l = [];
                        let p = null;
                        r.expectedType && r.expectedType.kind !== "value" && (p = r.expectedType);
                        for (let d = 1; d < t.length; d += 2) {
                            const m = d === 1 ? -1 / 0 : t[d], _ = t[d + 1], v = d, b = d + 1;
                            if (typeof m != "number") return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', v);
                            if (l.length && l[l.length - 1][0] >= m) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', v);
                            const S = r.parse(_, b, p);
                            if (!S) return null;
                            p = p || S.type, l.push([m, S]);
                        }
                        return new $r(p, n, l);
                    }
                    evaluate(t) {
                        const r = this.labels, n = this.outputs;
                        if (r.length === 1) return n[0].evaluate(t);
                        const l = this.input.evaluate(t);
                        if (l <= r[0]) return n[0].evaluate(t);
                        const p = r.length;
                        return l >= r[p - 1] ? n[p - 1].evaluate(t) : n[Pn(r, l)].evaluate(t);
                    }
                    eachChild(t) {
                        t(this.input);
                        for (const r of this.outputs) t(r);
                    }
                    outputDefined() {
                        return this.outputs.every((t) => t.outputDefined());
                    }
                }
                function ti(a) {
                    return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
                }
                var fs, ms, jl = function () {
                    if (ms) return fs;
                    function a(t, r, n, l) {
                        this.cx = 3 * t, this.bx = 3 * (n - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (l - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = n, this.p2y = l;
                    }
                    return ms = 1, fs = a, a.prototype = {
                        sampleCurveX: function (t) {
                            return ((this.ax * t + this.bx) * t + this.cx) * t;
                        }, sampleCurveY: function (t) {
                            return ((this.ay * t + this.by) * t + this.cy) * t;
                        }, sampleCurveDerivativeX: function (t) {
                            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
                        }, solveCurveX: function (t, r) {
                            if (r === void 0 && (r = 1e-6), t < 0) return 0;
                            if (t > 1) return 1;
                            for (var n = t, l = 0; l < 8; l++) {
                                var p = this.sampleCurveX(n) - t;
                                if (Math.abs(p) < r) return n;
                                var d = this.sampleCurveDerivativeX(n);
                                if (Math.abs(d) < 1e-6) break;
                                n -= p / d;
                            }
                            var m = 0, _ = 1;
                            for (n = t, l = 0; l < 20 && (p = this.sampleCurveX(n), !(Math.abs(p - t) < r)); l++) t > p ? m = n : _ = n, n = 0.5 * (_ - m) + m;
                            return n;
                        }, solve: function (t, r) {
                            return this.sampleCurveY(this.solveCurveX(t, r));
                        }
                    }, fs;
                }(), rh = ti(jl);
                class _i {
                    constructor(t, r, n, l, p) {
                        this.type = t, this.operator = r, this.interpolation = n, this.input = l, this.labels = [], this.outputs = [];
                        for (const [d, m] of p) this.labels.push(d), this.outputs.push(m);
                    }
                    static interpolationFactor(t, r, n, l) {
                        let p = 0;
                        if (t.name === "exponential") p = Mn(r, t.base, n, l);
                        else if (t.name === "linear") p = Mn(r, 1, n, l);
                        else if (t.name === "cubic-bezier") {
                            const d = t.controlPoints;
                            p = new rh(d[0], d[1], d[2], d[3]).solve(Mn(r, 1, n, l));
                        }
                        return p;
                    }
                    static parse(t, r) {
                        let [n, l, p, ...d] = t;
                        if (!Array.isArray(l) || l.length === 0) return r.error("Expected an interpolation type expression.", 1);
                        if (l[0] === "linear") l = { name: "linear" };
                        else if (l[0] === "exponential") {
                            const v = l[1];
                            if (typeof v != "number") return r.error("Exponential interpolation requires a numeric base.", 1, 1);
                            l = { name: "exponential", base: v };
                        } else {
                            if (l[0] !== "cubic-bezier") return r.error(`Unknown interpolation type ${String(l[0])}`, 1, 0);
                            {
                                const v = l.slice(1);
                                if (v.length !== 4 || v.some((b) => typeof b != "number" || b < 0 || b > 1)) return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                                l = { name: "cubic-bezier", controlPoints: v };
                            }
                        }
                        if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
                        if (p = r.parse(p, 2, Se), !p) return null;
                        const m = [];
                        let _ = null;
                        n !== "interpolate-hcl" && n !== "interpolate-lab" || r.expectedType == mn ? r.expectedType && r.expectedType.kind !== "value" && (_ = r.expectedType) : _ = Lt;
                        for (let v = 0; v < d.length; v += 2) {
                            const b = d[v], S = d[v + 1], I = v + 3, A = v + 4;
                            if (typeof b != "number") return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', I);
                            if (m.length && m[m.length - 1][0] >= b) return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', I);
                            const k = r.parse(S, A, _);
                            if (!k) return null;
                            _ = _ || k.type, m.push([b, k]);
                        }
                        return Ir(_, Se) || Ir(_, Bt) || Ir(_, Lt) || Ir(_, ra) || Ir(_, Mr) || Ir(_, mn) || Ir(_, $t) || Ir(_, Ni(Se)) ? new _i(_, n, l, p, m) : r.error(`Type ${It(_)} is not interpolatable.`);
                    }
                    evaluate(t) {
                        const r = this.labels, n = this.outputs;
                        if (r.length === 1) return n[0].evaluate(t);
                        const l = this.input.evaluate(t);
                        if (l <= r[0]) return n[0].evaluate(t);
                        const p = r.length;
                        if (l >= r[p - 1]) return n[p - 1].evaluate(t);
                        const d = Pn(r, l), m = _i.interpolationFactor(this.interpolation, l, r[d], r[d + 1]), _ = n[d].evaluate(t), v = n[d + 1].evaluate(t);
                        switch (this.operator) {
                            case "interpolate":
                                switch (this.type.kind) {
                                    case "number":
                                        return Ti(_, v, m);
                                    case "color":
                                        return st.interpolate(_, v, m);
                                    case "padding":
                                        return ci.interpolate(_, v, m);
                                    case "colorArray":
                                        return hi.interpolate(_, v, m);
                                    case "numberArray":
                                        return Ut.interpolate(_, v, m);
                                    case "variableAnchorOffsetCollection":
                                        return Pi.interpolate(_, v, m);
                                    case "array":
                                        return la(_, v, m);
                                    case "projectionDefinition":
                                        return Ei.interpolate(_, v, m);
                                }
                            case "interpolate-hcl":
                                switch (this.type.kind) {
                                    case "color":
                                        return st.interpolate(_, v, m, "hcl");
                                    case "colorArray":
                                        return hi.interpolate(_, v, m, "hcl");
                                }
                            case "interpolate-lab":
                                switch (this.type.kind) {
                                    case "color":
                                        return st.interpolate(_, v, m, "lab");
                                    case "colorArray":
                                        return hi.interpolate(_, v, m, "lab");
                                }
                        }
                    }
                    eachChild(t) {
                        t(this.input);
                        for (const r of this.outputs) t(r);
                    }
                    outputDefined() {
                        return this.outputs.every((t) => t.outputDefined());
                    }
                }
                function Mn(a, t, r, n) {
                    const l = n - r, p = a - r;
                    return l === 0 ? 0 : t === 1 ? p / l : (Math.pow(t, p) - 1) / (Math.pow(t, l) - 1);
                }
                const gr = { color: st.interpolate, number: Ti, padding: ci.interpolate, numberArray: Ut.interpolate, colorArray: hi.interpolate, variableAnchorOffsetCollection: Pi.interpolate, array: la };
                class ua {
                    constructor(t, r) {
                        this.type = t, this.args = r;
                    }
                    static parse(t, r) {
                        if (t.length < 2) return r.error("Expected at least one argument.");
                        let n = null;
                        const l = r.expectedType;
                        l && l.kind !== "value" && (n = l);
                        const p = [];
                        for (const m of t.slice(1)) {
                            const _ = r.parse(m, 1 + p.length, n, void 0, { typeAnnotation: "omit" });
                            if (!_) return null;
                            n = n || _.type, p.push(_);
                        }
                        if (!n) throw new Error("No output type");
                        const d = l && p.some((m) => za(l, m.type));
                        return new ua(d ? Qe : n, p);
                    }
                    evaluate(t) {
                        let r, n = null, l = 0;
                        for (const p of this.args) if (l++, n = p.evaluate(t), n && n instanceof Oi && !n.available && (r || (r = n.name), n = null, l === this.args.length && (n = r)), n !== null) break;
                        return n;
                    }
                    eachChild(t) {
                        this.args.forEach(t);
                    }
                    outputDefined() {
                        return this.args.every((t) => t.outputDefined());
                    }
                }
                function In(a, t) {
                    return a === "==" || a === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
                }
                function Hi(a, t, r, n) {
                    return n.compare(t, r) === 0;
                }
                function pa(a, t, r) {
                    const n = a !== "==" && a !== "!=";
                    return class Ed {
                        constructor(p, d, m) {
                            this.type = Je, this.lhs = p, this.rhs = d, this.collator = m, this.hasUntypedArgument = p.type.kind === "value" || d.type.kind === "value";
                        }
                        static parse(p, d) {
                            if (p.length !== 3 && p.length !== 4) return d.error("Expected two or three arguments.");
                            const m = p[0];
                            let _ = d.parse(p[1], 1, Qe);
                            if (!_) return null;
                            if (!In(m, _.type)) return d.concat(1).error(`"${m}" comparisons are not supported for type '${It(_.type)}'.`);
                            let v = d.parse(p[2], 2, Qe);
                            if (!v) return null;
                            if (!In(m, v.type)) return d.concat(2).error(`"${m}" comparisons are not supported for type '${It(v.type)}'.`);
                            if (_.type.kind !== v.type.kind && _.type.kind !== "value" && v.type.kind !== "value") return d.error(`Cannot compare types '${It(_.type)}' and '${It(v.type)}'.`);
                            n && (_.type.kind === "value" && v.type.kind !== "value" ? _ = new et(v.type, [_]) : _.type.kind !== "value" && v.type.kind === "value" && (v = new et(_.type, [v])));
                            let b = null;
                            if (p.length === 4) {
                                if (_.type.kind !== "string" && v.type.kind !== "string" && _.type.kind !== "value" && v.type.kind !== "value") return d.error("Cannot use collator to compare non-string types.");
                                if (b = d.parse(p[3], 3, ka), !b) return null;
                            }
                            return new Ed(_, v, b);
                        }
                        evaluate(p) {
                            const d = this.lhs.evaluate(p), m = this.rhs.evaluate(p);
                            if (n && this.hasUntypedArgument) {
                                const _ = Ft(d), v = Ft(m);
                                if (_.kind !== v.kind || _.kind !== "string" && _.kind !== "number") throw new St(`Expected arguments for "${a}" to be (string, string) or (number, number), but found (${_.kind}, ${v.kind}) instead.`);
                            }
                            if (this.collator && !n && this.hasUntypedArgument) {
                                const _ = Ft(d), v = Ft(m);
                                if (_.kind !== "string" || v.kind !== "string") return t(p, d, m);
                            }
                            return this.collator ? r(p, d, m, this.collator.evaluate(p)) : t(p, d, m);
                        }
                        eachChild(p) {
                            p(this.lhs), p(this.rhs), this.collator && p(this.collator);
                        }
                        outputDefined() {
                            return !0;
                        }
                    };
                }
                const gs = pa("==", function (a, t, r) {
                    return t === r;
                }, Hi), ah = pa("!=", function (a, t, r) {
                    return t !== r;
                }, function (a, t, r, n) {
                    return !Hi(0, t, r, n);
                }), To = pa("<", function (a, t, r) {
                    return t < r;
                }, function (a, t, r, n) {
                    return n.compare(t, r) < 0;
                }), nh = pa(">", function (a, t, r) {
                    return t > r;
                }, function (a, t, r, n) {
                    return n.compare(t, r) > 0;
                }), sh = pa("<=", function (a, t, r) {
                    return t <= r;
                }, function (a, t, r, n) {
                    return n.compare(t, r) <= 0;
                }), oh = pa(">=", function (a, t, r) {
                    return t >= r;
                }, function (a, t, r, n) {
                    return n.compare(t, r) >= 0;
                });
                class _s {
                    constructor(t, r, n) {
                        this.type = ka, this.locale = n, this.caseSensitive = t, this.diacriticSensitive = r;
                    }
                    static parse(t, r) {
                        if (t.length !== 2) return r.error("Expected one argument.");
                        const n = t[1];
                        if (typeof n != "object" || Array.isArray(n)) return r.error("Collator options argument must be an object.");
                        const l = r.parse(n["case-sensitive"] !== void 0 && n["case-sensitive"], 1, Je);
                        if (!l) return null;
                        const p = r.parse(n["diacritic-sensitive"] !== void 0 && n["diacritic-sensitive"], 1, Je);
                        if (!p) return null;
                        let d = null;
                        return n.locale && (d = r.parse(n.locale, 1, qe), !d) ? null : new _s(l, p, d);
                    }
                    evaluate(t) {
                        return new vn(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
                    }
                    eachChild(t) {
                        t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
                    }
                    outputDefined() {
                        return !1;
                    }
                }
                class Na {
                    constructor(t, r, n, l, p) {
                        this.type = qe, this.number = t, this.locale = r, this.currency = n, this.minFractionDigits = l, this.maxFractionDigits = p;
                    }
                    static parse(t, r) {
                        if (t.length !== 3) return r.error("Expected two arguments.");
                        const n = r.parse(t[1], 1, Se);
                        if (!n) return null;
                        const l = t[2];
                        if (typeof l != "object" || Array.isArray(l)) return r.error("NumberFormat options argument must be an object.");
                        let p = null;
                        if (l.locale && (p = r.parse(l.locale, 1, qe), !p)) return null;
                        let d = null;
                        if (l.currency && (d = r.parse(l.currency, 1, qe), !d)) return null;
                        let m = null;
                        if (l["min-fraction-digits"] && (m = r.parse(l["min-fraction-digits"], 1, Se), !m)) return null;
                        let _ = null;
                        return l["max-fraction-digits"] && (_ = r.parse(l["max-fraction-digits"], 1, Se), !_) ? null : new Na(n, p, d, m, _);
                    }
                    evaluate(t) {
                        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
                    }
                    eachChild(t) {
                        t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
                    }
                    outputDefined() {
                        return !1;
                    }
                }
                class ys {
                    constructor(t) {
                        this.type = fn, this.sections = t;
                    }
                    static parse(t, r) {
                        if (t.length < 2) return r.error("Expected at least one argument.");
                        const n = t[1];
                        if (!Array.isArray(n) && typeof n == "object") return r.error("First argument must be an image or text section.");
                        const l = [];
                        let p = !1;
                        for (let d = 1; d <= t.length - 1; ++d) {
                            const m = t[d];
                            if (p && typeof m == "object" && !Array.isArray(m)) {
                                p = !1;
                                let _ = null;
                                if (m["font-scale"] && (_ = r.parse(m["font-scale"], 1, Se), !_)) return null;
                                let v = null;
                                if (m["text-font"] && (v = r.parse(m["text-font"], 1, Ni(qe)), !v)) return null;
                                let b = null;
                                if (m["text-color"] && (b = r.parse(m["text-color"], 1, Lt), !b)) return null;
                                let S = null;
                                if (m["vertical-align"]) {
                                    if (typeof m["vertical-align"] == "string" && !xn.includes(m["vertical-align"])) return r.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${m["vertical-align"]}' instead.`);
                                    if (S = r.parse(m["vertical-align"], 1, qe), !S) return null;
                                }
                                const I = l[l.length - 1];
                                I.scale = _, I.font = v, I.textColor = b, I.verticalAlign = S;
                            } else {
                                const _ = r.parse(t[d], 1, Qe);
                                if (!_) return null;
                                const v = _.type.kind;
                                if (v !== "string" && v !== "value" && v !== "null" && v !== "resolvedImage") return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                                p = !0, l.push({ content: _, scale: null, font: null, textColor: null, verticalAlign: null });
                            }
                        }
                        return new ys(l);
                    }
                    evaluate(t) {
                        return new zi(this.sections.map((r) => {
                            const n = r.content.evaluate(t);
                            return Ft(n) === aa ? new Da("", n, null, null, null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null) : new Da(ot(n), null, r.scale ? r.scale.evaluate(t) : null, r.font ? r.font.evaluate(t).join(",") : null, r.textColor ? r.textColor.evaluate(t) : null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null);
                        }));
                    }
                    eachChild(t) {
                        for (const r of this.sections) t(r.content), r.scale && t(r.scale), r.font && t(r.font), r.textColor && t(r.textColor), r.verticalAlign && t(r.verticalAlign);
                    }
                    outputDefined() {
                        return !1;
                    }
                }
                class vs {
                    constructor(t) {
                        this.type = aa, this.input = t;
                    }
                    static parse(t, r) {
                        if (t.length !== 2) return r.error("Expected two arguments.");
                        const n = r.parse(t[1], 1, qe);
                        return n ? new vs(n) : r.error("No image name provided.");
                    }
                    evaluate(t) {
                        const r = this.input.evaluate(t), n = Oi.fromString(r);
                        return n && t.availableImages && (n.available = t.availableImages.indexOf(r) > -1), n;
                    }
                    eachChild(t) {
                        t(this.input);
                    }
                    outputDefined() {
                        return !1;
                    }
                }
                class xs {
                    constructor(t) {
                        this.type = Se, this.input = t;
                    }
                    static parse(t, r) {
                        if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
                        const n = r.parse(t[1], 1);
                        return n ? n.type.kind !== "array" && n.type.kind !== "string" && n.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${It(n.type)} instead.`) : new xs(n) : null;
                    }
                    evaluate(t) {
                        const r = this.input.evaluate(t);
                        if (typeof r == "string") return [...r].length;
                        if (Array.isArray(r)) return r.length;
                        throw new St(`Expected value to be of type string or array, but found ${It(Ft(r))} instead.`);
                    }
                    eachChild(t) {
                        t(this.input);
                    }
                    outputDefined() {
                        return !1;
                    }
                }
                const _r = 8192;
                function $l(a, t) {
                    const r = (180 + a[0]) / 360, n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a[1] * Math.PI / 360))) / 360, l = Math.pow(2, t.z);
                    return [Math.round(r * l * _r), Math.round(n * l * _r)];
                }
                function Po(a, t) {
                    const r = Math.pow(2, t.z);
                    return [(l = (a[0] / _r + t.x) / r, 360 * l - 180), (n = (a[1] / _r + t.y) / r, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90)];
                    var n, l;
                }
                function Cn(a, t) {
                    a[0] = Math.min(a[0], t[0]), a[1] = Math.min(a[1], t[1]), a[2] = Math.max(a[2], t[0]), a[3] = Math.max(a[3], t[1]);
                }
                function An(a, t) {
                    return !(a[0] <= t[0] || a[2] >= t[2] || a[1] <= t[1] || a[3] >= t[3]);
                }
                function lh(a, t, r) {
                    const n = a[0] - t[0], l = a[1] - t[1], p = a[0] - r[0], d = a[1] - r[1];
                    return n * d - p * l == 0 && n * p <= 0 && l * d <= 0;
                }
                function bs(a, t, r, n) {
                    return (l = [n[0] - r[0], n[1] - r[1]])[0] * (p = [t[0] - a[0], t[1] - a[1]])[1] - l[1] * p[0] != 0 && !(!Gl(a, t, r, n) || !Gl(r, n, a, t));
                    var l, p;
                }
                function Ul(a, t, r) {
                    for (const n of r) for (let l = 0; l < n.length - 1; ++l) if (bs(a, t, n[l], n[l + 1])) return !0;
                    return !1;
                }
                function da(a, t, r = !1) {
                    let n = !1;
                    for (const m of t) for (let _ = 0; _ < m.length - 1; _++) {
                        if (lh(a, m[_], m[_ + 1])) return r;
                        (p = m[_])[1] > (l = a)[1] != (d = m[_ + 1])[1] > l[1] && l[0] < (d[0] - p[0]) * (l[1] - p[1]) / (d[1] - p[1]) + p[0] && (n = !n);
                    }
                    var l, p, d;
                    return n;
                }
                function Vl(a, t) {
                    for (const r of t) if (da(a, r)) return !0;
                    return !1;
                }
                function Zl(a, t) {
                    for (const r of a) if (!da(r, t)) return !1;
                    for (let r = 0; r < a.length - 1; ++r) if (Ul(a[r], a[r + 1], t)) return !1;
                    return !0;
                }
                function ch(a, t) {
                    for (const r of t) if (Zl(a, r)) return !0;
                    return !1;
                }
                function Gl(a, t, r, n) {
                    const l = n[0] - r[0], p = n[1] - r[1], d = (a[0] - r[0]) * p - l * (a[1] - r[1]), m = (t[0] - r[0]) * p - l * (t[1] - r[1]);
                    return d > 0 && m < 0 || d < 0 && m > 0;
                }
                function kn(a, t, r) {
                    const n = [];
                    for (let l = 0; l < a.length; l++) {
                        const p = [];
                        for (let d = 0; d < a[l].length; d++) {
                            const m = $l(a[l][d], r);
                            Cn(t, m), p.push(m);
                        }
                        n.push(p);
                    }
                    return n;
                }
                function ql(a, t, r) {
                    const n = [];
                    for (let l = 0; l < a.length; l++) {
                        const p = kn(a[l], t, r);
                        n.push(p);
                    }
                    return n;
                }
                function Hl(a, t, r, n) {
                    if (a[0] < r[0] || a[0] > r[2]) {
                        const l = 0.5 * n;
                        let p = a[0] - r[0] > l ? -n : r[0] - a[0] > l ? n : 0;
                        p === 0 && (p = a[0] - r[2] > l ? -n : r[2] - a[0] > l ? n : 0), a[0] += p;
                    }
                    Cn(t, a);
                }
                function Wl(a, t, r, n) {
                    const l = Math.pow(2, n.z) * _r, p = [n.x * _r, n.y * _r], d = [];
                    for (const m of a) for (const _ of m) {
                        const v = [_.x + p[0], _.y + p[1]];
                        Hl(v, t, r, l), d.push(v);
                    }
                    return d;
                }
                function Mo(a, t, r, n) {
                    const l = Math.pow(2, n.z) * _r, p = [n.x * _r, n.y * _r], d = [];
                    for (const _ of a) {
                        const v = [];
                        for (const b of _) {
                            const S = [b.x + p[0], b.y + p[1]];
                            Cn(t, S), v.push(S);
                        }
                        d.push(v);
                    }
                    if (t[2] - t[0] <= l / 2) {
                        (m = t)[0] = m[1] = 1 / 0, m[2] = m[3] = -1 / 0;
                        for (const _ of d) for (const v of _) Hl(v, t, r, l);
                    }
                    var m;
                    return d;
                }
                class Ur {
                    constructor(t, r) {
                        this.type = Je, this.geojson = t, this.geometries = r;
                    }
                    static parse(t, r) {
                        if (t.length !== 2) return r.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                        if (vt(t[1])) {
                            const n = t[1];
                            if (n.type === "FeatureCollection") {
                                const l = [];
                                for (const p of n.features) {
                                    const { type: d, coordinates: m } = p.geometry;
                                    d === "Polygon" && l.push(m), d === "MultiPolygon" && l.push(...m);
                                }
                                if (l.length) return new Ur(n, { type: "MultiPolygon", coordinates: l });
                            } else if (n.type === "Feature") {
                                const l = n.geometry.type;
                                if (l === "Polygon" || l === "MultiPolygon") return new Ur(n, n.geometry);
                            } else if (n.type === "Polygon" || n.type === "MultiPolygon") return new Ur(n, n);
                        }
                        return r.error("'within' expression requires valid geojson object that contains polygon geometry type.");
                    }
                    evaluate(t) {
                        if (t.geometry() != null && t.canonicalID() != null) {
                            if (t.geometryType() === "Point") return function (r, n) {
                                const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], d = r.canonicalID();
                                if (n.type === "Polygon") {
                                    const m = kn(n.coordinates, p, d), _ = Wl(r.geometry(), l, p, d);
                                    if (!An(l, p)) return !1;
                                    for (const v of _) if (!da(v, m)) return !1;
                                }
                                if (n.type === "MultiPolygon") {
                                    const m = ql(n.coordinates, p, d), _ = Wl(r.geometry(), l, p, d);
                                    if (!An(l, p)) return !1;
                                    for (const v of _) if (!Vl(v, m)) return !1;
                                }
                                return !0;
                            }(t, this.geometries);
                            if (t.geometryType() === "LineString") return function (r, n) {
                                const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], d = r.canonicalID();
                                if (n.type === "Polygon") {
                                    const m = kn(n.coordinates, p, d), _ = Mo(r.geometry(), l, p, d);
                                    if (!An(l, p)) return !1;
                                    for (const v of _) if (!Zl(v, m)) return !1;
                                }
                                if (n.type === "MultiPolygon") {
                                    const m = ql(n.coordinates, p, d), _ = Mo(r.geometry(), l, p, d);
                                    if (!An(l, p)) return !1;
                                    for (const v of _) if (!ch(v, m)) return !1;
                                }
                                return !0;
                            }(t, this.geometries);
                        }
                        return !1;
                    }
                    eachChild() {
                    }
                    outputDefined() {
                        return !0;
                    }
                }
                let Xl = class {
                    constructor(a = [], t = (r, n) => r < n ? -1 : r > n ? 1 : 0) {
                        if (this.data = a, this.length = this.data.length, this.compare = t, this.length > 0) for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r);
                    }
                    push(a) {
                        this.data.push(a), this._up(this.length++);
                    }
                    pop() {
                        if (this.length === 0) return;
                        const a = this.data[0], t = this.data.pop();
                        return --this.length > 0 && (this.data[0] = t, this._down(0)), a;
                    }
                    peek() {
                        return this.data[0];
                    }
                    _up(a) {
                        const { data: t, compare: r } = this, n = t[a];
                        for (; a > 0;) {
                            const l = a - 1 >> 1, p = t[l];
                            if (r(n, p) >= 0) break;
                            t[a] = p, a = l;
                        }
                        t[a] = n;
                    }
                    _down(a) {
                        const { data: t, compare: r } = this, n = this.length >> 1, l = t[a];
                        for (; a < n;) {
                            let p = 1 + (a << 1);
                            const d = p + 1;
                            if (d < this.length && r(t[d], t[p]) < 0 && (p = d), r(t[p], l) >= 0) break;
                            t[a] = t[p], a = p;
                        }
                        t[a] = l;
                    }
                };
                function Kl(a, t, r = 0, n = a.length - 1, l = Yl) {
                    for (; n > r;) {
                        if (n - r > 600) {
                            const _ = n - r + 1, v = t - r + 1, b = Math.log(_), S = 0.5 * Math.exp(2 * b / 3), I = 0.5 * Math.sqrt(b * S * (_ - S) / _) * (v - _ / 2 < 0 ? -1 : 1);
                            Kl(a, t, Math.max(r, Math.floor(t - v * S / _ + I)), Math.min(n, Math.floor(t + (_ - v) * S / _ + I)), l);
                        }
                        const p = a[t];
                        let d = r, m = n;
                        for (Oa(a, r, t), l(a[n], p) > 0 && Oa(a, r, n); d < m;) {
                            for (Oa(a, d, m), d++, m--; l(a[d], p) < 0;) d++;
                            for (; l(a[m], p) > 0;) m--;
                        }
                        l(a[r], p) === 0 ? Oa(a, r, m) : (m++, Oa(a, m, n)), m <= t && (r = m + 1), t <= m && (n = m - 1);
                    }
                }
                function Oa(a, t, r) {
                    const n = a[t];
                    a[t] = a[r], a[r] = n;
                }
                function Yl(a, t) {
                    return a < t ? -1 : a > t ? 1 : 0;
                }
                function ws(a, t) {
                    if (a.length <= 1) return [a];
                    const r = [];
                    let n, l;
                    for (const p of a) {
                        const d = uh(p);
                        d !== 0 && (p.area = Math.abs(d), l === void 0 && (l = d < 0), l === d < 0 ? (n && r.push(n), n = [p]) : n.push(p));
                    }
                    if (n && r.push(n), t > 1) for (let p = 0; p < r.length; p++) r[p].length <= t || (Kl(r[p], t, 1, r[p].length - 1, hh), r[p] = r[p].slice(0, t));
                    return r;
                }
                function hh(a, t) {
                    return t.area - a.area;
                }
                function uh(a) {
                    let t = 0;
                    for (let r, n, l = 0, p = a.length, d = p - 1; l < p; d = l++) r = a[l], n = a[d], t += (n.x - r.x) * (r.y + n.y);
                    return t;
                }
                const Io = 1 / 298.257223563, Jl = Io * (2 - Io), Ql = Math.PI / 180;
                class Co {
                    constructor(t) {
                        const r = 6378.137 * Ql * 1e3, n = Math.cos(t * Ql), l = 1 / (1 - Jl * (1 - n * n)), p = Math.sqrt(l);
                        this.kx = r * p * n, this.ky = r * p * l * (1 - Jl);
                    }
                    distance(t, r) {
                        const n = this.wrap(t[0] - r[0]) * this.kx, l = (t[1] - r[1]) * this.ky;
                        return Math.sqrt(n * n + l * l);
                    }
                    pointOnLine(t, r) {
                        let n, l, p, d, m = 1 / 0;
                        for (let _ = 0; _ < t.length - 1; _++) {
                            let v = t[_][0], b = t[_][1], S = this.wrap(t[_ + 1][0] - v) * this.kx, I = (t[_ + 1][1] - b) * this.ky, A = 0;
                            S === 0 && I === 0 || (A = (this.wrap(r[0] - v) * this.kx * S + (r[1] - b) * this.ky * I) / (S * S + I * I), A > 1 ? (v = t[_ + 1][0], b = t[_ + 1][1]) : A > 0 && (v += S / this.kx * A, b += I / this.ky * A)), S = this.wrap(r[0] - v) * this.kx, I = (r[1] - b) * this.ky;
                            const k = S * S + I * I;
                            k < m && (m = k, n = v, l = b, p = _, d = A);
                        }
                        return { point: [n, l], index: p, t: Math.max(0, Math.min(1, d)) };
                    }
                    wrap(t) {
                        for (; t < -180;) t += 360;
                        for (; t > 180;) t -= 360;
                        return t;
                    }
                }
                function ec(a, t) {
                    return t[0] - a[0];
                }
                function pt(a) {
                    return a[1] - a[0] + 1;
                }
                function Cr(a, t) {
                    return a[1] >= a[0] && a[1] < t;
                }
                function Ao(a, t) {
                    if (a[0] > a[1]) return [null, null];
                    const r = pt(a);
                    if (t) {
                        if (r === 2) return [a, null];
                        const l = Math.floor(r / 2);
                        return [[a[0], a[0] + l], [a[0] + l, a[1]]];
                    }
                    if (r === 1) return [a, null];
                    const n = Math.floor(r / 2) - 1;
                    return [[a[0], a[0] + n], [a[0] + n + 1, a[1]]];
                }
                function ko(a, t) {
                    if (!Cr(t, a.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    for (let n = t[0]; n <= t[1]; ++n) Cn(r, a[n]);
                    return r;
                }
                function zo(a) {
                    const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    for (const r of a) for (const n of r) Cn(t, n);
                    return t;
                }
                function tc(a) {
                    return a[0] !== -1 / 0 && a[1] !== -1 / 0 && a[2] !== 1 / 0 && a[3] !== 1 / 0;
                }
                function Eo(a, t, r) {
                    if (!tc(a) || !tc(t)) return NaN;
                    let n = 0, l = 0;
                    return a[2] < t[0] && (n = t[0] - a[2]), a[0] > t[2] && (n = a[0] - t[2]), a[1] > t[3] && (l = a[1] - t[3]), a[3] < t[1] && (l = t[1] - a[3]), r.distance([0, 0], [n, l]);
                }
                function fa(a, t, r) {
                    const n = r.pointOnLine(t, a);
                    return r.distance(a, n.point);
                }
                function Ro(a, t, r, n, l) {
                    const p = Math.min(fa(a, [r, n], l), fa(t, [r, n], l)), d = Math.min(fa(r, [a, t], l), fa(n, [a, t], l));
                    return Math.min(p, d);
                }
                function ph(a, t, r, n, l) {
                    if (!Cr(t, a.length) || !Cr(n, r.length)) return 1 / 0;
                    let p = 1 / 0;
                    for (let d = t[0]; d < t[1]; ++d) {
                        const m = a[d], _ = a[d + 1];
                        for (let v = n[0]; v < n[1]; ++v) {
                            const b = r[v], S = r[v + 1];
                            if (bs(m, _, b, S)) return 0;
                            p = Math.min(p, Ro(m, _, b, S, l));
                        }
                    }
                    return p;
                }
                function dh(a, t, r, n, l) {
                    if (!Cr(t, a.length) || !Cr(n, r.length)) return NaN;
                    let p = 1 / 0;
                    for (let d = t[0]; d <= t[1]; ++d) for (let m = n[0]; m <= n[1]; ++m) if (p = Math.min(p, l.distance(a[d], r[m])), p === 0) return p;
                    return p;
                }
                function fh(a, t, r) {
                    if (da(a, t, !0)) return 0;
                    let n = 1 / 0;
                    for (const l of t) {
                        const p = l[0], d = l[l.length - 1];
                        if (p !== d && (n = Math.min(n, fa(a, [d, p], r)), n === 0)) return n;
                        const m = r.pointOnLine(l, a);
                        if (n = Math.min(n, r.distance(a, m.point)), n === 0) return n;
                    }
                    return n;
                }
                function mh(a, t, r, n) {
                    if (!Cr(t, a.length)) return NaN;
                    for (let p = t[0]; p <= t[1]; ++p) if (da(a[p], r, !0)) return 0;
                    let l = 1 / 0;
                    for (let p = t[0]; p < t[1]; ++p) {
                        const d = a[p], m = a[p + 1];
                        for (const _ of r) for (let v = 0, b = _.length, S = b - 1; v < b; S = v++) {
                            const I = _[S], A = _[v];
                            if (bs(d, m, I, A)) return 0;
                            l = Math.min(l, Ro(d, m, I, A, n));
                        }
                    }
                    return l;
                }
                function ic(a, t) {
                    for (const r of a) for (const n of r) if (da(n, t, !0)) return !0;
                    return !1;
                }
                function gh(a, t, r, n = 1 / 0) {
                    const l = zo(a), p = zo(t);
                    if (n !== 1 / 0 && Eo(l, p, r) >= n) return n;
                    if (An(l, p)) {
                        if (ic(a, t)) return 0;
                    } else if (ic(t, a)) return 0;
                    let d = 1 / 0;
                    for (const m of a) for (let _ = 0, v = m.length, b = v - 1; _ < v; b = _++) {
                        const S = m[b], I = m[_];
                        for (const A of t) for (let k = 0, D = A.length, N = D - 1; k < D; N = k++) {
                            const G = A[N], ie = A[k];
                            if (bs(S, I, G, ie)) return 0;
                            d = Math.min(d, Ro(S, I, G, ie, r));
                        }
                    }
                    return d;
                }
                function rc(a, t, r, n, l, p) {
                    if (!p) return;
                    const d = Eo(ko(n, p), l, r);
                    d < t && a.push([d, p, [0, 0]]);
                }
                function Ss(a, t, r, n, l, p, d) {
                    if (!p || !d) return;
                    const m = Eo(ko(n, p), ko(l, d), r);
                    m < t && a.push([m, p, d]);
                }
                function Ts(a, t, r, n, l = 1 / 0) {
                    let p = Math.min(n.distance(a[0], r[0][0]), l);
                    if (p === 0) return p;
                    const d = new Xl([[0, [0, a.length - 1], [0, 0]]], ec), m = zo(r);
                    for (; d.length > 0;) {
                        const _ = d.pop();
                        if (_[0] >= p) continue;
                        const v = _[1], b = t ? 50 : 100;
                        if (pt(v) <= b) {
                            if (!Cr(v, a.length)) return NaN;
                            if (t) {
                                const S = mh(a, v, r, n);
                                if (isNaN(S) || S === 0) return S;
                                p = Math.min(p, S);
                            } else for (let S = v[0]; S <= v[1]; ++S) {
                                const I = fh(a[S], r, n);
                                if (p = Math.min(p, I), p === 0) return 0;
                            }
                        } else {
                            const S = Ao(v, t);
                            rc(d, p, n, a, m, S[0]), rc(d, p, n, a, m, S[1]);
                        }
                    }
                    return p;
                }
                function Ps(a, t, r, n, l, p = 1 / 0) {
                    let d = Math.min(p, l.distance(a[0], r[0]));
                    if (d === 0) return d;
                    const m = new Xl([[0, [0, a.length - 1], [0, r.length - 1]]], ec);
                    for (; m.length > 0;) {
                        const _ = m.pop();
                        if (_[0] >= d) continue;
                        const v = _[1], b = _[2], S = t ? 50 : 100, I = n ? 50 : 100;
                        if (pt(v) <= S && pt(b) <= I) {
                            if (!Cr(v, a.length) && Cr(b, r.length)) return NaN;
                            let A;
                            if (t && n) A = ph(a, v, r, b, l), d = Math.min(d, A);
                            else if (t && !n) {
                                const k = a.slice(v[0], v[1] + 1);
                                for (let D = b[0]; D <= b[1]; ++D) if (A = fa(r[D], k, l), d = Math.min(d, A), d === 0) return d;
                            } else if (!t && n) {
                                const k = r.slice(b[0], b[1] + 1);
                                for (let D = v[0]; D <= v[1]; ++D) if (A = fa(a[D], k, l), d = Math.min(d, A), d === 0) return d;
                            } else A = dh(a, v, r, b, l), d = Math.min(d, A);
                        } else {
                            const A = Ao(v, t), k = Ao(b, n);
                            Ss(m, d, l, a, r, A[0], k[0]), Ss(m, d, l, a, r, A[0], k[1]), Ss(m, d, l, a, r, A[1], k[0]), Ss(m, d, l, a, r, A[1], k[1]);
                        }
                    }
                    return d;
                }
                function Do(a) {
                    return a.type === "MultiPolygon" ? a.coordinates.map((t) => ({ type: "Polygon", coordinates: t })) : a.type === "MultiLineString" ? a.coordinates.map((t) => ({ type: "LineString", coordinates: t })) : a.type === "MultiPoint" ? a.coordinates.map((t) => ({ type: "Point", coordinates: t })) : [a];
                }
                class ma {
                    constructor(t, r) {
                        this.type = Se, this.geojson = t, this.geometries = r;
                    }
                    static parse(t, r) {
                        if (t.length !== 2) return r.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                        if (vt(t[1])) {
                            const n = t[1];
                            if (n.type === "FeatureCollection") return new ma(n, n.features.map((l) => Do(l.geometry)).flat());
                            if (n.type === "Feature") return new ma(n, Do(n.geometry));
                            if ("type" in n && "coordinates" in n) return new ma(n, Do(n));
                        }
                        return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
                    }
                    evaluate(t) {
                        if (t.geometry() != null && t.canonicalID() != null) {
                            if (t.geometryType() === "Point") return function (r, n) {
                                const l = r.geometry(), p = l.flat().map((_) => Po([_.x, _.y], r.canonical));
                                if (l.length === 0) return NaN;
                                const d = new Co(p[0][1]);
                                let m = 1 / 0;
                                for (const _ of n) {
                                    switch (_.type) {
                                        case "Point":
                                            m = Math.min(m, Ps(p, !1, [_.coordinates], !1, d, m));
                                            break;
                                        case "LineString":
                                            m = Math.min(m, Ps(p, !1, _.coordinates, !0, d, m));
                                            break;
                                        case "Polygon":
                                            m = Math.min(m, Ts(p, !1, _.coordinates, d, m));
                                    }
                                    if (m === 0) return m;
                                }
                                return m;
                            }(t, this.geometries);
                            if (t.geometryType() === "LineString") return function (r, n) {
                                const l = r.geometry(), p = l.flat().map((_) => Po([_.x, _.y], r.canonical));
                                if (l.length === 0) return NaN;
                                const d = new Co(p[0][1]);
                                let m = 1 / 0;
                                for (const _ of n) {
                                    switch (_.type) {
                                        case "Point":
                                            m = Math.min(m, Ps(p, !0, [_.coordinates], !1, d, m));
                                            break;
                                        case "LineString":
                                            m = Math.min(m, Ps(p, !0, _.coordinates, !0, d, m));
                                            break;
                                        case "Polygon":
                                            m = Math.min(m, Ts(p, !0, _.coordinates, d, m));
                                    }
                                    if (m === 0) return m;
                                }
                                return m;
                            }(t, this.geometries);
                            if (t.geometryType() === "Polygon") return function (r, n) {
                                const l = r.geometry();
                                if (l.length === 0 || l[0].length === 0) return NaN;
                                const p = ws(l, 0).map((_) => _.map((v) => v.map((b) => Po([b.x, b.y], r.canonical)))), d = new Co(p[0][0][0][1]);
                                let m = 1 / 0;
                                for (const _ of n) for (const v of p) {
                                    switch (_.type) {
                                        case "Point":
                                            m = Math.min(m, Ts([_.coordinates], !1, v, d, m));
                                            break;
                                        case "LineString":
                                            m = Math.min(m, Ts(_.coordinates, !0, v, d, m));
                                            break;
                                        case "Polygon":
                                            m = Math.min(m, gh(v, _.coordinates, d, m));
                                    }
                                    if (m === 0) return m;
                                }
                                return m;
                            }(t, this.geometries);
                        }
                        return NaN;
                    }
                    eachChild() {
                    }
                    outputDefined() {
                        return !0;
                    }
                }
                class Ms {
                    constructor(t) {
                        this.type = Qe, this.key = t;
                    }
                    static parse(t, r) {
                        if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
                        const n = t[1];
                        return n == null ? r.error("Global state property must be defined.") : typeof n != "string" ? r.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Ms(n);
                    }
                    evaluate(t) {
                        var r;
                        const n = (r = t.globals) === null || r === void 0 ? void 0 : r.globalState;
                        return n && Object.keys(n).length !== 0 ? _n(n, this.key) : null;
                    }
                    eachChild() {
                    }
                    outputDefined() {
                        return !1;
                    }
                }
                const ja = { "==": gs, "!=": ah, ">": nh, "<": To, ">=": oh, "<=": sh, array: et, at: So, boolean: et, case: ei, coalesce: ua, collator: _s, format: ys, image: vs, in: ds, "index-of": Tn, interpolate: _i, "interpolate-hcl": _i, "interpolate-lab": _i, length: xs, let: Fa, literal: Ke, match: ca, number: et, "number-format": Na, object: et, slice: ha, step: $r, string: et, "to-boolean": gi, "to-color": gi, "to-number": gi, "to-string": gi, var: Sn, within: Ur, distance: ma, "global-state": Ms };
                class Wi {
                    constructor(t, r, n, l) {
                        this.name = t, this.type = r, this._evaluate = n, this.args = l;
                    }
                    evaluate(t) {
                        return this._evaluate(t, this.args);
                    }
                    eachChild(t) {
                        this.args.forEach(t);
                    }
                    outputDefined() {
                        return !1;
                    }
                    static parse(t, r) {
                        const n = t[0], l = Wi.definitions[n];
                        if (!l) return r.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
                        const p = Array.isArray(l) ? l[0] : l.type, d = Array.isArray(l) ? [[l[1], l[2]]] : l.overloads, m = d.filter(([v]) => !Array.isArray(v) || v.length === t.length - 1);
                        let _ = null;
                        for (const [v, b] of m) {
                            _ = new wn(r.registry, Is, r.path, null, r.scope);
                            const S = [];
                            let I = !1;
                            for (let A = 1; A < t.length; A++) {
                                const k = t[A], D = Array.isArray(v) ? v[A - 1] : v.type, N = _.parse(k, 1 + S.length, D);
                                if (!N) {
                                    I = !0;
                                    break;
                                }
                                S.push(N);
                            }
                            if (!I) if (Array.isArray(v) && v.length !== S.length) _.error(`Expected ${v.length} arguments, but found ${S.length} instead.`);
                            else {
                                for (let A = 0; A < S.length; A++) {
                                    const k = Array.isArray(v) ? v[A] : v.type, D = S[A];
                                    _.concat(A + 1).checkSubtype(k, D.type);
                                }
                                if (_.errors.length === 0) return new Wi(n, p, b, S);
                            }
                        }
                        if (m.length === 1) r.errors.push(..._.errors);
                        else {
                            const v = (m.length ? m : d).map(([S]) => {
                                return I = S, Array.isArray(I) ? `(${I.map(It).join(", ")})` : `(${It(I.type)}...)`;
                                var I;
                            }).join(" | "), b = [];
                            for (let S = 1; S < t.length; S++) {
                                const I = r.parse(t[S], 1 + b.length);
                                if (!I) return null;
                                b.push(It(I.type));
                            }
                            r.error(`Expected arguments of type ${v}, but found (${b.join(", ")}) instead.`);
                        }
                        return null;
                    }
                    static register(t, r) {
                        Wi.definitions = r;
                        for (const n in r) t[n] = Wi;
                    }
                }
                function ac(a, [t, r, n, l]) {
                    t = t.evaluate(a), r = r.evaluate(a), n = n.evaluate(a);
                    const p = l ? l.evaluate(a) : 1, d = bn(t, r, n, p);
                    if (d) throw new St(d);
                    return new st(t / 255, r / 255, n / 255, p, !1);
                }
                function nc(a, t) {
                    return a in t;
                }
                function Lo(a, t) {
                    const r = t[a];
                    return r === void 0 ? null : r;
                }
                function ga(a) {
                    return { type: a };
                }
                function Is(a) {
                    if (a instanceof Sn) return Is(a.boundExpression);
                    if (a instanceof Wi && a.name === "error" || a instanceof _s || a instanceof Ur || a instanceof ma || a instanceof Ms) return !1;
                    const t = a instanceof gi || a instanceof et;
                    let r = !0;
                    return a.eachChild((n) => {
                        r = t ? r && Is(n) : r && n instanceof Ke;
                    }), !!r && Cs(a) && As(a, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
                }
                function Cs(a) {
                    if (a instanceof Wi && (a.name === "get" && a.args.length === 1 || a.name === "feature-state" || a.name === "has" && a.args.length === 1 || a.name === "properties" || a.name === "geometry-type" || a.name === "id" || /^filter-/.test(a.name)) || a instanceof Ur || a instanceof ma) return !1;
                    let t = !0;
                    return a.eachChild((r) => {
                        t && !Cs(r) && (t = !1);
                    }), t;
                }
                function zn(a) {
                    if (a instanceof Wi && a.name === "feature-state") return !1;
                    let t = !0;
                    return a.eachChild((r) => {
                        t && !zn(r) && (t = !1);
                    }), t;
                }
                function As(a, t) {
                    if (a instanceof Wi && t.indexOf(a.name) >= 0) return !1;
                    let r = !0;
                    return a.eachChild((n) => {
                        r && !As(n, t) && (r = !1);
                    }), r;
                }
                function ks(a) {
                    return { result: "success", value: a };
                }
                function $a(a) {
                    return { result: "error", value: a };
                }
                function Ua(a) {
                    return a["property-type"] === "data-driven" || a["property-type"] === "cross-faded-data-driven";
                }
                function sc(a) {
                    return !!a.expression && a.expression.parameters.indexOf("zoom") > -1;
                }
                function zs(a) {
                    return !!a.expression && a.expression.interpolated;
                }
                function it(a) {
                    return a instanceof Number ? "number" : a instanceof String ? "string" : a instanceof Boolean ? "boolean" : Array.isArray(a) ? "array" : a === null ? "null" : typeof a;
                }
                function Es(a) {
                    return typeof a == "object" && a !== null && !Array.isArray(a) && Ft(a) === ki;
                }
                function Rs(a) {
                    return a;
                }
                function Bo(a, t) {
                    const r = a.stops && typeof a.stops[0][0] == "object", n = r || !(r || a.property !== void 0), l = a.type || (zs(t) ? "exponential" : "interval"), p = function (b) {
                        switch (b.type) {
                            case "color":
                                return st.parse;
                            case "padding":
                                return ci.parse;
                            case "numberArray":
                                return Ut.parse;
                            case "colorArray":
                                return hi.parse;
                            default:
                                return null;
                        }
                    }(t);
                    if (p && ((a = gt({}, a)).stops && (a.stops = a.stops.map((b) => [b[0], p(b[1])])), a.default = p(a.default ? a.default : t.default)), a.colorSpace && (d = a.colorSpace) !== "rgb" && d !== "hcl" && d !== "lab") throw new Error(`Unknown color space: "${a.colorSpace}"`);
                    var d;
                    const m = function (b) {
                        switch (b) {
                            case "exponential":
                                return oc;
                            case "interval":
                                return yh;
                            case "categorical":
                                return _h;
                            case "identity":
                                return vh;
                            default:
                                throw new Error(`Unknown function type "${b}"`);
                        }
                    }(l);
                    let _, v;
                    if (l === "categorical") {
                        _ = /* @__PURE__ */ Object.create(null);
                        for (const b of a.stops) _[b[0]] = b[1];
                        v = typeof a.stops[0][0];
                    }
                    if (r) {
                        const b = {}, S = [];
                        for (let k = 0; k < a.stops.length; k++) {
                            const D = a.stops[k], N = D[0].zoom;
                            b[N] === void 0 && (b[N] = { zoom: N, type: a.type, property: a.property, default: a.default, stops: [] }, S.push(N)), b[N].stops.push([D[0].value, D[1]]);
                        }
                        const I = [];
                        for (const k of S) I.push([b[k].zoom, Bo(b[k], t)]);
                        const A = { name: "linear" };
                        return { kind: "composite", interpolationType: A, interpolationFactor: _i.interpolationFactor.bind(void 0, A), zoomStops: I.map((k) => k[0]), evaluate: ({ zoom: k }, D) => oc({ stops: I, base: a.base }, t, k).evaluate(k, D) };
                    }
                    if (n) {
                        const b = l === "exponential" ? { name: "exponential", base: a.base !== void 0 ? a.base : 1 } : null;
                        return { kind: "camera", interpolationType: b, interpolationFactor: _i.interpolationFactor.bind(void 0, b), zoomStops: a.stops.map((S) => S[0]), evaluate: ({ zoom: S }) => m(a, t, S, _, v) };
                    }
                    return {
                        kind: "source", evaluate(b, S) {
                            const I = S && S.properties ? S.properties[a.property] : void 0;
                            return I === void 0 ? En(a.default, t.default) : m(a, t, I, _, v);
                        }
                    };
                }
                function En(a, t, r) {
                    return a !== void 0 ? a : t !== void 0 ? t : r !== void 0 ? r : void 0;
                }
                function _h(a, t, r, n, l) {
                    return En(typeof r === l ? n[r] : void 0, a.default, t.default);
                }
                function yh(a, t, r) {
                    if (it(r) !== "number") return En(a.default, t.default);
                    const n = a.stops.length;
                    if (n === 1 || r <= a.stops[0][0]) return a.stops[0][1];
                    if (r >= a.stops[n - 1][0]) return a.stops[n - 1][1];
                    const l = Pn(a.stops.map((p) => p[0]), r);
                    return a.stops[l][1];
                }
                function oc(a, t, r) {
                    const n = a.base !== void 0 ? a.base : 1;
                    if (it(r) !== "number") return En(a.default, t.default);
                    const l = a.stops.length;
                    if (l === 1 || r <= a.stops[0][0]) return a.stops[0][1];
                    if (r >= a.stops[l - 1][0]) return a.stops[l - 1][1];
                    const p = Pn(a.stops.map((b) => b[0]), r), d = function (b, S, I, A) {
                        const k = A - I, D = b - I;
                        return k === 0 ? 0 : S === 1 ? D / k : (Math.pow(S, D) - 1) / (Math.pow(S, k) - 1);
                    }(r, n, a.stops[p][0], a.stops[p + 1][0]), m = a.stops[p][1], _ = a.stops[p + 1][1], v = gr[t.type] || Rs;
                    return typeof m.evaluate == "function" ? {
                        evaluate(...b) {
                            const S = m.evaluate.apply(void 0, b), I = _.evaluate.apply(void 0, b);
                            if (S !== void 0 && I !== void 0) return v(S, I, d, a.colorSpace);
                        }
                    } : v(m, _, d, a.colorSpace);
                }
                function vh(a, t, r) {
                    switch (t.type) {
                        case "color":
                            r = st.parse(r);
                            break;
                        case "formatted":
                            r = zi.fromString(r.toString());
                            break;
                        case "resolvedImage":
                            r = Oi.fromString(r.toString());
                            break;
                        case "padding":
                            r = ci.parse(r);
                            break;
                        case "colorArray":
                            r = hi.parse(r);
                            break;
                        case "numberArray":
                            r = Ut.parse(r);
                            break;
                        default:
                            it(r) === t.type || t.type === "enum" && t.values[r] || (r = void 0);
                    }
                    return En(r, a.default, t.default);
                }
                Wi.register(ja, {
                    error: [{ kind: "error" }, [qe], (a, [t]) => {
                        throw new St(t.evaluate(a));
                    }], typeof: [qe, [Qe], (a, [t]) => It(Ft(t.evaluate(a)))], "to-rgba": [Ni(Se, 4), [Lt], (a, [t]) => {
                        const [r, n, l, p] = t.evaluate(a).rgb;
                        return [255 * r, 255 * n, 255 * l, p];
                    }], rgb: [Lt, [Se, Se, Se], ac], rgba: [Lt, [Se, Se, Se, Se], ac], has: { type: Je, overloads: [[[qe], (a, [t]) => nc(t.evaluate(a), a.properties())], [[qe, ki], (a, [t, r]) => nc(t.evaluate(a), r.evaluate(a))]] }, get: { type: Qe, overloads: [[[qe], (a, [t]) => Lo(t.evaluate(a), a.properties())], [[qe, ki], (a, [t, r]) => Lo(t.evaluate(a), r.evaluate(a))]] }, "feature-state": [Qe, [qe], (a, [t]) => Lo(t.evaluate(a), a.featureState || {})], properties: [ki, [], (a) => a.properties()], "geometry-type": [qe, [], (a) => a.geometryType()], id: [Qe, [], (a) => a.id()], zoom: [Se, [], (a) => a.globals.zoom], "heatmap-density": [Se, [], (a) => a.globals.heatmapDensity || 0], "line-progress": [Se, [], (a) => a.globals.lineProgress || 0], accumulated: [Qe, [], (a) => a.globals.accumulated === void 0 ? null : a.globals.accumulated], "+": [Se, ga(Se), (a, t) => {
                        let r = 0;
                        for (const n of t) r += n.evaluate(a);
                        return r;
                    }], "*": [Se, ga(Se), (a, t) => {
                        let r = 1;
                        for (const n of t) r *= n.evaluate(a);
                        return r;
                    }], "-": { type: Se, overloads: [[[Se, Se], (a, [t, r]) => t.evaluate(a) - r.evaluate(a)], [[Se], (a, [t]) => -t.evaluate(a)]] }, "/": [Se, [Se, Se], (a, [t, r]) => t.evaluate(a) / r.evaluate(a)], "%": [Se, [Se, Se], (a, [t, r]) => t.evaluate(a) % r.evaluate(a)], ln2: [Se, [], () => Math.LN2], pi: [Se, [], () => Math.PI], e: [Se, [], () => Math.E], "^": [Se, [Se, Se], (a, [t, r]) => Math.pow(t.evaluate(a), r.evaluate(a))], sqrt: [Se, [Se], (a, [t]) => Math.sqrt(t.evaluate(a))], log10: [Se, [Se], (a, [t]) => Math.log(t.evaluate(a)) / Math.LN10], ln: [Se, [Se], (a, [t]) => Math.log(t.evaluate(a))], log2: [Se, [Se], (a, [t]) => Math.log(t.evaluate(a)) / Math.LN2], sin: [Se, [Se], (a, [t]) => Math.sin(t.evaluate(a))], cos: [Se, [Se], (a, [t]) => Math.cos(t.evaluate(a))], tan: [Se, [Se], (a, [t]) => Math.tan(t.evaluate(a))], asin: [Se, [Se], (a, [t]) => Math.asin(t.evaluate(a))], acos: [Se, [Se], (a, [t]) => Math.acos(t.evaluate(a))], atan: [Se, [Se], (a, [t]) => Math.atan(t.evaluate(a))], min: [Se, ga(Se), (a, t) => Math.min(...t.map((r) => r.evaluate(a)))], max: [Se, ga(Se), (a, t) => Math.max(...t.map((r) => r.evaluate(a)))], abs: [Se, [Se], (a, [t]) => Math.abs(t.evaluate(a))], round: [Se, [Se], (a, [t]) => {
                        const r = t.evaluate(a);
                        return r < 0 ? -Math.round(-r) : Math.round(r);
                    }], floor: [Se, [Se], (a, [t]) => Math.floor(t.evaluate(a))], ceil: [Se, [Se], (a, [t]) => Math.ceil(t.evaluate(a))], "filter-==": [Je, [qe, Qe], (a, [t, r]) => a.properties()[t.value] === r.value], "filter-id-==": [Je, [Qe], (a, [t]) => a.id() === t.value], "filter-type-==": [Je, [qe], (a, [t]) => a.geometryType() === t.value], "filter-<": [Je, [qe, Qe], (a, [t, r]) => {
                        const n = a.properties()[t.value], l = r.value;
                        return typeof n == typeof l && n < l;
                    }], "filter-id-<": [Je, [Qe], (a, [t]) => {
                        const r = a.id(), n = t.value;
                        return typeof r == typeof n && r < n;
                    }], "filter->": [Je, [qe, Qe], (a, [t, r]) => {
                        const n = a.properties()[t.value], l = r.value;
                        return typeof n == typeof l && n > l;
                    }], "filter-id->": [Je, [Qe], (a, [t]) => {
                        const r = a.id(), n = t.value;
                        return typeof r == typeof n && r > n;
                    }], "filter-<=": [Je, [qe, Qe], (a, [t, r]) => {
                        const n = a.properties()[t.value], l = r.value;
                        return typeof n == typeof l && n <= l;
                    }], "filter-id-<=": [Je, [Qe], (a, [t]) => {
                        const r = a.id(), n = t.value;
                        return typeof r == typeof n && r <= n;
                    }], "filter->=": [Je, [qe, Qe], (a, [t, r]) => {
                        const n = a.properties()[t.value], l = r.value;
                        return typeof n == typeof l && n >= l;
                    }], "filter-id->=": [Je, [Qe], (a, [t]) => {
                        const r = a.id(), n = t.value;
                        return typeof r == typeof n && r >= n;
                    }], "filter-has": [Je, [Qe], (a, [t]) => t.value in a.properties()], "filter-has-id": [Je, [], (a) => a.id() !== null && a.id() !== void 0], "filter-type-in": [Je, [Ni(qe)], (a, [t]) => t.value.indexOf(a.geometryType()) >= 0], "filter-id-in": [Je, [Ni(Qe)], (a, [t]) => t.value.indexOf(a.id()) >= 0], "filter-in-small": [Je, [qe, Ni(Qe)], (a, [t, r]) => r.value.indexOf(a.properties()[t.value]) >= 0], "filter-in-large": [Je, [qe, Ni(Qe)], (a, [t, r]) => function (n, l, p, d) {
                        for (; p <= d;) {
                            const m = p + d >> 1;
                            if (l[m] === n) return !0;
                            l[m] > n ? d = m - 1 : p = m + 1;
                        }
                        return !1;
                    }(a.properties()[t.value], r.value, 0, r.value.length - 1)], all: {
                        type: Je, overloads: [[[Je, Je], (a, [t, r]) => t.evaluate(a) && r.evaluate(a)], [ga(Je), (a, t) => {
                            for (const r of t) if (!r.evaluate(a)) return !1;
                            return !0;
                        }]]
                    }, any: {
                        type: Je, overloads: [[[Je, Je], (a, [t, r]) => t.evaluate(a) || r.evaluate(a)], [ga(Je), (a, t) => {
                            for (const r of t) if (r.evaluate(a)) return !0;
                            return !1;
                        }]]
                    }, "!": [Je, [Je], (a, [t]) => !t.evaluate(a)], "is-supported-script": [Je, [qe], (a, [t]) => {
                        const r = a.globals && a.globals.isSupportedScript;
                        return !r || r(t.evaluate(a));
                    }], upcase: [qe, [qe], (a, [t]) => t.evaluate(a).toUpperCase()], downcase: [qe, [qe], (a, [t]) => t.evaluate(a).toLowerCase()], concat: [qe, ga(Qe), (a, t) => t.map((r) => ot(r.evaluate(a))).join("")], "resolved-locale": [qe, [ka], (a, [t]) => t.evaluate(a).resolvedLocale()]
                });
                class Ds {
                    constructor(t, r) {
                        this.expression = t, this._warningHistory = {}, this._evaluator = new wo(), this._defaultValue = r ? function (n) {
                            if (n.type === "color" && Es(n.default)) return new st(0, 0, 0, 0);
                            switch (n.type) {
                                case "color":
                                    return st.parse(n.default) || null;
                                case "padding":
                                    return ci.parse(n.default) || null;
                                case "numberArray":
                                    return Ut.parse(n.default) || null;
                                case "colorArray":
                                    return hi.parse(n.default) || null;
                                case "variableAnchorOffsetCollection":
                                    return Pi.parse(n.default) || null;
                                case "projectionDefinition":
                                    return Ei.parse(n.default) || null;
                                default:
                                    return n.default === void 0 ? null : n.default;
                            }
                        }(r) : null, this._enumValues = r && r.type === "enum" ? r.values : null;
                    }
                    evaluateWithoutErrorHandling(t, r, n, l, p, d) {
                        return this._evaluator.globals = t, this._evaluator.feature = r, this._evaluator.featureState = n, this._evaluator.canonical = l, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = d, this.expression.evaluate(this._evaluator);
                    }
                    evaluate(t, r, n, l, p, d) {
                        this._evaluator.globals = t, this._evaluator.feature = r || null, this._evaluator.featureState = n || null, this._evaluator.canonical = l, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = d || null;
                        try {
                            const m = this.expression.evaluate(this._evaluator);
                            if (m == null || typeof m == "number" && m != m) return this._defaultValue;
                            if (this._enumValues && !(m in this._enumValues)) throw new St(`Expected value to be one of ${Object.keys(this._enumValues).map((_) => JSON.stringify(_)).join(", ")}, but found ${JSON.stringify(m)} instead.`);
                            return m;
                        } catch (m) {
                            return this._warningHistory[m.message] || (this._warningHistory[m.message] = !0, typeof console < "u" && console.warn(m.message)), this._defaultValue;
                        }
                    }
                }
                function Rn(a) {
                    return Array.isArray(a) && a.length > 0 && typeof a[0] == "string" && a[0] in ja;
                }
                function Ls(a, t) {
                    const r = new wn(ja, Is, [], t ? function (l) {
                        const p = { color: Lt, string: qe, number: Se, enum: qe, boolean: Je, formatted: fn, padding: ra, numberArray: Mr, colorArray: mn, projectionDefinition: Bt, resolvedImage: aa, variableAnchorOffsetCollection: $t };
                        return l.type === "array" ? Ni(p[l.value] || Qe, l.length) : p[l.type];
                    }(t) : void 0), n = r.parse(a, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
                    return n ? ks(new Ds(n, t)) : $a(r.errors);
                }
                class Fo {
                    constructor(t, r) {
                        this.kind = t, this._styleExpression = r, this.isStateDependent = t !== "constant" && !zn(r.expression);
                    }
                    evaluateWithoutErrorHandling(t, r, n, l, p, d) {
                        return this._styleExpression.evaluateWithoutErrorHandling(t, r, n, l, p, d);
                    }
                    evaluate(t, r, n, l, p, d) {
                        return this._styleExpression.evaluate(t, r, n, l, p, d);
                    }
                }
                class Bs {
                    constructor(t, r, n, l) {
                        this.kind = t, this.zoomStops = n, this._styleExpression = r, this.isStateDependent = t !== "camera" && !zn(r.expression), this.interpolationType = l;
                    }
                    evaluateWithoutErrorHandling(t, r, n, l, p, d) {
                        return this._styleExpression.evaluateWithoutErrorHandling(t, r, n, l, p, d);
                    }
                    evaluate(t, r, n, l, p, d) {
                        return this._styleExpression.evaluate(t, r, n, l, p, d);
                    }
                    interpolationFactor(t, r, n) {
                        return this.interpolationType ? _i.interpolationFactor(this.interpolationType, t, r, n) : 0;
                    }
                }
                function No(a, t) {
                    const r = Ls(a, t);
                    if (r.result === "error") return r;
                    const n = r.value.expression, l = Cs(n);
                    if (!l && !Ua(t)) return $a([new nt("", "data expressions not supported")]);
                    const p = As(n, ["zoom"]);
                    if (!p && !sc(t)) return $a([new nt("", "zoom expressions not supported")]);
                    const d = Ln(n);
                    return d || p ? d instanceof nt ? $a([d]) : d instanceof _i && !zs(t) ? $a([new nt("", '"interpolate" expressions cannot be used with this property')]) : ks(d ? new Bs(l ? "camera" : "composite", r.value, d.labels, d instanceof _i ? d.interpolation : void 0) : new Fo(l ? "constant" : "source", r.value)) : $a([new nt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
                }
                class Dn {
                    constructor(t, r) {
                        this._parameters = t, this._specification = r, gt(this, Bo(this._parameters, this._specification));
                    }
                    static deserialize(t) {
                        return new Dn(t._parameters, t._specification);
                    }
                    static serialize(t) {
                        return { _parameters: t._parameters, _specification: t._specification };
                    }
                }
                function Ln(a) {
                    let t = null;
                    if (a instanceof Fa) t = Ln(a.result);
                    else if (a instanceof ua) {
                        for (const r of a.args) if (t = Ln(r), t) break;
                    } else (a instanceof $r || a instanceof _i) && a.input instanceof Wi && a.input.name === "zoom" && (t = a);
                    return t instanceof nt || a.eachChild((r) => {
                        const n = Ln(r);
                        n instanceof nt ? t = n : !t && n ? t = new nt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && n && t !== n && (t = new nt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
                    }), t;
                }
                function Bn(a) {
                    if (a === !0 || a === !1) return !0;
                    if (!Array.isArray(a) || a.length === 0) return !1;
                    switch (a[0]) {
                        case "has":
                            return a.length >= 2 && a[1] !== "$id" && a[1] !== "$type";
                        case "in":
                            return a.length >= 3 && (typeof a[1] != "string" || Array.isArray(a[2]));
                        case "!in":
                        case "!has":
                        case "none":
                            return !1;
                        case "==":
                        case "!=":
                        case ">":
                        case ">=":
                        case "<":
                        case "<=":
                            return a.length !== 3 || Array.isArray(a[1]) || Array.isArray(a[2]);
                        case "any":
                        case "all":
                            for (const t of a.slice(1)) if (!Bn(t) && typeof t != "boolean") return !1;
                            return !0;
                        default:
                            return !0;
                    }
                }
                const Oo = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
                function Fn(a) {
                    if (a == null) return { filter: () => !0, needGeometry: !1 };
                    Bn(a) || (a = Ns(a));
                    const t = Ls(a, Oo);
                    if (t.result === "error") throw new Error(t.value.map((r) => `${r.key}: ${r.message}`).join(", "));
                    return { filter: (r, n, l) => t.value.evaluate(r, n, {}, l), needGeometry: lc(a) };
                }
                function Fs(a, t) {
                    return a < t ? -1 : a > t ? 1 : 0;
                }
                function lc(a) {
                    if (!Array.isArray(a)) return !1;
                    if (a[0] === "within" || a[0] === "distance") return !0;
                    for (let t = 1; t < a.length; t++) if (lc(a[t])) return !0;
                    return !1;
                }
                function Ns(a) {
                    if (!a) return !0;
                    const t = a[0];
                    return a.length <= 1 ? t !== "any" : t === "==" ? jo(a[1], a[2], "==") : t === "!=" ? Os(jo(a[1], a[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? jo(a[1], a[2], t) : t === "any" ? (r = a.slice(1), ["any"].concat(r.map(Ns))) : t === "all" ? ["all"].concat(a.slice(1).map(Ns)) : t === "none" ? ["all"].concat(a.slice(1).map(Ns).map(Os)) : t === "in" ? cc(a[1], a.slice(2)) : t === "!in" ? Os(cc(a[1], a.slice(2))) : t === "has" ? hc(a[1]) : t !== "!has" || Os(hc(a[1]));
                    var r;
                }
                function jo(a, t, r) {
                    switch (a) {
                        case "$type":
                            return [`filter-type-${r}`, t];
                        case "$id":
                            return [`filter-id-${r}`, t];
                        default:
                            return [`filter-${r}`, a, t];
                    }
                }
                function cc(a, t) {
                    if (t.length === 0) return !1;
                    switch (a) {
                        case "$type":
                            return ["filter-type-in", ["literal", t]];
                        case "$id":
                            return ["filter-id-in", ["literal", t]];
                        default:
                            return t.length > 200 && !t.some((r) => typeof r != typeof t[0]) ? ["filter-in-large", a, ["literal", t.sort(Fs)]] : ["filter-in-small", a, ["literal", t]];
                    }
                }
                function hc(a) {
                    switch (a) {
                        case "$type":
                            return !0;
                        case "$id":
                            return ["filter-has-id"];
                        default:
                            return ["filter-has", a];
                    }
                }
                function Os(a) {
                    return ["!", a];
                }
                function js(a) {
                    const t = typeof a;
                    if (t === "number" || t === "boolean" || t === "string" || a == null) return JSON.stringify(a);
                    if (Array.isArray(a)) {
                        let l = "[";
                        for (const p of a) l += `${js(p)},`;
                        return `${l}]`;
                    }
                    const r = Object.keys(a).sort();
                    let n = "{";
                    for (let l = 0; l < r.length; l++) n += `${JSON.stringify(r[l])}:${js(a[r[l]])},`;
                    return `${n}}`;
                }
                function uc(a) {
                    let t = "";
                    for (const r of pe) t += `/${js(a[r])}`;
                    return t;
                }
                function Nn(a) {
                    const t = a.value;
                    return t ? [new ve(a.key, t, "constants have been deprecated as of v8")] : [];
                }
                function jt(a) {
                    return a instanceof Number || a instanceof String || a instanceof Boolean ? a.valueOf() : a;
                }
                function Vr(a) {
                    if (Array.isArray(a)) return a.map(Vr);
                    if (a instanceof Object && !(a instanceof Number || a instanceof String || a instanceof Boolean)) {
                        const t = {};
                        for (const r in a) t[r] = Vr(a[r]);
                        return t;
                    }
                    return jt(a);
                }
                function ji(a) {
                    const t = a.key, r = a.value, n = a.valueSpec || {}, l = a.objectElementValidators || {}, p = a.style, d = a.styleSpec, m = a.validateSpec;
                    let _ = [];
                    const v = it(r);
                    if (v !== "object") return [new ve(t, r, `object expected, ${v} found`)];
                    for (const b in r) {
                        const S = b.split(".")[0], I = _n(n, S) || n["*"];
                        let A;
                        if (_n(l, S)) A = l[S];
                        else if (_n(n, S)) A = m;
                        else if (l["*"]) A = l["*"];
                        else {
                            if (!n["*"]) {
                                _.push(new ve(t, r[b], `unknown property "${b}"`));
                                continue;
                            }
                            A = m;
                        }
                        _ = _.concat(A({ key: (t && `${t}.`) + b, value: r[b], valueSpec: I, style: p, styleSpec: d, object: r, objectKey: b, validateSpec: m }, r));
                    }
                    for (const b in n) l[b] || n[b].required && n[b].default === void 0 && r[b] === void 0 && _.push(new ve(t, r, `missing required property "${b}"`));
                    return _;
                }
                function $o(a) {
                    const t = a.value, r = a.valueSpec, n = a.style, l = a.styleSpec, p = a.key, d = a.arrayElementValidator || a.validateSpec;
                    if (it(t) !== "array") return [new ve(p, t, `array expected, ${it(t)} found`)];
                    if (r.length && t.length !== r.length) return [new ve(p, t, `array length ${r.length} expected, length ${t.length} found`)];
                    if (r["min-length"] && t.length < r["min-length"]) return [new ve(p, t, `array length at least ${r["min-length"]} expected, length ${t.length} found`)];
                    let m = { type: r.value, values: r.values };
                    l.$version < 7 && (m.function = r.function), it(r.value) === "object" && (m = r.value);
                    let _ = [];
                    for (let v = 0; v < t.length; v++) _ = _.concat(d({ array: t, arrayIndex: v, value: t[v], valueSpec: m, validateSpec: a.validateSpec, style: n, styleSpec: l, key: `${p}[${v}]` }));
                    return _;
                }
                function On(a) {
                    const t = a.key, r = a.value, n = a.valueSpec;
                    let l = it(r);
                    return l === "number" && r != r && (l = "NaN"), l !== "number" ? [new ve(t, r, `number expected, ${l} found`)] : "minimum" in n && r < n.minimum ? [new ve(t, r, `${r} is less than the minimum value ${n.minimum}`)] : "maximum" in n && r > n.maximum ? [new ve(t, r, `${r} is greater than the maximum value ${n.maximum}`)] : [];
                }
                function Uo(a) {
                    const t = a.valueSpec, r = jt(a.value.type);
                    let n, l, p, d = {};
                    const m = r !== "categorical" && a.value.property === void 0, _ = !m, v = it(a.value.stops) === "array" && it(a.value.stops[0]) === "array" && it(a.value.stops[0][0]) === "object", b = ji({
                        key: a.key, value: a.value, valueSpec: a.styleSpec.function, validateSpec: a.validateSpec, style: a.style, styleSpec: a.styleSpec, objectElementValidators: {
                            stops: function (A) {
                                if (r === "identity") return [new ve(A.key, A.value, 'identity function may not have a "stops" property')];
                                let k = [];
                                const D = A.value;
                                return k = k.concat($o({ key: A.key, value: D, valueSpec: A.valueSpec, validateSpec: A.validateSpec, style: A.style, styleSpec: A.styleSpec, arrayElementValidator: S })), it(D) === "array" && D.length === 0 && k.push(new ve(A.key, D, "array must have at least one stop")), k;
                            }, default: function (A) {
                                return A.validateSpec({ key: A.key, value: A.value, valueSpec: t, validateSpec: A.validateSpec, style: A.style, styleSpec: A.styleSpec });
                            }
                        }
                    });
                    return r === "identity" && m && b.push(new ve(a.key, a.value, 'missing required property "property"')), r === "identity" || a.value.stops || b.push(new ve(a.key, a.value, 'missing required property "stops"')), r === "exponential" && a.valueSpec.expression && !zs(a.valueSpec) && b.push(new ve(a.key, a.value, "exponential functions not supported")), a.styleSpec.$version >= 8 && (_ && !Ua(a.valueSpec) ? b.push(new ve(a.key, a.value, "property functions not supported")) : m && !sc(a.valueSpec) && b.push(new ve(a.key, a.value, "zoom functions not supported"))), r !== "categorical" && !v || a.value.property !== void 0 || b.push(new ve(a.key, a.value, '"property" property is required')), b;
                    function S(A) {
                        let k = [];
                        const D = A.value, N = A.key;
                        if (it(D) !== "array") return [new ve(N, D, `array expected, ${it(D)} found`)];
                        if (D.length !== 2) return [new ve(N, D, `array length 2 expected, length ${D.length} found`)];
                        if (v) {
                            if (it(D[0]) !== "object") return [new ve(N, D, `object expected, ${it(D[0])} found`)];
                            if (D[0].zoom === void 0) return [new ve(N, D, "object stop key must have zoom")];
                            if (D[0].value === void 0) return [new ve(N, D, "object stop key must have value")];
                            if (p && p > jt(D[0].zoom)) return [new ve(N, D[0].zoom, "stop zoom values must appear in ascending order")];
                            jt(D[0].zoom) !== p && (p = jt(D[0].zoom), l = void 0, d = {}), k = k.concat(ji({ key: `${N}[0]`, value: D[0], valueSpec: { zoom: {} }, validateSpec: A.validateSpec, style: A.style, styleSpec: A.styleSpec, objectElementValidators: { zoom: On, value: I } }));
                        } else k = k.concat(I({ key: `${N}[0]`, value: D[0], validateSpec: A.validateSpec, style: A.style, styleSpec: A.styleSpec }, D));
                        return Rn(Vr(D[1])) ? k.concat([new ve(`${N}[1]`, D[1], "expressions are not allowed in function stops.")]) : k.concat(A.validateSpec({ key: `${N}[1]`, value: D[1], valueSpec: t, validateSpec: A.validateSpec, style: A.style, styleSpec: A.styleSpec }));
                    }
                    function I(A, k) {
                        const D = it(A.value), N = jt(A.value), G = A.value !== null ? A.value : k;
                        if (n) {
                            if (D !== n) return [new ve(A.key, G, `${D} stop domain type must match previous stop domain type ${n}`)];
                        } else n = D;
                        if (D !== "number" && D !== "string" && D !== "boolean") return [new ve(A.key, G, "stop domain value must be a number, string, or boolean")];
                        if (D !== "number" && r !== "categorical") {
                            let ie = `number expected, ${D} found`;
                            return Ua(t) && r === void 0 && (ie += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ve(A.key, G, ie)];
                        }
                        return r !== "categorical" || D !== "number" || isFinite(N) && Math.floor(N) === N ? r !== "categorical" && D === "number" && l !== void 0 && N < l ? [new ve(A.key, G, "stop domain values must appear in ascending order")] : (l = N, r === "categorical" && N in d ? [new ve(A.key, G, "stop domain values must be unique")] : (d[N] = !0, [])) : [new ve(A.key, G, `integer expected, found ${N}`)];
                    }
                }
                function yr(a) {
                    const t = (a.expressionContext === "property" ? No : Ls)(Vr(a.value), a.valueSpec);
                    if (t.result === "error") return t.value.map((n) => new ve(`${a.key}${n.key}`, a.value, n.message));
                    const r = t.value.expression || t.value._styleExpression.expression;
                    if (a.expressionContext === "property" && a.propertyKey === "text-font" && !r.outputDefined()) return [new ve(a.key, a.value, `Invalid data expression for "${a.propertyKey}". Output values must be contained as literals within the expression.`)];
                    if (a.expressionContext === "property" && a.propertyType === "layout" && !zn(r)) return [new ve(a.key, a.value, '"feature-state" data expressions are not supported with layout properties.')];
                    if (a.expressionContext === "filter" && !zn(r)) return [new ve(a.key, a.value, '"feature-state" data expressions are not supported with filters.')];
                    if (a.expressionContext && a.expressionContext.indexOf("cluster") === 0) {
                        if (!As(r, ["zoom", "feature-state"])) return [new ve(a.key, a.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
                        if (a.expressionContext === "cluster-initial" && !Cs(r)) return [new ve(a.key, a.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
                    }
                    return [];
                }
                function Vo(a) {
                    const t = a.key, r = a.value, n = it(r);
                    return n !== "string" ? [new ve(t, r, `color expected, ${n} found`)] : st.parse(String(r)) ? [] : [new ve(t, r, `color expected, "${r}" found`)];
                }
                function jn(a) {
                    const t = a.key, r = a.value, n = a.valueSpec, l = [];
                    return Array.isArray(n.values) ? n.values.indexOf(jt(r)) === -1 && l.push(new ve(t, r, `expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)) : Object.keys(n.values).indexOf(jt(r)) === -1 && l.push(new ve(t, r, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)), l;
                }
                function Zo(a) {
                    return Bn(Vr(a.value)) ? yr(gt({}, a, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : pc(a);
                }
                function pc(a) {
                    const t = a.value, r = a.key;
                    if (it(t) !== "array") return [new ve(r, t, `array expected, ${it(t)} found`)];
                    const n = a.styleSpec;
                    let l, p = [];
                    if (t.length < 1) return [new ve(r, t, "filter array must have at least 1 element")];
                    switch (p = p.concat(jn({ key: `${r}[0]`, value: t[0], valueSpec: n.filter_operator, style: a.style, styleSpec: a.styleSpec })), jt(t[0])) {
                        case "<":
                        case "<=":
                        case ">":
                        case ">=":
                            t.length >= 2 && jt(t[1]) === "$type" && p.push(new ve(r, t, `"$type" cannot be use with operator "${t[0]}"`));
                        case "==":
                        case "!=":
                            t.length !== 3 && p.push(new ve(r, t, `filter array for operator "${t[0]}" must have 3 elements`));
                        case "in":
                        case "!in":
                            t.length >= 2 && (l = it(t[1]), l !== "string" && p.push(new ve(`${r}[1]`, t[1], `string expected, ${l} found`)));
                            for (let d = 2; d < t.length; d++) l = it(t[d]), jt(t[1]) === "$type" ? p = p.concat(jn({ key: `${r}[${d}]`, value: t[d], valueSpec: n.geometry_type, style: a.style, styleSpec: a.styleSpec })) : l !== "string" && l !== "number" && l !== "boolean" && p.push(new ve(`${r}[${d}]`, t[d], `string, number, or boolean expected, ${l} found`));
                            break;
                        case "any":
                        case "all":
                        case "none":
                            for (let d = 1; d < t.length; d++) p = p.concat(pc({ key: `${r}[${d}]`, value: t[d], style: a.style, styleSpec: a.styleSpec }));
                            break;
                        case "has":
                        case "!has":
                            l = it(t[1]), t.length !== 2 ? p.push(new ve(r, t, `filter array for "${t[0]}" operator must have 2 elements`)) : l !== "string" && p.push(new ve(`${r}[1]`, t[1], `string expected, ${l} found`));
                    }
                    return p;
                }
                function dc(a, t) {
                    const r = a.key, n = a.validateSpec, l = a.style, p = a.styleSpec, d = a.value, m = a.objectKey, _ = p[`${t}_${a.layerType}`];
                    if (!_) return [];
                    const v = m.match(/^(.*)-transition$/);
                    if (t === "paint" && v && _[v[1]] && _[v[1]].transition) return n({ key: r, value: d, valueSpec: p.transition, style: l, styleSpec: p });
                    const b = a.valueSpec || _[m];
                    if (!b) return [new ve(r, d, `unknown property "${m}"`)];
                    let S;
                    if (it(d) === "string" && Ua(b) && !b.tokens && (S = /^{([^}]+)}$/.exec(d))) return [new ve(r, d, `"${m}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(S[1])} }\`.`)];
                    const I = [];
                    return a.layerType === "symbol" && (m === "text-field" && l && !l.glyphs && I.push(new ve(r, d, 'use of "text-field" requires a style "glyphs" property')), m === "text-font" && Es(Vr(d)) && jt(d.type) === "identity" && I.push(new ve(r, d, '"text-font" does not support identity functions'))), I.concat(n({ key: a.key, value: d, valueSpec: b, style: l, styleSpec: p, expressionContext: "property", propertyType: t, propertyKey: m }));
                }
                function fc(a) {
                    return dc(a, "paint");
                }
                function Va(a) {
                    return dc(a, "layout");
                }
                function Za(a) {
                    let t = [];
                    const r = a.value, n = a.key, l = a.style, p = a.styleSpec;
                    if (it(r) !== "object") return [new ve(n, r, `object expected, ${it(r)} found`)];
                    r.type || r.ref || t.push(new ve(n, r, 'either "type" or "ref" is required'));
                    let d = jt(r.type);
                    const m = jt(r.ref);
                    if (r.id) {
                        const _ = jt(r.id);
                        for (let v = 0; v < a.arrayIndex; v++) {
                            const b = l.layers[v];
                            jt(b.id) === _ && t.push(new ve(n, r.id, `duplicate layer id "${r.id}", previously used at line ${b.id.__line__}`));
                        }
                    }
                    if ("ref" in r) {
                        let _;
                        ["type", "source", "source-layer", "filter", "layout"].forEach((v) => {
                            v in r && t.push(new ve(n, r[v], `"${v}" is prohibited for ref layers`));
                        }), l.layers.forEach((v) => {
                            jt(v.id) === m && (_ = v);
                        }), _ ? _.ref ? t.push(new ve(n, r.ref, "ref cannot reference another ref layer")) : d = jt(_.type) : t.push(new ve(n, r.ref, `ref layer "${m}" not found`));
                    } else if (d !== "background") if (r.source) {
                        const _ = l.sources && l.sources[r.source], v = _ && jt(_.type);
                        _ ? v === "vector" && d === "raster" ? t.push(new ve(n, r.source, `layer "${r.id}" requires a raster source`)) : v !== "raster-dem" && d === "hillshade" ? t.push(new ve(n, r.source, `layer "${r.id}" requires a raster-dem source`)) : v === "raster" && d !== "raster" ? t.push(new ve(n, r.source, `layer "${r.id}" requires a vector source`)) : v !== "vector" || r["source-layer"] ? v === "raster-dem" && d !== "hillshade" ? t.push(new ve(n, r.source, "raster-dem source can only be used with layer type 'hillshade'.")) : d !== "line" || !r.paint || !r.paint["line-gradient"] || v === "geojson" && _.lineMetrics || t.push(new ve(n, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new ve(n, r, `layer "${r.id}" must specify a "source-layer"`)) : t.push(new ve(n, r.source, `source "${r.source}" not found`));
                    } else t.push(new ve(n, r, 'missing required property "source"'));
                    return t = t.concat(ji({ key: n, value: r, valueSpec: p.layer, style: a.style, styleSpec: a.styleSpec, validateSpec: a.validateSpec, objectElementValidators: { "*": () => [], type: () => a.validateSpec({ key: `${n}.type`, value: r.type, valueSpec: p.layer.type, style: a.style, styleSpec: a.styleSpec, validateSpec: a.validateSpec, object: r, objectKey: "type" }), filter: Zo, layout: (_) => ji({ layer: r, key: _.key, value: _.value, style: _.style, styleSpec: _.styleSpec, validateSpec: _.validateSpec, objectElementValidators: { "*": (v) => Va(gt({ layerType: d }, v)) } }), paint: (_) => ji({ layer: r, key: _.key, value: _.value, style: _.style, styleSpec: _.styleSpec, validateSpec: _.validateSpec, objectElementValidators: { "*": (v) => fc(gt({ layerType: d }, v)) } }) } })), t;
                }
                function Xt(a) {
                    const t = a.value, r = a.key, n = it(t);
                    return n !== "string" ? [new ve(r, t, `string expected, ${n} found`)] : [];
                }
                const Ga = {
                    promoteId: function ({ key: a, value: t }) {
                        if (it(t) === "string") return Xt({ key: a, value: t });
                        {
                            const r = [];
                            for (const n in t) r.push(...Xt({ key: `${a}.${n}`, value: t[n] }));
                            return r;
                        }
                    }
                };
                function Go(a) {
                    const t = a.value, r = a.key, n = a.styleSpec, l = a.style, p = a.validateSpec;
                    if (!t.type) return [new ve(r, t, '"type" is required')];
                    const d = jt(t.type);
                    let m;
                    switch (d) {
                        case "vector":
                        case "raster":
                            return m = ji({ key: r, value: t, valueSpec: n[`source_${d.replace("-", "_")}`], style: a.style, styleSpec: n, objectElementValidators: Ga, validateSpec: p }), m;
                        case "raster-dem":
                            return m = function (_) {
                                var v;
                                const b = (v = _.sourceName) !== null && v !== void 0 ? v : "", S = _.value, I = _.styleSpec, A = I.source_raster_dem, k = _.style;
                                let D = [];
                                const N = it(S);
                                if (S === void 0) return D;
                                if (N !== "object") return D.push(new ve("source_raster_dem", S, `object expected, ${N} found`)), D;
                                const G = jt(S.encoding) === "custom", ie = ["redFactor", "greenFactor", "blueFactor", "baseShift"], H = _.value.encoding ? `"${_.value.encoding}"` : "Default";
                                for (const C in S) !G && ie.includes(C) ? D.push(new ve(C, S[C], `In "${b}": "${C}" is only valid when "encoding" is set to "custom". ${H} encoding found`)) : A[C] ? D = D.concat(_.validateSpec({ key: C, value: S[C], valueSpec: A[C], validateSpec: _.validateSpec, style: k, styleSpec: I })) : D.push(new ve(C, S[C], `unknown property "${C}"`));
                                return D;
                            }({ sourceName: r, value: t, style: a.style, styleSpec: n, validateSpec: p }), m;
                        case "geojson":
                            if (m = ji({ key: r, value: t, valueSpec: n.source_geojson, style: l, styleSpec: n, validateSpec: p, objectElementValidators: Ga }), t.cluster) for (const _ in t.clusterProperties) {
                                const [v, b] = t.clusterProperties[_], S = typeof v == "string" ? [v, ["accumulated"], ["get", _]] : v;
                                m.push(...yr({ key: `${r}.${_}.map`, value: b, expressionContext: "cluster-map" })), m.push(...yr({ key: `${r}.${_}.reduce`, value: S, expressionContext: "cluster-reduce" }));
                            }
                            return m;
                        case "video":
                            return ji({ key: r, value: t, valueSpec: n.source_video, style: l, validateSpec: p, styleSpec: n });
                        case "image":
                            return ji({ key: r, value: t, valueSpec: n.source_image, style: l, validateSpec: p, styleSpec: n });
                        case "canvas":
                            return [new ve(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
                        default:
                            return jn({ key: `${r}.type`, value: t.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
                    }
                }
                function mc(a) {
                    const t = a.value, r = a.styleSpec, n = r.light, l = a.style;
                    let p = [];
                    const d = it(t);
                    if (t === void 0) return p;
                    if (d !== "object") return p = p.concat([new ve("light", t, `object expected, ${d} found`)]), p;
                    for (const m in t) {
                        const _ = m.match(/^(.*)-transition$/);
                        p = p.concat(_ && n[_[1]] && n[_[1]].transition ? a.validateSpec({ key: m, value: t[m], valueSpec: r.transition, validateSpec: a.validateSpec, style: l, styleSpec: r }) : n[m] ? a.validateSpec({ key: m, value: t[m], valueSpec: n[m], validateSpec: a.validateSpec, style: l, styleSpec: r }) : [new ve(m, t[m], `unknown property "${m}"`)]);
                    }
                    return p;
                }
                function gc(a) {
                    const t = a.value, r = a.styleSpec, n = r.sky, l = a.style, p = it(t);
                    if (t === void 0) return [];
                    if (p !== "object") return [new ve("sky", t, `object expected, ${p} found`)];
                    let d = [];
                    for (const m in t) d = d.concat(n[m] ? a.validateSpec({ key: m, value: t[m], valueSpec: n[m], style: l, styleSpec: r }) : [new ve(m, t[m], `unknown property "${m}"`)]);
                    return d;
                }
                function qa(a) {
                    const t = a.value, r = a.styleSpec, n = r.terrain, l = a.style;
                    let p = [];
                    const d = it(t);
                    if (t === void 0) return p;
                    if (d !== "object") return p = p.concat([new ve("terrain", t, `object expected, ${d} found`)]), p;
                    for (const m in t) p = p.concat(n[m] ? a.validateSpec({ key: m, value: t[m], valueSpec: n[m], validateSpec: a.validateSpec, style: l, styleSpec: r }) : [new ve(m, t[m], `unknown property "${m}"`)]);
                    return p;
                }
                function qo(a) {
                    let t = [];
                    const r = a.value, n = a.key;
                    if (Array.isArray(r)) {
                        const l = [], p = [];
                        for (const d in r) r[d].id && l.includes(r[d].id) && t.push(new ve(n, r, `all the sprites' ids must be unique, but ${r[d].id} is duplicated`)), l.push(r[d].id), r[d].url && p.includes(r[d].url) && t.push(new ve(n, r, `all the sprites' URLs must be unique, but ${r[d].url} is duplicated`)), p.push(r[d].url), t = t.concat(ji({ key: `${n}[${d}]`, value: r[d], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: a.validateSpec }));
                        return t;
                    }
                    return Xt({ key: n, value: r });
                }
                function $s(a) {
                    return t = a.value, t && t.constructor === Object ? [] : [new ve(a.key, a.value, `object expected, ${it(a.value)} found`)];
                    var t;
                }
                const _c = {
                    "*": () => [], array: $o, boolean: function (a) {
                        const t = a.value, r = a.key, n = it(t);
                        return n !== "boolean" ? [new ve(r, t, `boolean expected, ${n} found`)] : [];
                    }, number: On, color: Vo, constants: Nn, enum: jn, filter: Zo, function: Uo, layer: Za, object: ji, source: Go, light: mc, sky: gc, terrain: qa, projection: function (a) {
                        const t = a.value, r = a.styleSpec, n = r.projection, l = a.style, p = it(t);
                        if (t === void 0) return [];
                        if (p !== "object") return [new ve("projection", t, `object expected, ${p} found`)];
                        let d = [];
                        for (const m in t) d = d.concat(n[m] ? a.validateSpec({ key: m, value: t[m], valueSpec: n[m], style: l, styleSpec: r }) : [new ve(m, t[m], `unknown property "${m}"`)]);
                        return d;
                    }, projectionDefinition: function (a) {
                        const t = a.key;
                        let r = a.value;
                        r = r instanceof String ? r.valueOf() : r;
                        const n = it(r);
                        return n !== "array" || function (l) {
                            return Array.isArray(l) && l.length === 3 && typeof l[0] == "string" && typeof l[1] == "string" && typeof l[2] == "number";
                        }(r) || function (l) {
                            return !!["interpolate", "step", "literal"].includes(l[0]);
                        }(r) ? ["array", "string"].includes(n) ? [] : [new ve(t, r, `projection expected, invalid type "${n}" found`)] : [new ve(t, r, `projection expected, invalid array ${JSON.stringify(r)} found`)];
                    }, string: Xt, formatted: function (a) {
                        return Xt(a).length === 0 ? [] : yr(a);
                    }, resolvedImage: function (a) {
                        return Xt(a).length === 0 ? [] : yr(a);
                    }, padding: function (a) {
                        const t = a.key, r = a.value;
                        if (it(r) === "array") {
                            if (r.length < 1 || r.length > 4) return [new ve(t, r, `padding requires 1 to 4 values; ${r.length} values found`)];
                            const n = { type: "number" };
                            let l = [];
                            for (let p = 0; p < r.length; p++) l = l.concat(a.validateSpec({ key: `${t}[${p}]`, value: r[p], validateSpec: a.validateSpec, valueSpec: n }));
                            return l;
                        }
                        return On({ key: t, value: r, valueSpec: {} });
                    }, numberArray: function (a) {
                        const t = a.key, r = a.value;
                        if (it(r) === "array") {
                            const n = { type: "number" };
                            if (r.length < 1) return [new ve(t, r, "array length at least 1 expected, length 0 found")];
                            let l = [];
                            for (let p = 0; p < r.length; p++) l = l.concat(a.validateSpec({ key: `${t}[${p}]`, value: r[p], validateSpec: a.validateSpec, valueSpec: n }));
                            return l;
                        }
                        return On({ key: t, value: r, valueSpec: {} });
                    }, colorArray: function (a) {
                        const t = a.key, r = a.value;
                        if (it(r) === "array") {
                            if (r.length < 1) return [new ve(t, r, "array length at least 1 expected, length 0 found")];
                            let n = [];
                            for (let l = 0; l < r.length; l++) n = n.concat(Vo({ key: `${t}[${l}]`, value: r[l] }));
                            return n;
                        }
                        return Vo({ key: t, value: r });
                    }, variableAnchorOffsetCollection: function (a) {
                        const t = a.key, r = a.value, n = it(r), l = a.styleSpec;
                        if (n !== "array" || r.length < 1 || r.length % 2 != 0) return [new ve(t, r, "variableAnchorOffsetCollection requires a non-empty array of even length")];
                        let p = [];
                        for (let d = 0; d < r.length; d += 2) p = p.concat(jn({ key: `${t}[${d}]`, value: r[d], valueSpec: l.layout_symbol["text-anchor"] })), p = p.concat($o({ key: `${t}[${d + 1}]`, value: r[d + 1], valueSpec: { length: 2, value: "number" }, validateSpec: a.validateSpec, style: a.style, styleSpec: l }));
                        return p;
                    }, sprite: qo, state: $s
                };
                function Ha(a) {
                    const t = a.value, r = a.valueSpec, n = a.styleSpec;
                    return a.validateSpec = Ha, r.expression && Es(jt(t)) ? Uo(a) : r.expression && Rn(Vr(t)) ? yr(a) : r.type && _c[r.type] ? _c[r.type](a) : ji(gt({}, a, { valueSpec: r.type ? n[r.type] : r }));
                }
                function yc(a) {
                    const t = a.value, r = a.key, n = Xt(a);
                    return n.length || (t.indexOf("{fontstack}") === -1 && n.push(new ve(r, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && n.push(new ve(r, t, '"glyphs" url must include a "{range}" token'))), n;
                }
                function yi(a, t = O) {
                    let r = [];
                    return r = r.concat(Ha({ key: "", value: a, valueSpec: t.$root, styleSpec: t, style: a, validateSpec: Ha, objectElementValidators: { glyphs: yc, "*": () => [] } })), a.constants && (r = r.concat(Nn({ key: "constants", value: a.constants }))), Wa(r);
                }
                function tr(a) {
                    return function (t) {
                        return a({ ...t, validateSpec: Ha });
                    };
                }
                function Wa(a) {
                    return [].concat(a).sort((t, r) => t.line - r.line);
                }
                function ir(a) {
                    return function (...t) {
                        return Wa(a.apply(this, t));
                    };
                }
                yi.source = ir(tr(Go)), yi.sprite = ir(tr(qo)), yi.glyphs = ir(tr(yc)), yi.light = ir(tr(mc)), yi.sky = ir(tr(gc)), yi.terrain = ir(tr(qa)), yi.state = ir(tr($s)), yi.layer = ir(tr(Za)), yi.filter = ir(tr(Zo)), yi.paintProperty = ir(tr(fc)), yi.layoutProperty = ir(tr(Va));
                const Xa = yi, Us = Xa.light, xh = Xa.sky, Ho = Xa.paintProperty, Vs = Xa.layoutProperty;
                function Wo(a, t) {
                    let r = !1;
                    if (t && t.length) for (const n of t) a.fire(new W(new Error(n.message))), r = !0;
                    return r;
                }
                class Ka {
                    constructor(t, r, n) {
                        const l = this.cells = [];
                        if (t instanceof ArrayBuffer) {
                            this.arrayBuffer = t;
                            const d = new Int32Array(this.arrayBuffer);
                            t = d[0], this.d = (r = d[1]) + 2 * (n = d[2]);
                            for (let _ = 0; _ < this.d * this.d; _++) {
                                const v = d[3 + _], b = d[3 + _ + 1];
                                l.push(v === b ? null : d.subarray(v, b));
                            }
                            const m = d[3 + l.length + 1];
                            this.keys = d.subarray(d[3 + l.length], m), this.bboxes = d.subarray(m), this.insert = this._insertReadonly;
                        } else {
                            this.d = r + 2 * n;
                            for (let d = 0; d < this.d * this.d; d++) l.push([]);
                            this.keys = [], this.bboxes = [];
                        }
                        this.n = r, this.extent = t, this.padding = n, this.scale = r / t, this.uid = 0;
                        const p = n / r * t;
                        this.min = -p, this.max = t + p;
                    }
                    insert(t, r, n, l, p) {
                        this._forEachCell(r, n, l, p, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(l), this.bboxes.push(p);
                    }
                    _insertReadonly() {
                        throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
                    }
                    _insertCell(t, r, n, l, p, d) {
                        this.cells[p].push(d);
                    }
                    query(t, r, n, l, p) {
                        const d = this.min, m = this.max;
                        if (t <= d && r <= d && m <= n && m <= l && !p) return Array.prototype.slice.call(this.keys);
                        {
                            const _ = [];
                            return this._forEachCell(t, r, n, l, this._queryCell, _, {}, p), _;
                        }
                    }
                    _queryCell(t, r, n, l, p, d, m, _) {
                        const v = this.cells[p];
                        if (v !== null) {
                            const b = this.keys, S = this.bboxes;
                            for (let I = 0; I < v.length; I++) {
                                const A = v[I];
                                if (m[A] === void 0) {
                                    const k = 4 * A;
                                    (_ ? _(S[k + 0], S[k + 1], S[k + 2], S[k + 3]) : t <= S[k + 2] && r <= S[k + 3] && n >= S[k + 0] && l >= S[k + 1]) ? (m[A] = !0, d.push(b[A])) : m[A] = !1;
                                }
                            }
                        }
                    }
                    _forEachCell(t, r, n, l, p, d, m, _) {
                        const v = this._convertToCellCoord(t), b = this._convertToCellCoord(r), S = this._convertToCellCoord(n), I = this._convertToCellCoord(l);
                        for (let A = v; A <= S; A++) for (let k = b; k <= I; k++) {
                            const D = this.d * k + A;
                            if ((!_ || _(this._convertFromCellCoord(A), this._convertFromCellCoord(k), this._convertFromCellCoord(A + 1), this._convertFromCellCoord(k + 1))) && p.call(this, t, r, n, l, D, d, m, _)) return;
                        }
                    }
                    _convertFromCellCoord(t) {
                        return (t - this.padding) / this.scale;
                    }
                    _convertToCellCoord(t) {
                        return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
                    }
                    toArrayBuffer() {
                        if (this.arrayBuffer) return this.arrayBuffer;
                        const t = this.cells, r = 3 + this.cells.length + 1 + 1;
                        let n = 0;
                        for (let d = 0; d < this.cells.length; d++) n += this.cells[d].length;
                        const l = new Int32Array(r + n + this.keys.length + this.bboxes.length);
                        l[0] = this.extent, l[1] = this.n, l[2] = this.padding;
                        let p = r;
                        for (let d = 0; d < t.length; d++) {
                            const m = t[d];
                            l[3 + d] = p, l.set(m, p), p += m.length;
                        }
                        return l[3 + t.length] = p, l.set(this.keys, p), p += this.keys.length, l[3 + t.length + 1] = p, l.set(this.bboxes, p), p += this.bboxes.length, l.buffer;
                    }
                    static serialize(t, r) {
                        const n = t.toArrayBuffer();
                        return r && r.push(n), { buffer: n };
                    }
                    static deserialize(t) {
                        return new Ka(t.buffer);
                    }
                }
                const vr = {};
                function Le(a, t, r = {}) {
                    if (vr[a]) throw new Error(`${a} is already registered.`);
                    Object.defineProperty(t, "_classRegistryKey", { value: a, writeable: !1 }), vr[a] = { klass: t, omit: r.omit || [], shallow: r.shallow || [] };
                }
                Le("Object", Object), Le("TransferableGridIndex", Ka), Le("Color", st), Le("Error", Error), Le("AJAXError", qi), Le("ResolvedImage", Oi), Le("StylePropertyFunction", Dn), Le("StyleExpression", Ds, { omit: ["_evaluator"] }), Le("ZoomDependentExpression", Bs), Le("ZoomConstantExpression", Fo), Le("CompoundExpression", Wi, { omit: ["_evaluate"] });
                for (const a in ja) ja[a]._classRegistryKey || Le(`Expression_${a}`, ja[a]);
                function Zs(a) {
                    return a && typeof ArrayBuffer < "u" && (a instanceof ArrayBuffer || a.constructor && a.constructor.name === "ArrayBuffer");
                }
                function Gs(a) {
                    return a.$name || a.constructor._classRegistryKey;
                }
                function vc(a) {
                    return !function (t) {
                        if (t === null || typeof t != "object") return !1;
                        const r = Gs(t);
                        return !(!r || r === "Object");
                    }(a) && (a == null || typeof a == "boolean" || typeof a == "number" || typeof a == "string" || a instanceof Boolean || a instanceof Number || a instanceof String || a instanceof Date || a instanceof RegExp || a instanceof Blob || a instanceof Error || Zs(a) || Gi(a) || ArrayBuffer.isView(a) || a instanceof ImageData);
                }
                function Ya(a, t) {
                    if (vc(a)) return (Zs(a) || Gi(a)) && t && t.push(a), ArrayBuffer.isView(a) && t && t.push(a.buffer), a instanceof ImageData && t && t.push(a.data.buffer), a;
                    if (Array.isArray(a)) {
                        const p = [];
                        for (const d of a) p.push(Ya(d, t));
                        return p;
                    }
                    if (typeof a != "object") throw new Error("can't serialize object of type " + typeof a);
                    const r = Gs(a);
                    if (!r) throw new Error(`can't serialize object of unregistered class ${a.constructor.name}`);
                    if (!vr[r]) throw new Error(`${r} is not registered.`);
                    const { klass: n } = vr[r], l = n.serialize ? n.serialize(a, t) : {};
                    if (n.serialize) {
                        if (t && l === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
                    } else {
                        for (const p in a) {
                            if (!a.hasOwnProperty(p) || vr[r].omit.indexOf(p) >= 0) continue;
                            const d = a[p];
                            l[p] = vr[r].shallow.indexOf(p) >= 0 ? d : Ya(d, t);
                        }
                        a instanceof Error && (l.message = a.message);
                    }
                    if (l.$name) throw new Error("$name property is reserved for worker serialization logic.");
                    return r !== "Object" && (l.$name = r), l;
                }
                function $n(a) {
                    if (vc(a)) return a;
                    if (Array.isArray(a)) return a.map($n);
                    if (typeof a != "object") throw new Error("can't deserialize object of type " + typeof a);
                    const t = Gs(a) || "Object";
                    if (!vr[t]) throw new Error(`can't deserialize unregistered class ${t}`);
                    const { klass: r } = vr[t];
                    if (!r) throw new Error(`can't deserialize unregistered class ${t}`);
                    if (r.deserialize) return r.deserialize(a);
                    const n = Object.create(r.prototype);
                    for (const l of Object.keys(a)) {
                        if (l === "$name") continue;
                        const p = a[l];
                        n[l] = vr[t].shallow.indexOf(l) >= 0 ? p : $n(p);
                    }
                    return n;
                }
                class Xo {
                    constructor() {
                        this.first = !0;
                    }
                    update(t, r) {
                        const n = Math.floor(t);
                        return this.first ? (this.first = !1, this.lastIntegerZoom = n, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = n, !0) : (this.lastFloorZoom > n ? (this.lastIntegerZoom = n + 1, this.lastIntegerZoomTime = r) : this.lastFloorZoom < n && (this.lastIntegerZoom = n, this.lastIntegerZoomTime = r), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = n, !0));
                    }
                }
                const rt = { "Latin-1 Supplement": (a) => a >= 128 && a <= 255, "Hangul Jamo": (a) => a >= 4352 && a <= 4607, Khmer: (a) => a >= 6016 && a <= 6143, "General Punctuation": (a) => a >= 8192 && a <= 8303, "Letterlike Symbols": (a) => a >= 8448 && a <= 8527, "Number Forms": (a) => a >= 8528 && a <= 8591, "Miscellaneous Technical": (a) => a >= 8960 && a <= 9215, "Control Pictures": (a) => a >= 9216 && a <= 9279, "Optical Character Recognition": (a) => a >= 9280 && a <= 9311, "Enclosed Alphanumerics": (a) => a >= 9312 && a <= 9471, "Geometric Shapes": (a) => a >= 9632 && a <= 9727, "Miscellaneous Symbols": (a) => a >= 9728 && a <= 9983, "Miscellaneous Symbols and Arrows": (a) => a >= 11008 && a <= 11263, "Ideographic Description Characters": (a) => a >= 12272 && a <= 12287, "CJK Symbols and Punctuation": (a) => a >= 12288 && a <= 12351, Hiragana: (a) => a >= 12352 && a <= 12447, Katakana: (a) => a >= 12448 && a <= 12543, Kanbun: (a) => a >= 12688 && a <= 12703, "CJK Strokes": (a) => a >= 12736 && a <= 12783, "Enclosed CJK Letters and Months": (a) => a >= 12800 && a <= 13055, "CJK Compatibility": (a) => a >= 13056 && a <= 13311, "Yijing Hexagram Symbols": (a) => a >= 19904 && a <= 19967, "CJK Unified Ideographs": (a) => a >= 19968 && a <= 40959, "Hangul Syllables": (a) => a >= 44032 && a <= 55215, "Private Use Area": (a) => a >= 57344 && a <= 63743, "Vertical Forms": (a) => a >= 65040 && a <= 65055, "CJK Compatibility Forms": (a) => a >= 65072 && a <= 65103, "Small Form Variants": (a) => a >= 65104 && a <= 65135, "Halfwidth and Fullwidth Forms": (a) => a >= 65280 && a <= 65519 };
                function qs(a) {
                    for (const t of a) if (Hs(t.charCodeAt(0))) return !0;
                    return !1;
                }
                function bh(a) {
                    for (const t of a) if (!bc(t.charCodeAt(0))) return !1;
                    return !0;
                }
                function Ko(a) {
                    const t = a.map((r) => {
                        try {
                            return new RegExp(`\\p{sc=${r}}`, "u").source;
                        } catch {
                            return null;
                        }
                    }).filter((r) => r);
                    return new RegExp(t.join("|"), "u");
                }
                const xc = Ko(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
                function bc(a) {
                    return !xc.test(String.fromCodePoint(a));
                }
                const Yo = Ko(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
                function Hs(a) {
                    return !(a !== 746 && a !== 747 && (a < 4352 || !(rt["CJK Compatibility Forms"](a) && !(a >= 65097 && a <= 65103) || rt["CJK Compatibility"](a) || rt["CJK Strokes"](a) || !(!rt["CJK Symbols and Punctuation"](a) || a >= 12296 && a <= 12305 || a >= 12308 && a <= 12319 || a === 12336) || rt["Enclosed CJK Letters and Months"](a) || rt["Ideographic Description Characters"](a) || rt.Kanbun(a) || rt.Katakana(a) && a !== 12540 || !(!rt["Halfwidth and Fullwidth Forms"](a) || a === 65288 || a === 65289 || a === 65293 || a >= 65306 && a <= 65310 || a === 65339 || a === 65341 || a === 65343 || a >= 65371 && a <= 65503 || a === 65507 || a >= 65512 && a <= 65519) || !(!rt["Small Form Variants"](a) || a >= 65112 && a <= 65118 || a >= 65123 && a <= 65126) || rt["Vertical Forms"](a) || rt["Yijing Hexagram Symbols"](a) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(a)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(a)) || Yo.test(String.fromCodePoint(a)))));
                }
                function Un(a) {
                    return !(Hs(a) || function (t) {
                        return !!(rt["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || rt["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || rt["Letterlike Symbols"](t) || rt["Number Forms"](t) || rt["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || rt["Control Pictures"](t) && t !== 9251 || rt["Optical Character Recognition"](t) || rt["Enclosed Alphanumerics"](t) || rt["Geometric Shapes"](t) || rt["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || rt["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || rt["CJK Symbols and Punctuation"](t) || rt.Katakana(t) || rt["Private Use Area"](t) || rt["CJK Compatibility Forms"](t) || rt["Small Form Variants"](t) || rt["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533);
                    }(a));
                }
                const wh = Ko(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
                function Ws(a) {
                    return wh.test(String.fromCodePoint(a));
                }
                function Sh(a, t) {
                    return !(!t && Ws(a) || a >= 2304 && a <= 3583 || a >= 3840 && a <= 4255 || rt.Khmer(a));
                }
                function Th(a) {
                    for (const t of a) if (Ws(t.charCodeAt(0))) return !0;
                    return !1;
                }
                const Ar = new class {
                    constructor() {
                        this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
                        };
                    }
                    setState(a) {
                        this.pluginStatus = a.pluginStatus, this.pluginURL = a.pluginURL;
                    }
                    getState() {
                        return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
                    }
                    setMethods(a) {
                        if (Ar.isParsed()) throw new Error("RTL text plugin already registered.");
                        this.applyArabicShaping = a.applyArabicShaping, this.processBidirectionalText = a.processBidirectionalText, this.processStyledBidirectionalText = a.processStyledBidirectionalText, this.loadScriptResolve();
                    }
                    isParsed() {
                        return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
                    }
                    getRTLTextPluginStatus() {
                        return this.pluginStatus;
                    }
                    syncState(a, t) {
                        return c(this, void 0, void 0, function* () {
                            if (this.isParsed()) return this.getState();
                            if (a.pluginStatus !== "loading") return this.setState(a), a;
                            const r = a.pluginURL, n = new Promise((p) => {
                                this.loadScriptResolve = p;
                            });
                            t(r);
                            const l = new Promise((p) => setTimeout(() => p(), this.TIMEOUT));
                            if (yield Promise.race([n, l]), this.isParsed()) {
                                const p = { pluginStatus: "loaded", pluginURL: r };
                                return this.setState(p), p;
                            }
                            throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${r}`);
                        });
                    }
                }();
                class Tt {
                    constructor(t, r) {
                        this.zoom = t, r ? (this.now = r.now, this.fadeDuration = r.fadeDuration, this.zoomHistory = r.zoomHistory, this.transition = r.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Xo(), this.transition = {});
                    }
                    isSupportedScript(t) {
                        return function (r, n) {
                            for (const l of r) if (!Sh(l.charCodeAt(0), n)) return !1;
                            return !0;
                        }(t, Ar.getRTLTextPluginStatus() === "loaded");
                    }
                    crossFadingFactor() {
                        return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
                    }
                    getCrossfadeParameters() {
                        const t = this.zoom, r = t - Math.floor(t), n = this.crossFadingFactor();
                        return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: r + (1 - r) * n } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - n) * r };
                    }
                }
                class Vn {
                    constructor(t, r) {
                        this.property = t, this.value = r, this.expression = function (n, l) {
                            if (Es(n)) return new Dn(n, l);
                            if (Rn(n)) {
                                const p = No(n, l);
                                if (p.result === "error") throw new Error(p.value.map((d) => `${d.key}: ${d.message}`).join(", "));
                                return p.value;
                            }
                            {
                                let p = n;
                                return l.type === "color" && typeof n == "string" ? p = st.parse(n) : l.type !== "padding" || typeof n != "number" && !Array.isArray(n) ? l.type !== "numberArray" || typeof n != "number" && !Array.isArray(n) ? l.type !== "colorArray" || typeof n != "string" && !Array.isArray(n) ? l.type === "variableAnchorOffsetCollection" && Array.isArray(n) ? p = Pi.parse(n) : l.type === "projectionDefinition" && typeof n == "string" && (p = Ei.parse(n)) : p = hi.parse(n) : p = Ut.parse(n) : p = ci.parse(n), { kind: "constant", evaluate: () => p };
                            }
                        }(r === void 0 ? t.specification.default : r, t.specification);
                    }
                    isDataDriven() {
                        return this.expression.kind === "source" || this.expression.kind === "composite";
                    }
                    possiblyEvaluate(t, r, n) {
                        return this.property.possiblyEvaluate(this, t, r, n);
                    }
                }
                class Jo {
                    constructor(t) {
                        this.property = t, this.value = new Vn(t, void 0);
                    }
                    transitioned(t, r) {
                        return new Sc(this.property, this.value, r, Di({}, t.transition, this.transition), t.now);
                    }
                    untransitioned() {
                        return new Sc(this.property, this.value, null, {}, 0);
                    }
                }
                class wc {
                    constructor(t) {
                        this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);
                    }
                    getValue(t) {
                        return Li(this._values[t].value.value);
                    }
                    setValue(t, r) {
                        Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Jo(this._values[t].property)), this._values[t].value = new Vn(this._values[t].property, r === null ? void 0 : Li(r));
                    }
                    getTransition(t) {
                        return Li(this._values[t].transition);
                    }
                    setTransition(t, r) {
                        Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Jo(this._values[t].property)), this._values[t].transition = Li(r) || void 0;
                    }
                    serialize() {
                        const t = {};
                        for (const r of Object.keys(this._values)) {
                            const n = this.getValue(r);
                            n !== void 0 && (t[r] = n);
                            const l = this.getTransition(r);
                            l !== void 0 && (t[`${r}-transition`] = l);
                        }
                        return t;
                    }
                    transitioned(t, r) {
                        const n = new Tc(this._properties);
                        for (const l of Object.keys(this._values)) n._values[l] = this._values[l].transitioned(t, r._values[l]);
                        return n;
                    }
                    untransitioned() {
                        const t = new Tc(this._properties);
                        for (const r of Object.keys(this._values)) t._values[r] = this._values[r].untransitioned();
                        return t;
                    }
                }
                class Sc {
                    constructor(t, r, n, l, p) {
                        this.property = t, this.value = r, this.begin = p + l.delay || 0, this.end = this.begin + l.duration || 0, t.specification.transition && (l.delay || l.duration) && (this.prior = n);
                    }
                    possiblyEvaluate(t, r, n) {
                        const l = t.now || 0, p = this.value.possiblyEvaluate(t, r, n), d = this.prior;
                        if (d) {
                            if (l > this.end) return this.prior = null, p;
                            if (this.value.isDataDriven()) return this.prior = null, p;
                            if (l < this.begin) return d.possiblyEvaluate(t, r, n);
                            {
                                const m = (l - this.begin) / (this.end - this.begin);
                                return this.property.interpolate(d.possiblyEvaluate(t, r, n), p, Qi(m));
                            }
                        }
                        return p;
                    }
                }
                class Tc {
                    constructor(t) {
                        this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
                    }
                    possiblyEvaluate(t, r, n) {
                        const l = new Xs(this._properties);
                        for (const p of Object.keys(this._values)) l._values[p] = this._values[p].possiblyEvaluate(t, r, n);
                        return l;
                    }
                    hasTransition() {
                        for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;
                        return !1;
                    }
                }
                class Ph {
                    constructor(t) {
                        this._properties = t, this._values = Object.create(t.defaultPropertyValues);
                    }
                    hasValue(t) {
                        return this._values[t].value !== void 0;
                    }
                    getValue(t) {
                        return Li(this._values[t].value);
                    }
                    setValue(t, r) {
                        this._values[t] = new Vn(this._values[t].property, r === null ? void 0 : Li(r));
                    }
                    serialize() {
                        const t = {};
                        for (const r of Object.keys(this._values)) {
                            const n = this.getValue(r);
                            n !== void 0 && (t[r] = n);
                        }
                        return t;
                    }
                    possiblyEvaluate(t, r, n) {
                        const l = new Xs(this._properties);
                        for (const p of Object.keys(this._values)) l._values[p] = this._values[p].possiblyEvaluate(t, r, n);
                        return l;
                    }
                }
                class Mi {
                    constructor(t, r, n) {
                        this.property = t, this.value = r, this.parameters = n;
                    }
                    isConstant() {
                        return this.value.kind === "constant";
                    }
                    constantOr(t) {
                        return this.value.kind === "constant" ? this.value.value : t;
                    }
                    evaluate(t, r, n, l) {
                        return this.property.evaluate(this.value, this.parameters, t, r, n, l);
                    }
                }
                class Xs {
                    constructor(t) {
                        this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
                    }
                    get(t) {
                        return this._values[t];
                    }
                }
                class je {
                    constructor(t) {
                        this.specification = t;
                    }
                    possiblyEvaluate(t, r) {
                        if (t.isDataDriven()) throw new Error("Value should not be data driven");
                        return t.expression.evaluate(r);
                    }
                    interpolate(t, r, n) {
                        const l = gr[this.specification.type];
                        return l ? l(t, r, n) : t;
                    }
                }
                class He {
                    constructor(t, r) {
                        this.specification = t, this.overrides = r;
                    }
                    possiblyEvaluate(t, r, n, l) {
                        return new Mi(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? { kind: "constant", value: t.expression.evaluate(r, null, {}, n, l) } : t.expression, r);
                    }
                    interpolate(t, r, n) {
                        if (t.value.kind !== "constant" || r.value.kind !== "constant") return t;
                        if (t.value.value === void 0 || r.value.value === void 0) return new Mi(this, { kind: "constant", value: void 0 }, t.parameters);
                        const l = gr[this.specification.type];
                        if (l) {
                            const p = l(t.value.value, r.value.value, n);
                            return new Mi(this, { kind: "constant", value: p }, t.parameters);
                        }
                        return t;
                    }
                    evaluate(t, r, n, l, p, d) {
                        return t.kind === "constant" ? t.value : t.evaluate(r, n, l, p, d);
                    }
                }
                class Zn extends He {
                    possiblyEvaluate(t, r, n, l) {
                        if (t.value === void 0) return new Mi(this, { kind: "constant", value: void 0 }, r);
                        if (t.expression.kind === "constant") {
                            const p = t.expression.evaluate(r, null, {}, n, l), d = t.property.specification.type === "resolvedImage" && typeof p != "string" ? p.name : p, m = this._calculate(d, d, d, r);
                            return new Mi(this, { kind: "constant", value: m }, r);
                        }
                        if (t.expression.kind === "camera") {
                            const p = this._calculate(t.expression.evaluate({ zoom: r.zoom - 1 }), t.expression.evaluate({ zoom: r.zoom }), t.expression.evaluate({ zoom: r.zoom + 1 }), r);
                            return new Mi(this, { kind: "constant", value: p }, r);
                        }
                        return new Mi(this, t.expression, r);
                    }
                    evaluate(t, r, n, l, p, d) {
                        if (t.kind === "source") {
                            const m = t.evaluate(r, n, l, p, d);
                            return this._calculate(m, m, m, r);
                        }
                        return t.kind === "composite" ? this._calculate(t.evaluate({ zoom: Math.floor(r.zoom) - 1 }, n, l), t.evaluate({ zoom: Math.floor(r.zoom) }, n, l), t.evaluate({ zoom: Math.floor(r.zoom) + 1 }, n, l), r) : t.value;
                    }
                    _calculate(t, r, n, l) {
                        return l.zoom > l.zoomHistory.lastIntegerZoom ? { from: t, to: r } : { from: n, to: r };
                    }
                    interpolate(t) {
                        return t;
                    }
                }
                class Qo {
                    constructor(t) {
                        this.specification = t;
                    }
                    possiblyEvaluate(t, r, n, l) {
                        if (t.value !== void 0) {
                            if (t.expression.kind === "constant") {
                                const p = t.expression.evaluate(r, null, {}, n, l);
                                return this._calculate(p, p, p, r);
                            }
                            return this._calculate(t.expression.evaluate(new Tt(Math.floor(r.zoom - 1), r)), t.expression.evaluate(new Tt(Math.floor(r.zoom), r)), t.expression.evaluate(new Tt(Math.floor(r.zoom + 1), r)), r);
                        }
                    }
                    _calculate(t, r, n, l) {
                        return l.zoom > l.zoomHistory.lastIntegerZoom ? { from: t, to: r } : { from: n, to: r };
                    }
                    interpolate(t) {
                        return t;
                    }
                }
                class el {
                    constructor(t) {
                        this.specification = t;
                    }
                    possiblyEvaluate(t, r, n, l) {
                        return !!t.expression.evaluate(r, null, {}, n, l);
                    }
                    interpolate() {
                        return !1;
                    }
                }
                class Gt {
                    constructor(t) {
                        this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
                        for (const r in t) {
                            const n = t[r];
                            n.specification.overridable && this.overridableProperties.push(r);
                            const l = this.defaultPropertyValues[r] = new Vn(n, void 0), p = this.defaultTransitionablePropertyValues[r] = new Jo(n);
                            this.defaultTransitioningPropertyValues[r] = p.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = l.possiblyEvaluate({});
                        }
                    }
                }
                Le("DataDrivenProperty", He), Le("DataConstantProperty", je), Le("CrossFadedDataDrivenProperty", Zn), Le("CrossFadedProperty", Qo), Le("ColorRampProperty", el);
                const tl = "-transition";
                class Xi extends re {
                    constructor(t, r) {
                        if (super(), this.id = t.id, this.type = t.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter), r.layout && (this._unevaluatedLayout = new Ph(r.layout)), r.paint)) {
                            this._transitionablePaint = new wc(r.paint);
                            for (const n in t.paint) this.setPaintProperty(n, t.paint[n], { validate: !1 });
                            for (const n in t.layout) this.setLayoutProperty(n, t.layout[n], { validate: !1 });
                            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Xs(r.paint);
                        }
                    }
                    getCrossfadeParameters() {
                        return this._crossfadeParameters;
                    }
                    getLayoutProperty(t) {
                        return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t);
                    }
                    setLayoutProperty(t, r, n = {}) {
                        r != null && this._validate(Vs, `layers.${this.id}.layout.${t}`, t, r, n) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, r) : this.visibility = r);
                    }
                    getPaintProperty(t) {
                        return t.endsWith(tl) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);
                    }
                    setPaintProperty(t, r, n = {}) {
                        if (r != null && this._validate(Ho, `layers.${this.id}.paint.${t}`, t, r, n)) return !1;
                        if (t.endsWith(tl)) return this._transitionablePaint.setTransition(t.slice(0, -11), r || void 0), !1;
                        {
                            const l = this._transitionablePaint._values[t], p = l.property.specification["property-type"] === "cross-faded-data-driven", d = l.value.isDataDriven(), m = l.value;
                            this._transitionablePaint.setValue(t, r), this._handleSpecialPaintPropertyUpdate(t);
                            const _ = this._transitionablePaint._values[t].value;
                            return _.isDataDriven() || d || p || this._handleOverridablePaintPropertyUpdate(t, m, _);
                        }
                    }
                    _handleSpecialPaintPropertyUpdate(t) {
                    }
                    _handleOverridablePaintPropertyUpdate(t, r, n) {
                        return !1;
                    }
                    isHidden(t) {
                        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none";
                    }
                    updateTransitions(t) {
                        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
                    }
                    hasTransition() {
                        return this._transitioningPaint.hasTransition();
                    }
                    recalculate(t, r) {
                        t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, r)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, r);
                    }
                    serialize() {
                        const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
                        return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), un(t, (r, n) => !(r === void 0 || n === "layout" && !Object.keys(r).length || n === "paint" && !Object.keys(r).length));
                    }
                    _validate(t, r, n, l, p = {}) {
                        return (!p || p.validate !== !1) && Wo(this, t.call(Xa, { key: r, layerType: this.type, objectKey: n, value: l, styleSpec: O, style: { glyphs: !0, sprite: !0 } }));
                    }
                    is3D() {
                        return !1;
                    }
                    isTileClipped() {
                        return !1;
                    }
                    hasOffscreenPass() {
                        return !1;
                    }
                    resize() {
                    }
                    isStateDependent() {
                        for (const t in this.paint._values) {
                            const r = this.paint.get(t);
                            if (r instanceof Mi && Ua(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent) return !0;
                        }
                        return !1;
                    }
                }
                const Pc = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
                class _a {
                    constructor(t, r) {
                        this._structArray = t, this._pos1 = r * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
                    }
                }
                class Nt {
                    constructor() {
                        this.isTransferred = !1, this.capacity = -1, this.resize(0);
                    }
                    static serialize(t, r) {
                        return t._trim(), r && (t.isTransferred = !0, r.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
                    }
                    static deserialize(t) {
                        const r = Object.create(this.prototype);
                        return r.arrayBuffer = t.arrayBuffer, r.length = t.length, r.capacity = t.arrayBuffer.byteLength / r.bytesPerElement, r._refreshViews(), r;
                    }
                    _trim() {
                        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
                    }
                    clear() {
                        this.length = 0;
                    }
                    resize(t) {
                        this.reserve(t), this.length = t;
                    }
                    reserve(t) {
                        if (t > this.capacity) {
                            this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                            const r = this.uint8;
                            this._refreshViews(), r && this.uint8.set(r);
                        }
                    }
                    _refreshViews() {
                        throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
                    }
                }
                function Ct(a, t = 1) {
                    let r = 0, n = 0;
                    return {
                        members: a.map((l) => {
                            const p = Pc[l.type].BYTES_PER_ELEMENT, d = r = Ja(r, Math.max(t, p)), m = l.components || 1;
                            return n = Math.max(n, p), r += p * m, { name: l.name, type: l.type, components: m, offset: d };
                        }), size: Ja(r, Math.max(n, t)), alignment: t
                    };
                }
                function Ja(a, t) {
                    return Math.ceil(a / t) * t;
                }
                class Gn extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r) {
                        const n = this.length;
                        return this.resize(n + 1), this.emplace(n, t, r);
                    }
                    emplace(t, r, n) {
                        const l = 2 * t;
                        return this.int16[l + 0] = r, this.int16[l + 1] = n, t;
                    }
                }
                Gn.prototype.bytesPerElement = 4, Le("StructArrayLayout2i4", Gn);
                class qn extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n) {
                        const l = this.length;
                        return this.resize(l + 1), this.emplace(l, t, r, n);
                    }
                    emplace(t, r, n, l) {
                        const p = 3 * t;
                        return this.int16[p + 0] = r, this.int16[p + 1] = n, this.int16[p + 2] = l, t;
                    }
                }
                qn.prototype.bytesPerElement = 6, Le("StructArrayLayout3i6", qn);
                class ya extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n, l) {
                        const p = this.length;
                        return this.resize(p + 1), this.emplace(p, t, r, n, l);
                    }
                    emplace(t, r, n, l, p) {
                        const d = 4 * t;
                        return this.int16[d + 0] = r, this.int16[d + 1] = n, this.int16[d + 2] = l, this.int16[d + 3] = p, t;
                    }
                }
                ya.prototype.bytesPerElement = 8, Le("StructArrayLayout4i8", ya);
                class il extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n, l, p, d) {
                        const m = this.length;
                        return this.resize(m + 1), this.emplace(m, t, r, n, l, p, d);
                    }
                    emplace(t, r, n, l, p, d, m) {
                        const _ = 6 * t;
                        return this.int16[_ + 0] = r, this.int16[_ + 1] = n, this.int16[_ + 2] = l, this.int16[_ + 3] = p, this.int16[_ + 4] = d, this.int16[_ + 5] = m, t;
                    }
                }
                il.prototype.bytesPerElement = 12, Le("StructArrayLayout2i4i12", il);
                class rl extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n, l, p, d) {
                        const m = this.length;
                        return this.resize(m + 1), this.emplace(m, t, r, n, l, p, d);
                    }
                    emplace(t, r, n, l, p, d, m) {
                        const _ = 4 * t, v = 8 * t;
                        return this.int16[_ + 0] = r, this.int16[_ + 1] = n, this.uint8[v + 4] = l, this.uint8[v + 5] = p, this.uint8[v + 6] = d, this.uint8[v + 7] = m, t;
                    }
                }
                rl.prototype.bytesPerElement = 8, Le("StructArrayLayout2i4ub8", rl);
                class Qa extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r) {
                        const n = this.length;
                        return this.resize(n + 1), this.emplace(n, t, r);
                    }
                    emplace(t, r, n) {
                        const l = 2 * t;
                        return this.float32[l + 0] = r, this.float32[l + 1] = n, t;
                    }
                }
                Qa.prototype.bytesPerElement = 8, Le("StructArrayLayout2f8", Qa);
                class al extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n, l, p, d, m, _, v, b) {
                        const S = this.length;
                        return this.resize(S + 1), this.emplace(S, t, r, n, l, p, d, m, _, v, b);
                    }
                    emplace(t, r, n, l, p, d, m, _, v, b, S) {
                        const I = 10 * t;
                        return this.uint16[I + 0] = r, this.uint16[I + 1] = n, this.uint16[I + 2] = l, this.uint16[I + 3] = p, this.uint16[I + 4] = d, this.uint16[I + 5] = m, this.uint16[I + 6] = _, this.uint16[I + 7] = v, this.uint16[I + 8] = b, this.uint16[I + 9] = S, t;
                    }
                }
                al.prototype.bytesPerElement = 20, Le("StructArrayLayout10ui20", al);
                class h extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n, l, p, d, m, _, v, b, S, I) {
                        const A = this.length;
                        return this.resize(A + 1), this.emplace(A, t, r, n, l, p, d, m, _, v, b, S, I);
                    }
                    emplace(t, r, n, l, p, d, m, _, v, b, S, I, A) {
                        const k = 12 * t;
                        return this.int16[k + 0] = r, this.int16[k + 1] = n, this.int16[k + 2] = l, this.int16[k + 3] = p, this.uint16[k + 4] = d, this.uint16[k + 5] = m, this.uint16[k + 6] = _, this.uint16[k + 7] = v, this.int16[k + 8] = b, this.int16[k + 9] = S, this.int16[k + 10] = I, this.int16[k + 11] = A, t;
                    }
                }
                h.prototype.bytesPerElement = 24, Le("StructArrayLayout4i4ui4i24", h);
                class e extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n) {
                        const l = this.length;
                        return this.resize(l + 1), this.emplace(l, t, r, n);
                    }
                    emplace(t, r, n, l) {
                        const p = 3 * t;
                        return this.float32[p + 0] = r, this.float32[p + 1] = n, this.float32[p + 2] = l, t;
                    }
                }
                e.prototype.bytesPerElement = 12, Le("StructArrayLayout3f12", e);
                class i extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
                    }
                    emplaceBack(t) {
                        const r = this.length;
                        return this.resize(r + 1), this.emplace(r, t);
                    }
                    emplace(t, r) {
                        return this.uint32[1 * t + 0] = r, t;
                    }
                }
                i.prototype.bytesPerElement = 4, Le("StructArrayLayout1ul4", i);
                class s extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n, l, p, d, m, _, v) {
                        const b = this.length;
                        return this.resize(b + 1), this.emplace(b, t, r, n, l, p, d, m, _, v);
                    }
                    emplace(t, r, n, l, p, d, m, _, v, b) {
                        const S = 10 * t, I = 5 * t;
                        return this.int16[S + 0] = r, this.int16[S + 1] = n, this.int16[S + 2] = l, this.int16[S + 3] = p, this.int16[S + 4] = d, this.int16[S + 5] = m, this.uint32[I + 3] = _, this.uint16[S + 8] = v, this.uint16[S + 9] = b, t;
                    }
                }
                s.prototype.bytesPerElement = 20, Le("StructArrayLayout6i1ul2ui20", s);
                class o extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n, l, p, d) {
                        const m = this.length;
                        return this.resize(m + 1), this.emplace(m, t, r, n, l, p, d);
                    }
                    emplace(t, r, n, l, p, d, m) {
                        const _ = 6 * t;
                        return this.int16[_ + 0] = r, this.int16[_ + 1] = n, this.int16[_ + 2] = l, this.int16[_ + 3] = p, this.int16[_ + 4] = d, this.int16[_ + 5] = m, t;
                    }
                }
                o.prototype.bytesPerElement = 12, Le("StructArrayLayout2i2i2i12", o);
                class u extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n, l, p) {
                        const d = this.length;
                        return this.resize(d + 1), this.emplace(d, t, r, n, l, p);
                    }
                    emplace(t, r, n, l, p, d) {
                        const m = 4 * t, _ = 8 * t;
                        return this.float32[m + 0] = r, this.float32[m + 1] = n, this.float32[m + 2] = l, this.int16[_ + 6] = p, this.int16[_ + 7] = d, t;
                    }
                }
                u.prototype.bytesPerElement = 16, Le("StructArrayLayout2f1f2i16", u);
                class f extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n, l, p, d) {
                        const m = this.length;
                        return this.resize(m + 1), this.emplace(m, t, r, n, l, p, d);
                    }
                    emplace(t, r, n, l, p, d, m) {
                        const _ = 16 * t, v = 4 * t, b = 8 * t;
                        return this.uint8[_ + 0] = r, this.uint8[_ + 1] = n, this.float32[v + 1] = l, this.float32[v + 2] = p, this.int16[b + 6] = d, this.int16[b + 7] = m, t;
                    }
                }
                f.prototype.bytesPerElement = 16, Le("StructArrayLayout2ub2f2i16", f);
                class g extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n) {
                        const l = this.length;
                        return this.resize(l + 1), this.emplace(l, t, r, n);
                    }
                    emplace(t, r, n, l) {
                        const p = 3 * t;
                        return this.uint16[p + 0] = r, this.uint16[p + 1] = n, this.uint16[p + 2] = l, t;
                    }
                }
                g.prototype.bytesPerElement = 6, Le("StructArrayLayout3ui6", g);
                class y extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n, l, p, d, m, _, v, b, S, I, A, k, D, N, G) {
                        const ie = this.length;
                        return this.resize(ie + 1), this.emplace(ie, t, r, n, l, p, d, m, _, v, b, S, I, A, k, D, N, G);
                    }
                    emplace(t, r, n, l, p, d, m, _, v, b, S, I, A, k, D, N, G, ie) {
                        const H = 24 * t, C = 12 * t, F = 48 * t;
                        return this.int16[H + 0] = r, this.int16[H + 1] = n, this.uint16[H + 2] = l, this.uint16[H + 3] = p, this.uint32[C + 2] = d, this.uint32[C + 3] = m, this.uint32[C + 4] = _, this.uint16[H + 10] = v, this.uint16[H + 11] = b, this.uint16[H + 12] = S, this.float32[C + 7] = I, this.float32[C + 8] = A, this.uint8[F + 36] = k, this.uint8[F + 37] = D, this.uint8[F + 38] = N, this.uint32[C + 10] = G, this.int16[H + 22] = ie, t;
                    }
                }
                y.prototype.bytesPerElement = 48, Le("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", y);
                class x extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n, l, p, d, m, _, v, b, S, I, A, k, D, N, G, ie, H, C, F, X, ue, Me, me, xe, Ae, Ie) {
                        const ke = this.length;
                        return this.resize(ke + 1), this.emplace(ke, t, r, n, l, p, d, m, _, v, b, S, I, A, k, D, N, G, ie, H, C, F, X, ue, Me, me, xe, Ae, Ie);
                    }
                    emplace(t, r, n, l, p, d, m, _, v, b, S, I, A, k, D, N, G, ie, H, C, F, X, ue, Me, me, xe, Ae, Ie, ke) {
                        const we = 32 * t, Be = 16 * t;
                        return this.int16[we + 0] = r, this.int16[we + 1] = n, this.int16[we + 2] = l, this.int16[we + 3] = p, this.int16[we + 4] = d, this.int16[we + 5] = m, this.int16[we + 6] = _, this.int16[we + 7] = v, this.uint16[we + 8] = b, this.uint16[we + 9] = S, this.uint16[we + 10] = I, this.uint16[we + 11] = A, this.uint16[we + 12] = k, this.uint16[we + 13] = D, this.uint16[we + 14] = N, this.uint16[we + 15] = G, this.uint16[we + 16] = ie, this.uint16[we + 17] = H, this.uint16[we + 18] = C, this.uint16[we + 19] = F, this.uint16[we + 20] = X, this.uint16[we + 21] = ue, this.uint16[we + 22] = Me, this.uint32[Be + 12] = me, this.float32[Be + 13] = xe, this.float32[Be + 14] = Ae, this.uint16[we + 30] = Ie, this.uint16[we + 31] = ke, t;
                    }
                }
                x.prototype.bytesPerElement = 64, Le("StructArrayLayout8i15ui1ul2f2ui64", x);
                class w extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
                    }
                    emplaceBack(t) {
                        const r = this.length;
                        return this.resize(r + 1), this.emplace(r, t);
                    }
                    emplace(t, r) {
                        return this.float32[1 * t + 0] = r, t;
                    }
                }
                w.prototype.bytesPerElement = 4, Le("StructArrayLayout1f4", w);
                class P extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n) {
                        const l = this.length;
                        return this.resize(l + 1), this.emplace(l, t, r, n);
                    }
                    emplace(t, r, n, l) {
                        const p = 3 * t;
                        return this.uint16[6 * t + 0] = r, this.float32[p + 1] = n, this.float32[p + 2] = l, t;
                    }
                }
                P.prototype.bytesPerElement = 12, Le("StructArrayLayout1ui2f12", P);
                class T extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n) {
                        const l = this.length;
                        return this.resize(l + 1), this.emplace(l, t, r, n);
                    }
                    emplace(t, r, n, l) {
                        const p = 4 * t;
                        return this.uint32[2 * t + 0] = r, this.uint16[p + 2] = n, this.uint16[p + 3] = l, t;
                    }
                }
                T.prototype.bytesPerElement = 8, Le("StructArrayLayout1ul2ui8", T);
                class z extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r) {
                        const n = this.length;
                        return this.resize(n + 1), this.emplace(n, t, r);
                    }
                    emplace(t, r, n) {
                        const l = 2 * t;
                        return this.uint16[l + 0] = r, this.uint16[l + 1] = n, t;
                    }
                }
                z.prototype.bytesPerElement = 4, Le("StructArrayLayout2ui4", z);
                class R extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
                    }
                    emplaceBack(t) {
                        const r = this.length;
                        return this.resize(r + 1), this.emplace(r, t);
                    }
                    emplace(t, r) {
                        return this.uint16[1 * t + 0] = r, t;
                    }
                }
                R.prototype.bytesPerElement = 2, Le("StructArrayLayout1ui2", R);
                class V extends Nt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
                    }
                    emplaceBack(t, r, n, l) {
                        const p = this.length;
                        return this.resize(p + 1), this.emplace(p, t, r, n, l);
                    }
                    emplace(t, r, n, l, p) {
                        const d = 4 * t;
                        return this.float32[d + 0] = r, this.float32[d + 1] = n, this.float32[d + 2] = l, this.float32[d + 3] = p, t;
                    }
                }
                V.prototype.bytesPerElement = 16, Le("StructArrayLayout4f16", V);
                class U extends _a {
                    get anchorPointX() {
                        return this._structArray.int16[this._pos2 + 0];
                    }
                    get anchorPointY() {
                        return this._structArray.int16[this._pos2 + 1];
                    }
                    get x1() {
                        return this._structArray.int16[this._pos2 + 2];
                    }
                    get y1() {
                        return this._structArray.int16[this._pos2 + 3];
                    }
                    get x2() {
                        return this._structArray.int16[this._pos2 + 4];
                    }
                    get y2() {
                        return this._structArray.int16[this._pos2 + 5];
                    }
                    get featureIndex() {
                        return this._structArray.uint32[this._pos4 + 3];
                    }
                    get sourceLayerIndex() {
                        return this._structArray.uint16[this._pos2 + 8];
                    }
                    get bucketIndex() {
                        return this._structArray.uint16[this._pos2 + 9];
                    }
                    get anchorPoint() {
                        return new $e(this.anchorPointX, this.anchorPointY);
                    }
                }
                U.prototype.size = 20;
                class Z extends s {
                    get(t) {
                        return new U(this, t);
                    }
                }
                Le("CollisionBoxArray", Z);
                class q extends _a {
                    get anchorX() {
                        return this._structArray.int16[this._pos2 + 0];
                    }
                    get anchorY() {
                        return this._structArray.int16[this._pos2 + 1];
                    }
                    get glyphStartIndex() {
                        return this._structArray.uint16[this._pos2 + 2];
                    }
                    get numGlyphs() {
                        return this._structArray.uint16[this._pos2 + 3];
                    }
                    get vertexStartIndex() {
                        return this._structArray.uint32[this._pos4 + 2];
                    }
                    get lineStartIndex() {
                        return this._structArray.uint32[this._pos4 + 3];
                    }
                    get lineLength() {
                        return this._structArray.uint32[this._pos4 + 4];
                    }
                    get segment() {
                        return this._structArray.uint16[this._pos2 + 10];
                    }
                    get lowerSize() {
                        return this._structArray.uint16[this._pos2 + 11];
                    }
                    get upperSize() {
                        return this._structArray.uint16[this._pos2 + 12];
                    }
                    get lineOffsetX() {
                        return this._structArray.float32[this._pos4 + 7];
                    }
                    get lineOffsetY() {
                        return this._structArray.float32[this._pos4 + 8];
                    }
                    get writingMode() {
                        return this._structArray.uint8[this._pos1 + 36];
                    }
                    get placedOrientation() {
                        return this._structArray.uint8[this._pos1 + 37];
                    }
                    set placedOrientation(t) {
                        this._structArray.uint8[this._pos1 + 37] = t;
                    }
                    get hidden() {
                        return this._structArray.uint8[this._pos1 + 38];
                    }
                    set hidden(t) {
                        this._structArray.uint8[this._pos1 + 38] = t;
                    }
                    get crossTileID() {
                        return this._structArray.uint32[this._pos4 + 10];
                    }
                    set crossTileID(t) {
                        this._structArray.uint32[this._pos4 + 10] = t;
                    }
                    get associatedIconIndex() {
                        return this._structArray.int16[this._pos2 + 22];
                    }
                }
                q.prototype.size = 48;
                class J extends y {
                    get(t) {
                        return new q(this, t);
                    }
                }
                Le("PlacedSymbolArray", J);
                class Y extends _a {
                    get anchorX() {
                        return this._structArray.int16[this._pos2 + 0];
                    }
                    get anchorY() {
                        return this._structArray.int16[this._pos2 + 1];
                    }
                    get rightJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 2];
                    }
                    get centerJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 3];
                    }
                    get leftJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 4];
                    }
                    get verticalPlacedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 5];
                    }
                    get placedIconSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 6];
                    }
                    get verticalPlacedIconSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 7];
                    }
                    get key() {
                        return this._structArray.uint16[this._pos2 + 8];
                    }
                    get textBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 9];
                    }
                    get textBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 10];
                    }
                    get verticalTextBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 11];
                    }
                    get verticalTextBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 12];
                    }
                    get iconBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 13];
                    }
                    get iconBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 14];
                    }
                    get verticalIconBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 15];
                    }
                    get verticalIconBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 16];
                    }
                    get featureIndex() {
                        return this._structArray.uint16[this._pos2 + 17];
                    }
                    get numHorizontalGlyphVertices() {
                        return this._structArray.uint16[this._pos2 + 18];
                    }
                    get numVerticalGlyphVertices() {
                        return this._structArray.uint16[this._pos2 + 19];
                    }
                    get numIconVertices() {
                        return this._structArray.uint16[this._pos2 + 20];
                    }
                    get numVerticalIconVertices() {
                        return this._structArray.uint16[this._pos2 + 21];
                    }
                    get useRuntimeCollisionCircles() {
                        return this._structArray.uint16[this._pos2 + 22];
                    }
                    get crossTileID() {
                        return this._structArray.uint32[this._pos4 + 12];
                    }
                    set crossTileID(t) {
                        this._structArray.uint32[this._pos4 + 12] = t;
                    }
                    get textBoxScale() {
                        return this._structArray.float32[this._pos4 + 13];
                    }
                    get collisionCircleDiameter() {
                        return this._structArray.float32[this._pos4 + 14];
                    }
                    get textAnchorOffsetStartIndex() {
                        return this._structArray.uint16[this._pos2 + 30];
                    }
                    get textAnchorOffsetEndIndex() {
                        return this._structArray.uint16[this._pos2 + 31];
                    }
                }
                Y.prototype.size = 64;
                class ee extends x {
                    get(t) {
                        return new Y(this, t);
                    }
                }
                Le("SymbolInstanceArray", ee);
                class ae extends w {
                    getoffsetX(t) {
                        return this.float32[1 * t + 0];
                    }
                }
                Le("GlyphOffsetArray", ae);
                class te extends qn {
                    getx(t) {
                        return this.int16[3 * t + 0];
                    }
                    gety(t) {
                        return this.int16[3 * t + 1];
                    }
                    gettileUnitDistanceFromAnchor(t) {
                        return this.int16[3 * t + 2];
                    }
                }
                Le("SymbolLineVertexArray", te);
                class he extends _a {
                    get textAnchor() {
                        return this._structArray.uint16[this._pos2 + 0];
                    }
                    get textOffset0() {
                        return this._structArray.float32[this._pos4 + 1];
                    }
                    get textOffset1() {
                        return this._structArray.float32[this._pos4 + 2];
                    }
                }
                he.prototype.size = 12;
                class be extends P {
                    get(t) {
                        return new he(this, t);
                    }
                }
                Le("TextAnchorOffsetArray", be);
                class ge extends _a {
                    get featureIndex() {
                        return this._structArray.uint32[this._pos4 + 0];
                    }
                    get sourceLayerIndex() {
                        return this._structArray.uint16[this._pos2 + 2];
                    }
                    get bucketIndex() {
                        return this._structArray.uint16[this._pos2 + 3];
                    }
                }
                ge.prototype.size = 8;
                class _e extends T {
                    get(t) {
                        return new ge(this, t);
                    }
                }
                Le("FeatureIndexArray", _e);
                class ye extends Gn {
                }
                class Ee extends Gn {
                }
                class ze extends Gn {
                }
                class Ce extends il {
                }
                class Ne extends rl {
                }
                class tt extends Qa {
                }
                class lt extends al {
                }
                class At extends h {
                }
                class xt extends e {
                }
                class kt extends i {
                }
                class zt extends o {
                }
                class wt extends f {
                }
                class ft extends g {
                }
                class Kt extends z {
                }
                const ii = Ct([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: ui } = ii;
                class mt {
                    constructor(t = []) {
                        this._forceNewSegmentOnNextPrepare = !1, this.segments = t;
                    }
                    prepareSegment(t, r, n, l) {
                        const p = this.segments[this.segments.length - 1];
                        return t > mt.MAX_VERTEX_ARRAY_LENGTH && wi(`Max vertices per segment is ${mt.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${mt.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !p || p.vertexLength + t > mt.MAX_VERTEX_ARRAY_LENGTH || p.sortKey !== l ? this.createNewSegment(r, n, l) : p;
                    }
                    createNewSegment(t, r, n) {
                        const l = { vertexOffset: t.length, primitiveOffset: r.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
                        return n !== void 0 && (l.sortKey = n), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(l), l;
                    }
                    getOrCreateLatestSegment(t, r, n) {
                        return this.prepareSegment(0, t, r, n);
                    }
                    forceNewSegmentOnNextPrepare() {
                        this._forceNewSegmentOnNextPrepare = !0;
                    }
                    get() {
                        return this.segments;
                    }
                    destroy() {
                        for (const t of this.segments) for (const r in t.vaos) t.vaos[r].destroy();
                    }
                    static simpleSegment(t, r, n, l) {
                        return new mt([{ vertexOffset: t, primitiveOffset: r, vertexLength: n, primitiveLength: l, vaos: {}, sortKey: 0 }]);
                    }
                }
                function Zr(a, t) {
                    return 256 * (a = li(Math.floor(a), 0, 255)) + li(Math.floor(t), 0, 255);
                }
                mt.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Le("SegmentVector", mt);
                const xr = Ct([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
                var Gr, va, Hn, qr = { exports: {} }, xa = { exports: {} }, $i = { exports: {} }, Hr = function () {
                    if (Hn) return qr.exports;
                    Hn = 1;
                    var a = (Gr || (Gr = 1, xa.exports = function (r, n) {
                        var l, p, d, m, _, v, b, S;
                        for (p = r.length - (l = 3 & r.length), d = n, _ = 3432918353, v = 461845907, S = 0; S < p;) b = 255 & r.charCodeAt(S) | (255 & r.charCodeAt(++S)) << 8 | (255 & r.charCodeAt(++S)) << 16 | (255 & r.charCodeAt(++S)) << 24, ++S, d = 27492 + (65535 & (m = 5 * (65535 & (d = (d ^= b = (65535 & (b = (b = (65535 & b) * _ + (((b >>> 16) * _ & 65535) << 16) & 4294967295) << 15 | b >>> 17)) * v + (((b >>> 16) * v & 65535) << 16) & 4294967295) << 13 | d >>> 19)) + ((5 * (d >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (m >>> 16) & 65535) << 16);
                        switch (b = 0, l) {
                            case 3:
                                b ^= (255 & r.charCodeAt(S + 2)) << 16;
                            case 2:
                                b ^= (255 & r.charCodeAt(S + 1)) << 8;
                            case 1:
                                d ^= b = (65535 & (b = (b = (65535 & (b ^= 255 & r.charCodeAt(S))) * _ + (((b >>> 16) * _ & 65535) << 16) & 4294967295) << 15 | b >>> 17)) * v + (((b >>> 16) * v & 65535) << 16) & 4294967295;
                        }
                        return d ^= r.length, d = 2246822507 * (65535 & (d ^= d >>> 16)) + ((2246822507 * (d >>> 16) & 65535) << 16) & 4294967295, d = 3266489909 * (65535 & (d ^= d >>> 13)) + ((3266489909 * (d >>> 16) & 65535) << 16) & 4294967295, (d ^= d >>> 16) >>> 0;
                    }), xa.exports), t = (va || (va = 1, $i.exports = function (r, n) {
                        for (var l, p = r.length, d = n ^ p, m = 0; p >= 4;) l = 1540483477 * (65535 & (l = 255 & r.charCodeAt(m) | (255 & r.charCodeAt(++m)) << 8 | (255 & r.charCodeAt(++m)) << 16 | (255 & r.charCodeAt(++m)) << 24)) + ((1540483477 * (l >>> 16) & 65535) << 16), d = 1540483477 * (65535 & d) + ((1540483477 * (d >>> 16) & 65535) << 16) ^ (l = 1540483477 * (65535 & (l ^= l >>> 24)) + ((1540483477 * (l >>> 16) & 65535) << 16)), p -= 4, ++m;
                        switch (p) {
                            case 3:
                                d ^= (255 & r.charCodeAt(m + 2)) << 16;
                            case 2:
                                d ^= (255 & r.charCodeAt(m + 1)) << 8;
                            case 1:
                                d = 1540483477 * (65535 & (d ^= 255 & r.charCodeAt(m))) + ((1540483477 * (d >>> 16) & 65535) << 16);
                        }
                        return d = 1540483477 * (65535 & (d ^= d >>> 13)) + ((1540483477 * (d >>> 16) & 65535) << 16), (d ^= d >>> 15) >>> 0;
                    }), $i.exports);
                    return qr.exports = a, qr.exports.murmur3 = a, qr.exports.murmur2 = t, qr.exports;
                }(), kr = Fe(Hr);
                class Wr {
                    constructor() {
                        this.ids = [], this.positions = [], this.indexed = !1;
                    }
                    add(t, r, n, l) {
                        this.ids.push(qt(t)), this.positions.push(r, n, l);
                    }
                    getPositions(t) {
                        if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
                        const r = qt(t);
                        let n = 0, l = this.ids.length - 1;
                        for (; n < l;) {
                            const d = n + l >> 1;
                            this.ids[d] >= r ? l = d : n = d + 1;
                        }
                        const p = [];
                        for (; this.ids[n] === r;) p.push({ index: this.positions[3 * n], start: this.positions[3 * n + 1], end: this.positions[3 * n + 2] }), n++;
                        return p;
                    }
                    static serialize(t, r) {
                        const n = new Float64Array(t.ids), l = new Uint32Array(t.positions);
                        return Ht(n, l, 0, n.length - 1), r && r.push(n.buffer, l.buffer), { ids: n, positions: l };
                    }
                    static deserialize(t) {
                        const r = new Wr();
                        return r.ids = t.ids, r.positions = t.positions, r.indexed = !0, r;
                    }
                }
                function qt(a) {
                    const t = +a;
                    return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : kr(String(a));
                }
                function Ht(a, t, r, n) {
                    for (; r < n;) {
                        const l = a[r + n >> 1];
                        let p = r - 1, d = n + 1;
                        for (; ;) {
                            do
                                p++;
                            while (a[p] < l);
                            do
                                d--;
                            while (a[d] > l);
                            if (p >= d) break;
                            Ii(a, p, d), Ii(t, 3 * p, 3 * d), Ii(t, 3 * p + 1, 3 * d + 1), Ii(t, 3 * p + 2, 3 * d + 2);
                        }
                        d - r < n - d ? (Ht(a, t, r, d), r = d + 1) : (Ht(a, t, d + 1, n), n = d);
                    }
                }
                function Ii(a, t, r) {
                    const n = a[t];
                    a[t] = a[r], a[r] = n;
                }
                Le("FeaturePositionMap", Wr);
                class Pt {
                    constructor(t, r) {
                        this.gl = t.gl, this.location = r;
                    }
                }
                class Ks extends Pt {
                    constructor(t, r) {
                        super(t, r), this.current = 0;
                    }
                    set(t) {
                        this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));
                    }
                }
                class Mc extends Pt {
                    constructor(t, r) {
                        super(t, r), this.current = [0, 0, 0, 0];
                    }
                    set(t) {
                        t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
                    }
                }
                class Ic extends Pt {
                    constructor(t, r) {
                        super(t, r), this.current = st.transparent;
                    }
                    set(t) {
                        t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
                    }
                }
                const Mh = new Float32Array(16);
                function nl(a) {
                    return [Zr(255 * a.r, 255 * a.g), Zr(255 * a.b, 255 * a.a)];
                }
                class Wn {
                    constructor(t, r, n) {
                        this.value = t, this.uniformNames = r.map((l) => `u_${l}`), this.type = n;
                    }
                    setUniform(t, r, n) {
                        t.set(n.constantOr(this.value));
                    }
                    getBinding(t, r, n) {
                        return this.type === "color" ? new Ic(t, r) : new Ks(t, r);
                    }
                }
                class Ki {
                    constructor(t, r) {
                        this.uniformNames = r.map((n) => `u_${n}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
                    }
                    setConstantPatternPositions(t, r) {
                        this.pixelRatioFrom = r.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = r.tlbr, this.patternTo = t.tlbr;
                    }
                    setUniform(t, r, n, l) {
                        const p = l === "u_pattern_to" ? this.patternTo : l === "u_pattern_from" ? this.patternFrom : l === "u_pixel_ratio_to" ? this.pixelRatioTo : l === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
                        p && t.set(p);
                    }
                    getBinding(t, r, n) {
                        return n.substr(0, 9) === "u_pattern" ? new Mc(t, r) : new Ks(t, r);
                    }
                }
                class br {
                    constructor(t, r, n, l) {
                        this.expression = t, this.type = n, this.maxValue = 0, this.paintVertexAttributes = r.map((p) => ({ name: `a_${p}`, type: "Float32", components: n === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new l();
                    }
                    populatePaintArray(t, r, n, l, p) {
                        const d = this.paintVertexArray.length, m = this.expression.evaluate(new Tt(0), r, {}, l, [], p);
                        this.paintVertexArray.resize(t), this._setPaintValue(d, t, m);
                    }
                    updatePaintArray(t, r, n, l) {
                        const p = this.expression.evaluate({ zoom: 0 }, n, l);
                        this._setPaintValue(t, r, p);
                    }
                    _setPaintValue(t, r, n) {
                        if (this.type === "color") {
                            const l = nl(n);
                            for (let p = t; p < r; p++) this.paintVertexArray.emplace(p, l[0], l[1]);
                        } else {
                            for (let l = t; l < r; l++) this.paintVertexArray.emplace(l, n);
                            this.maxValue = Math.max(this.maxValue, Math.abs(n));
                        }
                    }
                    upload(t) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
                    }
                }
                class Yi {
                    constructor(t, r, n, l, p, d) {
                        this.expression = t, this.uniformNames = r.map((m) => `u_${m}_t`), this.type = n, this.useIntegerZoom = l, this.zoom = p, this.maxValue = 0, this.paintVertexAttributes = r.map((m) => ({ name: `a_${m}`, type: "Float32", components: n === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new d();
                    }
                    populatePaintArray(t, r, n, l, p) {
                        const d = this.expression.evaluate(new Tt(this.zoom), r, {}, l, [], p), m = this.expression.evaluate(new Tt(this.zoom + 1), r, {}, l, [], p), _ = this.paintVertexArray.length;
                        this.paintVertexArray.resize(t), this._setPaintValue(_, t, d, m);
                    }
                    updatePaintArray(t, r, n, l) {
                        const p = this.expression.evaluate({ zoom: this.zoom }, n, l), d = this.expression.evaluate({ zoom: this.zoom + 1 }, n, l);
                        this._setPaintValue(t, r, p, d);
                    }
                    _setPaintValue(t, r, n, l) {
                        if (this.type === "color") {
                            const p = nl(n), d = nl(l);
                            for (let m = t; m < r; m++) this.paintVertexArray.emplace(m, p[0], p[1], d[0], d[1]);
                        } else {
                            for (let p = t; p < r; p++) this.paintVertexArray.emplace(p, n, l);
                            this.maxValue = Math.max(this.maxValue, Math.abs(n), Math.abs(l));
                        }
                    }
                    upload(t) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
                    }
                    setUniform(t, r) {
                        const n = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom, l = li(this.expression.interpolationFactor(n, this.zoom, this.zoom + 1), 0, 1);
                        t.set(l);
                    }
                    getBinding(t, r, n) {
                        return new Ks(t, r);
                    }
                }
                class zr {
                    constructor(t, r, n, l, p, d) {
                        this.expression = t, this.type = r, this.useIntegerZoom = n, this.zoom = l, this.layerId = d, this.zoomInPaintVertexArray = new p(), this.zoomOutPaintVertexArray = new p();
                    }
                    populatePaintArray(t, r, n) {
                        const l = this.zoomInPaintVertexArray.length;
                        this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(l, t, r.patterns && r.patterns[this.layerId], n);
                    }
                    updatePaintArray(t, r, n, l, p) {
                        this._setPaintValues(t, r, n.patterns && n.patterns[this.layerId], p);
                    }
                    _setPaintValues(t, r, n, l) {
                        if (!l || !n) return;
                        const { min: p, mid: d, max: m } = n, _ = l[p], v = l[d], b = l[m];
                        if (_ && v && b) for (let S = t; S < r; S++) this.zoomInPaintVertexArray.emplace(S, v.tl[0], v.tl[1], v.br[0], v.br[1], _.tl[0], _.tl[1], _.br[0], _.br[1], v.pixelRatio, _.pixelRatio), this.zoomOutPaintVertexArray.emplace(S, v.tl[0], v.tl[1], v.br[0], v.br[1], b.tl[0], b.tl[1], b.br[0], b.br[1], v.pixelRatio, b.pixelRatio);
                    }
                    upload(t) {
                        this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, xr.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, xr.members, this.expression.isStateDependent));
                    }
                    destroy() {
                        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
                    }
                }
                class Ys {
                    constructor(t, r, n) {
                        this.binders = {}, this._buffers = [];
                        const l = [];
                        for (const p in t.paint._values) {
                            if (!n(p)) continue;
                            const d = t.paint.get(p);
                            if (!(d instanceof Mi && Ua(d.property.specification))) continue;
                            const m = sl(p, t.type), _ = d.value, v = d.property.specification.type, b = d.property.useIntegerZoom, S = d.property.specification["property-type"], I = S === "cross-faded" || S === "cross-faded-data-driven";
                            if (_.kind === "constant") this.binders[p] = I ? new Ki(_.value, m) : new Wn(_.value, m, v), l.push(`/u_${p}`);
                            else if (_.kind === "source" || I) {
                                const A = Mu(p, v, "source");
                                this.binders[p] = I ? new zr(_, v, b, r, A, t.id) : new br(_, m, v, A), l.push(`/a_${p}`);
                            } else {
                                const A = Mu(p, v, "composite");
                                this.binders[p] = new Yi(_, m, v, b, r, A), l.push(`/z_${p}`);
                            }
                        }
                        this.cacheKey = l.sort().join("");
                    }
                    getMaxValue(t) {
                        const r = this.binders[t];
                        return r instanceof br || r instanceof Yi ? r.maxValue : 0;
                    }
                    populatePaintArrays(t, r, n, l, p) {
                        for (const d in this.binders) {
                            const m = this.binders[d];
                            (m instanceof br || m instanceof Yi || m instanceof zr) && m.populatePaintArray(t, r, n, l, p);
                        }
                    }
                    setConstantPatternPositions(t, r) {
                        for (const n in this.binders) {
                            const l = this.binders[n];
                            l instanceof Ki && l.setConstantPatternPositions(t, r);
                        }
                    }
                    updatePaintArrays(t, r, n, l, p) {
                        let d = !1;
                        for (const m in t) {
                            const _ = r.getPositions(m);
                            for (const v of _) {
                                const b = n.feature(v.index);
                                for (const S in this.binders) {
                                    const I = this.binders[S];
                                    if ((I instanceof br || I instanceof Yi || I instanceof zr) && I.expression.isStateDependent === !0) {
                                        const A = l.paint.get(S);
                                        I.expression = A.value, I.updatePaintArray(v.start, v.end, b, t[m], p), d = !0;
                                    }
                                }
                            }
                        }
                        return d;
                    }
                    defines() {
                        const t = [];
                        for (const r in this.binders) {
                            const n = this.binders[r];
                            (n instanceof Wn || n instanceof Ki) && t.push(...n.uniformNames.map((l) => `#define HAS_UNIFORM_${l}`));
                        }
                        return t;
                    }
                    getBinderAttributes() {
                        const t = [];
                        for (const r in this.binders) {
                            const n = this.binders[r];
                            if (n instanceof br || n instanceof Yi) for (let l = 0; l < n.paintVertexAttributes.length; l++) t.push(n.paintVertexAttributes[l].name);
                            else if (n instanceof zr) for (let l = 0; l < xr.members.length; l++) t.push(xr.members[l].name);
                        }
                        return t;
                    }
                    getBinderUniforms() {
                        const t = [];
                        for (const r in this.binders) {
                            const n = this.binders[r];
                            if (n instanceof Wn || n instanceof Ki || n instanceof Yi) for (const l of n.uniformNames) t.push(l);
                        }
                        return t;
                    }
                    getPaintVertexBuffers() {
                        return this._buffers;
                    }
                    getUniforms(t, r) {
                        const n = [];
                        for (const l in this.binders) {
                            const p = this.binders[l];
                            if (p instanceof Wn || p instanceof Ki || p instanceof Yi) {
                                for (const d of p.uniformNames) if (r[d]) {
                                    const m = p.getBinding(t, r[d], d);
                                    n.push({ name: d, property: l, binding: m });
                                }
                            }
                        }
                        return n;
                    }
                    setUniforms(t, r, n, l) {
                        for (const { name: p, property: d, binding: m } of r) this.binders[d].setUniform(m, l, n.get(d), p);
                    }
                    updatePaintBuffers(t) {
                        this._buffers = [];
                        for (const r in this.binders) {
                            const n = this.binders[r];
                            if (t && n instanceof zr) {
                                const l = t.fromScale === 2 ? n.zoomInPaintVertexBuffer : n.zoomOutPaintVertexBuffer;
                                l && this._buffers.push(l);
                            } else (n instanceof br || n instanceof Yi) && n.paintVertexBuffer && this._buffers.push(n.paintVertexBuffer);
                        }
                    }
                    upload(t) {
                        for (const r in this.binders) {
                            const n = this.binders[r];
                            (n instanceof br || n instanceof Yi || n instanceof zr) && n.upload(t);
                        }
                        this.updatePaintBuffers();
                    }
                    destroy() {
                        for (const t in this.binders) {
                            const r = this.binders[t];
                            (r instanceof br || r instanceof Yi || r instanceof zr) && r.destroy();
                        }
                    }
                }
                class Xr {
                    constructor(t, r, n = () => !0) {
                        this.programConfigurations = {};
                        for (const l of t) this.programConfigurations[l.id] = new Ys(l, r, n);
                        this.needsUpload = !1, this._featureMap = new Wr(), this._bufferOffset = 0;
                    }
                    populatePaintArrays(t, r, n, l, p, d) {
                        for (const m in this.programConfigurations) this.programConfigurations[m].populatePaintArrays(t, r, l, p, d);
                        r.id !== void 0 && this._featureMap.add(r.id, n, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;
                    }
                    updatePaintArrays(t, r, n, l) {
                        for (const p of n) this.needsUpload = this.programConfigurations[p.id].updatePaintArrays(t, this._featureMap, r, p, l) || this.needsUpload;
                    }
                    get(t) {
                        return this.programConfigurations[t];
                    }
                    upload(t) {
                        if (this.needsUpload) {
                            for (const r in this.programConfigurations) this.programConfigurations[r].upload(t);
                            this.needsUpload = !1;
                        }
                    }
                    destroy() {
                        for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
                    }
                }
                function sl(a, t) {
                    return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[a] || [a.replace(`${t}-`, "").replace(/-/g, "_")];
                }
                function Mu(a, t, r) {
                    const n = { color: { source: Qa, composite: V }, number: { source: w, composite: Qa } }, l = function (p) {
                        return { "line-pattern": { source: lt, composite: lt }, "fill-pattern": { source: lt, composite: lt }, "fill-extrusion-pattern": { source: lt, composite: lt } }[p];
                    }(a);
                    return l && l[r] || n[t][r];
                }
                Le("ConstantBinder", Wn), Le("CrossFadedConstantBinder", Ki), Le("SourceExpressionBinder", br), Le("CrossFadedCompositeBinder", zr), Le("CompositeExpressionBinder", Yi), Le("ProgramConfiguration", Ys, { omit: ["_buffers"] }), Le("ProgramConfigurationSet", Xr);
                const Ih = Math.pow(2, 14) - 1, Iu = -Ih - 1;
                function Xn(a) {
                    const t = yt / a.extent, r = a.loadGeometry();
                    for (let n = 0; n < r.length; n++) {
                        const l = r[n];
                        for (let p = 0; p < l.length; p++) {
                            const d = l[p], m = Math.round(d.x * t), _ = Math.round(d.y * t);
                            d.x = li(m, Iu, Ih), d.y = li(_, Iu, Ih), (m < d.x || m > d.x + 1 || _ < d.y || _ > d.y + 1) && wi("Geometry exceeds allowed extent, reduce your vector tile buffer size");
                        }
                    }
                    return r;
                }
                function Kn(a, t) {
                    return { type: a.type, id: a.id, properties: a.properties, geometry: t ? Xn(a) : [] };
                }
                const Cu = -32768;
                function Ld(a, t, r, n, l) {
                    a.emplaceBack(Cu + 8 * t + n, Cu + 8 * r + l);
                }
                class Ch {
                    constructor(t) {
                        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r) => r.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Ee(), this.indexArray = new ft(), this.segments = new mt(), this.programConfigurations = new Xr(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((r) => r.isStateDependent()).map((r) => r.id);
                    }
                    populate(t, r, n) {
                        const l = this.layers[0], p = [];
                        let d = null, m = !1, _ = l.type === "heatmap";
                        if (l.type === "circle") {
                            const b = l;
                            d = b.layout.get("circle-sort-key"), m = !d.isConstant(), _ = _ || b.paint.get("circle-pitch-alignment") === "map";
                        }
                        const v = _ ? r.subdivisionGranularity.circle : 1;
                        for (const { feature: b, id: S, index: I, sourceLayerIndex: A } of t) {
                            const k = this.layers[0]._featureFilter.needGeometry, D = Kn(b, k);
                            if (!this.layers[0]._featureFilter.filter(new Tt(this.zoom), D, n)) continue;
                            const N = m ? d.evaluate(D, {}, n) : void 0, G = { id: S, properties: b.properties, type: b.type, sourceLayerIndex: A, index: I, geometry: k ? D.geometry : Xn(b), patterns: {}, sortKey: N };
                            p.push(G);
                        }
                        m && p.sort((b, S) => b.sortKey - S.sortKey);
                        for (const b of p) {
                            const { geometry: S, index: I, sourceLayerIndex: A } = b, k = t[I].feature;
                            this.addFeature(b, S, I, n, v), r.featureIndex.insert(k, S, I, A, this.index);
                        }
                    }
                    update(t, r, n) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, n);
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0;
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload;
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ui), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
                    }
                    addFeature(t, r, n, l, p = 1) {
                        let d;
                        switch (p) {
                            case 1:
                                d = [0, 7];
                                break;
                            case 3:
                                d = [0, 2, 5, 7];
                                break;
                            case 5:
                                d = [0, 1, 3, 4, 6, 7];
                                break;
                            case 7:
                                d = [0, 1, 2, 3, 4, 5, 6, 7];
                                break;
                            default:
                                throw new Error(`Invalid circle bucket granularity: ${p}; valid values are 1, 3, 5, 7.`);
                        }
                        const m = d.length;
                        for (const _ of r) for (const v of _) {
                            const b = v.x, S = v.y;
                            if (b < 0 || b >= yt || S < 0 || S >= yt) continue;
                            const I = this.segments.prepareSegment(m * m, this.layoutVertexArray, this.indexArray, t.sortKey), A = I.vertexLength;
                            for (let k = 0; k < m; k++) for (let D = 0; D < m; D++) Ld(this.layoutVertexArray, b, S, d[D], d[k]);
                            for (let k = 0; k < m - 1; k++) for (let D = 0; D < m - 1; D++) {
                                const N = A + k * m + D, G = A + (k + 1) * m + D;
                                this.indexArray.emplaceBack(N, G + 1, N + 1), this.indexArray.emplaceBack(N, G, G + 1);
                            }
                            I.vertexLength += m * m, I.primitiveLength += (m - 1) * (m - 1) * 2;
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, {}, l);
                    }
                }
                function Au(a, t) {
                    for (let r = 0; r < a.length; r++) if (Yn(t, a[r])) return !0;
                    for (let r = 0; r < t.length; r++) if (Yn(a, t[r])) return !0;
                    return !!Ah(a, t);
                }
                function Bd(a, t, r) {
                    return !!Yn(a, t) || !!kh(t, a, r);
                }
                function ku(a, t) {
                    if (a.length === 1) return Eu(t, a[0]);
                    for (let r = 0; r < t.length; r++) {
                        const n = t[r];
                        for (let l = 0; l < n.length; l++) if (Yn(a, n[l])) return !0;
                    }
                    for (let r = 0; r < a.length; r++) if (Eu(t, a[r])) return !0;
                    for (let r = 0; r < t.length; r++) if (Ah(a, t[r])) return !0;
                    return !1;
                }
                function Fd(a, t, r) {
                    if (a.length > 1) {
                        if (Ah(a, t)) return !0;
                        for (let n = 0; n < t.length; n++) if (kh(t[n], a, r)) return !0;
                    }
                    for (let n = 0; n < a.length; n++) if (kh(a[n], t, r)) return !0;
                    return !1;
                }
                function Ah(a, t) {
                    if (a.length === 0 || t.length === 0) return !1;
                    for (let r = 0; r < a.length - 1; r++) {
                        const n = a[r], l = a[r + 1];
                        for (let p = 0; p < t.length - 1; p++) if (Nd(n, l, t[p], t[p + 1])) return !0;
                    }
                    return !1;
                }
                function Nd(a, t, r, n) {
                    return bt(a, r, n) !== bt(t, r, n) && bt(a, t, r) !== bt(a, t, n);
                }
                function kh(a, t, r) {
                    const n = r * r;
                    if (t.length === 1) return a.distSqr(t[0]) < n;
                    for (let l = 1; l < t.length; l++) if (zu(a, t[l - 1], t[l]) < n) return !0;
                    return !1;
                }
                function zu(a, t, r) {
                    const n = t.distSqr(r);
                    if (n === 0) return a.distSqr(t);
                    const l = ((a.x - t.x) * (r.x - t.x) + (a.y - t.y) * (r.y - t.y)) / n;
                    return a.distSqr(l < 0 ? t : l > 1 ? r : r.sub(t)._mult(l)._add(t));
                }
                function Eu(a, t) {
                    for (let r = 0; r < a.length; r++) if (Yn(a[r], t)) return !0;
                    return !1;
                }
                function Yn(a, t) {
                    let r = !1;
                    for (let n = 0, l = a.length - 1; n < a.length; l = n++) {
                        const p = a[n], d = a[l];
                        p.y > t.y != d.y > t.y && t.x < (d.x - p.x) * (t.y - p.y) / (d.y - p.y) + p.x && (r = !r);
                    }
                    return r;
                }
                function Od(a, t, r) {
                    const n = r[0], l = r[2];
                    if (a.x < n.x && t.x < n.x || a.x > l.x && t.x > l.x || a.y < n.y && t.y < n.y || a.y > l.y && t.y > l.y) return !1;
                    const p = bt(a, t, r[0]);
                    return p !== bt(a, t, r[1]) || p !== bt(a, t, r[2]) || p !== bt(a, t, r[3]);
                }
                function ol(a, t, r) {
                    const n = t.paint.get(a).value;
                    return n.kind === "constant" ? n.value : r.programConfigurations.get(t.id).getMaxValue(a);
                }
                function Cc(a) {
                    return Math.sqrt(a[0] * a[0] + a[1] * a[1]);
                }
                function Ac(a, t, r, n, l) {
                    if (!t[0] && !t[1]) return a;
                    const p = $e.convert(t)._mult(l);
                    r === "viewport" && p._rotate(-n);
                    const d = [];
                    for (let m = 0; m < a.length; m++) d.push(a[m].sub(p));
                    return d;
                }
                let Ru, Du;
                Le("CircleBucket", Ch, { omit: ["layers"] });
                var jd = {
                    get paint() {
                        return Du = Du || new Gt({ "circle-radius": new He(O.paint_circle["circle-radius"]), "circle-color": new He(O.paint_circle["circle-color"]), "circle-blur": new He(O.paint_circle["circle-blur"]), "circle-opacity": new He(O.paint_circle["circle-opacity"]), "circle-translate": new je(O.paint_circle["circle-translate"]), "circle-translate-anchor": new je(O.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new je(O.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new je(O.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new He(O.paint_circle["circle-stroke-width"]), "circle-stroke-color": new He(O.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new He(O.paint_circle["circle-stroke-opacity"]) });
                    }, get layout() {
                        return Ru = Ru || new Gt({ "circle-sort-key": new He(O.layout_circle["circle-sort-key"]) });
                    }
                };
                class $d extends Xi {
                    constructor(t) {
                        super(t, jd);
                    }
                    createBucket(t) {
                        return new Ch(t);
                    }
                    queryRadius(t) {
                        const r = t;
                        return ol("circle-radius", this, r) + ol("circle-stroke-width", this, r) + Cc(this.paint.get("circle-translate"));
                    }
                    queryIntersectsFeature({ queryGeometry: t, feature: r, featureState: n, geometry: l, transform: p, pixelsToTileUnits: d, unwrappedTileID: m, getElevation: _ }) {
                        const v = Ac(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -p.bearingInRadians, d), b = this.paint.get("circle-radius").evaluate(r, n) + this.paint.get("circle-stroke-width").evaluate(r, n), S = this.paint.get("circle-pitch-alignment") === "map", I = S ? v : function (k, D, N, G) {
                            return k.map((ie) => Lu(ie, D, N, G));
                        }(v, p, m, _), A = S ? b * d : b;
                        for (const k of l) for (const D of k) {
                            const N = S ? D : Lu(D, p, m, _);
                            let G = A;
                            const ie = p.projectTileCoordinates(D.x, D.y, m, _).signedDistanceFromCamera;
                            if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? G *= ie / p.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (G *= p.cameraToCenterDistance / ie), Bd(I, N, G)) return !0;
                        }
                        return !1;
                    }
                }
                function Lu(a, t, r, n) {
                    const l = t.projectTileCoordinates(a.x, a.y, r, n).point;
                    return new $e((0.5 * l.x + 0.5) * t.width, (0.5 * -l.y + 0.5) * t.height);
                }
                class Bu extends Ch {
                }
                let Fu;
                Le("HeatmapBucket", Bu, { omit: ["layers"] });
                var Ud = {
                    get paint() {
                        return Fu = Fu || new Gt({ "heatmap-radius": new He(O.paint_heatmap["heatmap-radius"]), "heatmap-weight": new He(O.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new je(O.paint_heatmap["heatmap-intensity"]), "heatmap-color": new el(O.paint_heatmap["heatmap-color"]), "heatmap-opacity": new je(O.paint_heatmap["heatmap-opacity"]) });
                    }
                };
                function zh(a, { width: t, height: r }, n, l) {
                    if (l) {
                        if (l instanceof Uint8ClampedArray) l = new Uint8Array(l.buffer);
                        else if (l.length !== t * r * n) throw new RangeError(`mismatched image size. expected: ${l.length} but got: ${t * r * n}`);
                    } else l = new Uint8Array(t * r * n);
                    return a.width = t, a.height = r, a.data = l, a;
                }
                function Nu(a, { width: t, height: r }, n) {
                    if (t === a.width && r === a.height) return;
                    const l = zh({}, { width: t, height: r }, n);
                    Eh(a, l, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(a.width, t), height: Math.min(a.height, r) }, n), a.width = t, a.height = r, a.data = l.data;
                }
                function Eh(a, t, r, n, l, p) {
                    if (l.width === 0 || l.height === 0) return t;
                    if (l.width > a.width || l.height > a.height || r.x > a.width - l.width || r.y > a.height - l.height) throw new RangeError("out of range source coordinates for image copy");
                    if (l.width > t.width || l.height > t.height || n.x > t.width - l.width || n.y > t.height - l.height) throw new RangeError("out of range destination coordinates for image copy");
                    const d = a.data, m = t.data;
                    if (d === m) throw new Error("srcData equals dstData, so image is already copied");
                    for (let _ = 0; _ < l.height; _++) {
                        const v = ((r.y + _) * a.width + r.x) * p, b = ((n.y + _) * t.width + n.x) * p;
                        for (let S = 0; S < l.width * p; S++) m[b + S] = d[v + S];
                    }
                    return t;
                }
                class ll {
                    constructor(t, r) {
                        zh(this, t, 1, r);
                    }
                    resize(t) {
                        Nu(this, t, 1);
                    }
                    clone() {
                        return new ll({ width: this.width, height: this.height }, new Uint8Array(this.data));
                    }
                    static copy(t, r, n, l, p) {
                        Eh(t, r, n, l, p, 1);
                    }
                }
                class rr {
                    constructor(t, r) {
                        zh(this, t, 4, r);
                    }
                    resize(t) {
                        Nu(this, t, 4);
                    }
                    replace(t, r) {
                        r ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
                    }
                    clone() {
                        return new rr({ width: this.width, height: this.height }, new Uint8Array(this.data));
                    }
                    static copy(t, r, n, l, p) {
                        Eh(t, r, n, l, p, 4);
                    }
                }
                function Ou(a) {
                    const t = {}, r = a.resolution || 256, n = a.clips ? a.clips.length : 1, l = a.image || new rr({ width: r, height: n });
                    if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`);
                    const p = (d, m, _) => {
                        t[a.evaluationKey] = _;
                        const v = a.expression.evaluate(t);
                        l.data[d + m + 0] = Math.floor(255 * v.r / v.a), l.data[d + m + 1] = Math.floor(255 * v.g / v.a), l.data[d + m + 2] = Math.floor(255 * v.b / v.a), l.data[d + m + 3] = Math.floor(255 * v.a);
                    };
                    if (a.clips) for (let d = 0, m = 0; d < n; ++d, m += 4 * r) for (let _ = 0, v = 0; _ < r; _++, v += 4) {
                        const b = _ / (r - 1), { start: S, end: I } = a.clips[d];
                        p(m, v, S * (1 - b) + I * b);
                    }
                    else for (let d = 0, m = 0; d < r; d++, m += 4) p(0, m, d / (r - 1));
                    return l;
                }
                Le("AlphaImage", ll), Le("RGBAImage", rr);
                const Rh = "big-fb";
                class Vd extends Xi {
                    createBucket(t) {
                        return new Bu(t);
                    }
                    constructor(t) {
                        super(t, Ud), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
                    }
                    _handleSpecialPaintPropertyUpdate(t) {
                        t === "heatmap-color" && this._updateColorRamp();
                    }
                    _updateColorRamp() {
                        this.colorRamp = Ou({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
                    }
                    resize() {
                        this.heatmapFbos.has(Rh) && this.heatmapFbos.delete(Rh);
                    }
                    queryRadius() {
                        return 0;
                    }
                    queryIntersectsFeature() {
                        return !1;
                    }
                    hasOffscreenPass() {
                        return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
                    }
                }
                let ju;
                var Zd = {
                    get paint() {
                        return ju = ju || new Gt({ "hillshade-illumination-direction": new je(O.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new je(O.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new je(O.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new je(O.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new je(O.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new je(O.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new je(O.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new je(O.paint_hillshade["hillshade-method"]) });
                    }
                };
                class Gd extends Xi {
                    constructor(t) {
                        super(t, Zd), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
                    }
                    getIlluminationProperties() {
                        let t = this.paint.get("hillshade-illumination-direction").values, r = this.paint.get("hillshade-illumination-altitude").values, n = this.paint.get("hillshade-highlight-color").values, l = this.paint.get("hillshade-shadow-color").values;
                        const p = Math.max(t.length, r.length, n.length, l.length);
                        t = t.concat(Array(p - t.length).fill(t.at(-1))), r = r.concat(Array(p - r.length).fill(r.at(-1))), n = n.concat(Array(p - n.length).fill(n.at(-1))), l = l.concat(Array(p - l.length).fill(l.at(-1)));
                        const d = r.map(ia);
                        return { directionRadians: t.map(ia), altitudeRadians: d, shadowColor: l, highlightColor: n };
                    }
                    hasOffscreenPass() {
                        return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
                    }
                }
                const qd = Ct([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Hd } = qd;
                function Dh(a, t, r) {
                    const n = r.patternDependencies;
                    let l = !1;
                    for (const p of t) {
                        const d = p.paint.get(`${a}-pattern`);
                        d.isConstant() || (l = !0);
                        const m = d.constantOr(null);
                        m && (l = !0, n[m.to] = !0, n[m.from] = !0);
                    }
                    return l;
                }
                function Lh(a, t, r, n, l) {
                    const p = l.patternDependencies;
                    for (const d of t) {
                        const m = d.paint.get(`${a}-pattern`).value;
                        if (m.kind !== "constant") {
                            let _ = m.evaluate({ zoom: n - 1 }, r, {}, l.availableImages), v = m.evaluate({ zoom: n }, r, {}, l.availableImages), b = m.evaluate({ zoom: n + 1 }, r, {}, l.availableImages);
                            _ = _ && _.name ? _.name : _, v = v && v.name ? v.name : v, b = b && b.name ? b.name : b, p[_] = !0, p[v] = !0, p[b] = !0, r.patterns[d.id] = { min: _, mid: v, max: b };
                        }
                    }
                    return r;
                }
                function $u(a, t, r, n, l) {
                    let p;
                    if (l === function (d, m, _, v) {
                        let b = 0;
                        for (let S = m, I = _ - v; S < _; S += v) b += (d[I] - d[S]) * (d[S + 1] + d[I + 1]), I = S;
                        return b;
                    }(a, t, r, n) > 0) for (let d = t; d < r; d += n) p = Gu(d / n | 0, a[d], a[d + 1], p);
                    else for (let d = r - n; d >= t; d -= n) p = Gu(d / n | 0, a[d], a[d + 1], p);
                    return p && Js(p, p.next) && (pl(p), p = p.next), p;
                }
                function Jn(a, t) {
                    if (!a) return a;
                    t || (t = a);
                    let r, n = a;
                    do
                        if (r = !1, n.steiner || !Js(n, n.next) && Vt(n.prev, n, n.next) !== 0) n = n.next;
                        else {
                            if (pl(n), n = t = n.prev, n === n.next) break;
                            r = !0;
                        }
                    while (r || n !== t);
                    return t;
                }
                function cl(a, t, r, n, l, p, d) {
                    if (!a) return;
                    !d && p && function (_, v, b, S) {
                        let I = _;
                        do
                            I.z === 0 && (I.z = Bh(I.x, I.y, v, b, S)), I.prevZ = I.prev, I.nextZ = I.next, I = I.next;
                        while (I !== _);
                        I.prevZ.nextZ = null, I.prevZ = null, function (A) {
                            let k, D = 1;
                            do {
                                let N, G = A;
                                A = null;
                                let ie = null;
                                for (k = 0; G;) {
                                    k++;
                                    let H = G, C = 0;
                                    for (let X = 0; X < D && (C++, H = H.nextZ, H); X++);
                                    let F = D;
                                    for (; C > 0 || F > 0 && H;) C !== 0 && (F === 0 || !H || G.z <= H.z) ? (N = G, G = G.nextZ, C--) : (N = H, H = H.nextZ, F--), ie ? ie.nextZ = N : A = N, N.prevZ = ie, ie = N;
                                    G = H;
                                }
                                ie.nextZ = null, D *= 2;
                            } while (k > 1);
                        }(I);
                    }(a, n, l, p);
                    let m = a;
                    for (; a.prev !== a.next;) {
                        const _ = a.prev, v = a.next;
                        if (p ? Xd(a, n, l, p) : Wd(a)) t.push(_.i, a.i, v.i), pl(a), a = v.next, m = v.next;
                        else if ((a = v) === m) {
                            d ? d === 1 ? cl(a = Kd(Jn(a), t), t, r, n, l, p, 2) : d === 2 && Yd(a, t, r, n, l, p) : cl(Jn(a), t, r, n, l, p, 1);
                            break;
                        }
                    }
                }
                function Wd(a) {
                    const t = a.prev, r = a, n = a.next;
                    if (Vt(t, r, n) >= 0) return !1;
                    const l = t.x, p = r.x, d = n.x, m = t.y, _ = r.y, v = n.y, b = Math.min(l, p, d), S = Math.min(m, _, v), I = Math.max(l, p, d), A = Math.max(m, _, v);
                    let k = n.next;
                    for (; k !== t;) {
                        if (k.x >= b && k.x <= I && k.y >= S && k.y <= A && hl(l, m, p, _, d, v, k.x, k.y) && Vt(k.prev, k, k.next) >= 0) return !1;
                        k = k.next;
                    }
                    return !0;
                }
                function Xd(a, t, r, n) {
                    const l = a.prev, p = a, d = a.next;
                    if (Vt(l, p, d) >= 0) return !1;
                    const m = l.x, _ = p.x, v = d.x, b = l.y, S = p.y, I = d.y, A = Math.min(m, _, v), k = Math.min(b, S, I), D = Math.max(m, _, v), N = Math.max(b, S, I), G = Bh(A, k, t, r, n), ie = Bh(D, N, t, r, n);
                    let H = a.prevZ, C = a.nextZ;
                    for (; H && H.z >= G && C && C.z <= ie;) {
                        if (H.x >= A && H.x <= D && H.y >= k && H.y <= N && H !== l && H !== d && hl(m, b, _, S, v, I, H.x, H.y) && Vt(H.prev, H, H.next) >= 0 || (H = H.prevZ, C.x >= A && C.x <= D && C.y >= k && C.y <= N && C !== l && C !== d && hl(m, b, _, S, v, I, C.x, C.y) && Vt(C.prev, C, C.next) >= 0)) return !1;
                        C = C.nextZ;
                    }
                    for (; H && H.z >= G;) {
                        if (H.x >= A && H.x <= D && H.y >= k && H.y <= N && H !== l && H !== d && hl(m, b, _, S, v, I, H.x, H.y) && Vt(H.prev, H, H.next) >= 0) return !1;
                        H = H.prevZ;
                    }
                    for (; C && C.z <= ie;) {
                        if (C.x >= A && C.x <= D && C.y >= k && C.y <= N && C !== l && C !== d && hl(m, b, _, S, v, I, C.x, C.y) && Vt(C.prev, C, C.next) >= 0) return !1;
                        C = C.nextZ;
                    }
                    return !0;
                }
                function Kd(a, t) {
                    let r = a;
                    do {
                        const n = r.prev, l = r.next.next;
                        !Js(n, l) && Vu(n, r, r.next, l) && ul(n, l) && ul(l, n) && (t.push(n.i, r.i, l.i), pl(r), pl(r.next), r = a = l), r = r.next;
                    } while (r !== a);
                    return Jn(r);
                }
                function Yd(a, t, r, n, l, p) {
                    let d = a;
                    do {
                        let m = d.next.next;
                        for (; m !== d.prev;) {
                            if (d.i !== m.i && rf(d, m)) {
                                let _ = Zu(d, m);
                                return d = Jn(d, d.next), _ = Jn(_, _.next), cl(d, t, r, n, l, p, 0), void cl(_, t, r, n, l, p, 0);
                            }
                            m = m.next;
                        }
                        d = d.next;
                    } while (d !== a);
                }
                function Jd(a, t) {
                    let r = a.x - t.x;
                    return r === 0 && (r = a.y - t.y, r === 0) && (r = (a.next.y - a.y) / (a.next.x - a.x) - (t.next.y - t.y) / (t.next.x - t.x)), r;
                }
                function Qd(a, t) {
                    const r = function (l, p) {
                        let d = p;
                        const m = l.x, _ = l.y;
                        let v, b = -1 / 0;
                        if (Js(l, d)) return d;
                        do {
                            if (Js(l, d.next)) return d.next;
                            if (_ <= d.y && _ >= d.next.y && d.next.y !== d.y) {
                                const D = d.x + (_ - d.y) * (d.next.x - d.x) / (d.next.y - d.y);
                                if (D <= m && D > b && (b = D, v = d.x < d.next.x ? d : d.next, D === m)) return v;
                            }
                            d = d.next;
                        } while (d !== p);
                        if (!v) return null;
                        const S = v, I = v.x, A = v.y;
                        let k = 1 / 0;
                        d = v;
                        do {
                            if (m >= d.x && d.x >= I && m !== d.x && Uu(_ < A ? m : b, _, I, A, _ < A ? b : m, _, d.x, d.y)) {
                                const D = Math.abs(_ - d.y) / (m - d.x);
                                ul(d, l) && (D < k || D === k && (d.x > v.x || d.x === v.x && ef(v, d))) && (v = d, k = D);
                            }
                            d = d.next;
                        } while (d !== S);
                        return v;
                    }(a, t);
                    if (!r) return t;
                    const n = Zu(r, a);
                    return Jn(n, n.next), Jn(r, r.next);
                }
                function ef(a, t) {
                    return Vt(a.prev, a, t.prev) < 0 && Vt(t.next, a, a.next) < 0;
                }
                function Bh(a, t, r, n, l) {
                    return (a = 1431655765 & ((a = 858993459 & ((a = 252645135 & ((a = 16711935 & ((a = (a - r) * l | 0) | a << 8)) | a << 4)) | a << 2)) | a << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * l | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
                }
                function tf(a) {
                    let t = a, r = a;
                    do
                        (t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next;
                    while (t !== a);
                    return r;
                }
                function Uu(a, t, r, n, l, p, d, m) {
                    return (l - d) * (t - m) >= (a - d) * (p - m) && (a - d) * (n - m) >= (r - d) * (t - m) && (r - d) * (p - m) >= (l - d) * (n - m);
                }
                function hl(a, t, r, n, l, p, d, m) {
                    return !(a === d && t === m) && Uu(a, t, r, n, l, p, d, m);
                }
                function rf(a, t) {
                    return a.next.i !== t.i && a.prev.i !== t.i && !function (r, n) {
                        let l = r;
                        do {
                            if (l.i !== r.i && l.next.i !== r.i && l.i !== n.i && l.next.i !== n.i && Vu(l, l.next, r, n)) return !0;
                            l = l.next;
                        } while (l !== r);
                        return !1;
                    }(a, t) && (ul(a, t) && ul(t, a) && function (r, n) {
                        let l = r, p = !1;
                        const d = (r.x + n.x) / 2, m = (r.y + n.y) / 2;
                        do
                            l.y > m != l.next.y > m && l.next.y !== l.y && d < (l.next.x - l.x) * (m - l.y) / (l.next.y - l.y) + l.x && (p = !p), l = l.next;
                        while (l !== r);
                        return p;
                    }(a, t) && (Vt(a.prev, a, t.prev) || Vt(a, t.prev, t)) || Js(a, t) && Vt(a.prev, a, a.next) > 0 && Vt(t.prev, t, t.next) > 0);
                }
                function Vt(a, t, r) {
                    return (t.y - a.y) * (r.x - t.x) - (t.x - a.x) * (r.y - t.y);
                }
                function Js(a, t) {
                    return a.x === t.x && a.y === t.y;
                }
                function Vu(a, t, r, n) {
                    const l = zc(Vt(a, t, r)), p = zc(Vt(a, t, n)), d = zc(Vt(r, n, a)), m = zc(Vt(r, n, t));
                    return l !== p && d !== m || !(l !== 0 || !kc(a, r, t)) || !(p !== 0 || !kc(a, n, t)) || !(d !== 0 || !kc(r, a, n)) || !(m !== 0 || !kc(r, t, n));
                }
                function kc(a, t, r) {
                    return t.x <= Math.max(a.x, r.x) && t.x >= Math.min(a.x, r.x) && t.y <= Math.max(a.y, r.y) && t.y >= Math.min(a.y, r.y);
                }
                function zc(a) {
                    return a > 0 ? 1 : a < 0 ? -1 : 0;
                }
                function ul(a, t) {
                    return Vt(a.prev, a, a.next) < 0 ? Vt(a, t, a.next) >= 0 && Vt(a, a.prev, t) >= 0 : Vt(a, t, a.prev) < 0 || Vt(a, a.next, t) < 0;
                }
                function Zu(a, t) {
                    const r = Fh(a.i, a.x, a.y), n = Fh(t.i, t.x, t.y), l = a.next, p = t.prev;
                    return a.next = t, t.prev = a, r.next = l, l.prev = r, n.next = r, r.prev = n, p.next = n, n.prev = p, n;
                }
                function Gu(a, t, r, n) {
                    const l = Fh(a, t, r);
                    return n ? (l.next = n.next, l.prev = n, n.next.prev = l, n.next = l) : (l.prev = l, l.next = l), l;
                }
                function pl(a) {
                    a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ);
                }
                function Fh(a, t, r) {
                    return { i: a, x: t, y: r, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
                }
                class Qs {
                    constructor(t, r) {
                        if (r > t) throw new Error("Min granularity must not be greater than base granularity.");
                        this._baseZoomGranularity = t, this._minGranularity = r;
                    }
                    getGranularityForZoomLevel(t) {
                        return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1);
                    }
                }
                class Ec {
                    constructor(t) {
                        this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle;
                    }
                }
                Ec.noSubdivision = new Ec({ fill: new Qs(0, 0), line: new Qs(0, 0), tile: new Qs(0, 0), stencil: new Qs(0, 0), circle: 1 }), Le("SubdivisionGranularityExpression", Qs), Le("SubdivisionGranularitySetting", Ec);
                const eo = -32768, dl = 32767;
                class af {
                    constructor(t, r) {
                        this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = t, this._granularityCellSize = yt / t, this._canonical = r;
                    }
                    _getKey(t, r) {
                        return (t += 32768) << 16 | (r += 32768) << 0;
                    }
                    _vertexToIndex(t, r) {
                        if (t < -32768 || r < -32768 || t > 32767 || r > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
                        const n = 0 | Math.round(t), l = 0 | Math.round(r), p = this._getKey(n, l);
                        if (this._vertexDictionary.has(p)) return this._vertexDictionary.get(p);
                        const d = this._vertexBuffer.length / 2;
                        return this._vertexDictionary.set(p, d), this._vertexBuffer.push(n, l), d;
                    }
                    _subdivideTrianglesScanline(t) {
                        if (this._granularity < 2) return function (l, p) {
                            const d = [];
                            for (let m = 0; m < p.length; m += 3) {
                                const _ = p[m], v = p[m + 1], b = p[m + 2], S = l[2 * _], I = l[2 * _ + 1];
                                (l[2 * v] - S) * (l[2 * b + 1] - I) - (l[2 * v + 1] - I) * (l[2 * b] - S) > 0 ? (d.push(_), d.push(b), d.push(v)) : (d.push(_), d.push(v), d.push(b));
                            }
                            return d;
                        }(this._vertexBuffer, t);
                        const r = [], n = t.length;
                        for (let l = 0; l < n; l += 3) {
                            const p = [t[l + 0], t[l + 1], t[l + 2]], d = [this._vertexBuffer[2 * t[l + 0] + 0], this._vertexBuffer[2 * t[l + 0] + 1], this._vertexBuffer[2 * t[l + 1] + 0], this._vertexBuffer[2 * t[l + 1] + 1], this._vertexBuffer[2 * t[l + 2] + 0], this._vertexBuffer[2 * t[l + 2] + 1]];
                            let m = 1 / 0, _ = 1 / 0, v = -1 / 0, b = -1 / 0;
                            for (let D = 0; D < 3; D++) {
                                const N = d[2 * D], G = d[2 * D + 1];
                                m = Math.min(m, N), v = Math.max(v, N), _ = Math.min(_, G), b = Math.max(b, G);
                            }
                            if (m === v || _ === b) continue;
                            const S = Math.floor(m / this._granularityCellSize), I = Math.ceil(v / this._granularityCellSize), A = Math.floor(_ / this._granularityCellSize), k = Math.ceil(b / this._granularityCellSize);
                            if (S !== I || A !== k) for (let D = A; D < k; D++) {
                                const N = this._scanlineGenerateVertexRingForCellRow(D, d, p);
                                nf(this._vertexBuffer, N, r);
                            }
                            else r.push(...p);
                        }
                        return r;
                    }
                    _scanlineGenerateVertexRingForCellRow(t, r, n) {
                        const l = t * this._granularityCellSize, p = l + this._granularityCellSize, d = [];
                        for (let m = 0; m < 3; m++) {
                            const _ = r[2 * m], v = r[2 * m + 1], b = r[2 * (m + 1) % 6], S = r[(2 * (m + 1) + 1) % 6], I = r[2 * (m + 2) % 6], A = r[(2 * (m + 2) + 1) % 6], k = b - _, D = S - v, N = k === 0, G = D === 0, ie = (l - v) / D, H = (p - v) / D, C = Math.min(ie, H), F = Math.max(ie, H);
                            if (!G && (C >= 1 || F <= 0) || G && (v < l || v > p)) {
                                S >= l && S <= p && d.push(n[(m + 1) % 3]);
                                continue;
                            }
                            !G && C > 0 && d.push(this._vertexToIndex(_ + k * C, v + D * C));
                            const X = _ + k * Math.max(C, 0), ue = _ + k * Math.min(F, 1);
                            N || this._generateIntraEdgeVertices(d, _, v, b, S, X, ue), !G && F < 1 && d.push(this._vertexToIndex(_ + k * F, v + D * F)), (G || S >= l && S <= p) && d.push(n[(m + 1) % 3]), !G && (S <= l || S >= p) && this._generateInterEdgeVertices(d, _, v, b, S, I, A, ue, l, p);
                        }
                        return d;
                    }
                    _generateIntraEdgeVertices(t, r, n, l, p, d, m) {
                        const _ = l - r, v = p - n, b = v === 0, S = b ? Math.min(r, l) : Math.min(d, m), I = b ? Math.max(r, l) : Math.max(d, m), A = Math.floor(S / this._granularityCellSize) + 1, k = Math.ceil(I / this._granularityCellSize) - 1;
                        if (b ? r < l : d < m) for (let D = A; D <= k; D++) {
                            const N = D * this._granularityCellSize;
                            t.push(this._vertexToIndex(N, n + v * (N - r) / _));
                        }
                        else for (let D = k; D >= A; D--) {
                            const N = D * this._granularityCellSize;
                            t.push(this._vertexToIndex(N, n + v * (N - r) / _));
                        }
                    }
                    _generateInterEdgeVertices(t, r, n, l, p, d, m, _, v, b) {
                        const S = p - n, I = d - l, A = m - p, k = (v - p) / A, D = (b - p) / A, N = Math.min(k, D), G = Math.max(k, D), ie = l + I * N;
                        let H = Math.floor(Math.min(ie, _) / this._granularityCellSize) + 1, C = Math.ceil(Math.max(ie, _) / this._granularityCellSize) - 1, F = _ < ie;
                        const X = A === 0;
                        if (X && (m === v || m === b)) return;
                        if (X || N >= 1 || G <= 0) {
                            const Me = n - m, me = d + (r - d) * Math.min((v - m) / Me, (b - m) / Me);
                            H = Math.floor(Math.min(me, _) / this._granularityCellSize) + 1, C = Math.ceil(Math.max(me, _) / this._granularityCellSize) - 1, F = _ < me;
                        }
                        const ue = S > 0 ? b : v;
                        if (F) for (let Me = H; Me <= C; Me++) t.push(this._vertexToIndex(Me * this._granularityCellSize, ue));
                        else for (let Me = C; Me >= H; Me--) t.push(this._vertexToIndex(Me * this._granularityCellSize, ue));
                    }
                    _generateOutline(t) {
                        const r = [];
                        for (const n of t) {
                            const l = Qn(n, this._granularity, !0), p = this._pointArrayToIndices(l), d = [];
                            for (let m = 1; m < p.length; m++) d.push(p[m - 1]), d.push(p[m]);
                            r.push(d);
                        }
                        return r;
                    }
                    _handlePoles(t) {
                        let r = !1, n = !1;
                        this._canonical && (this._canonical.y === 0 && (r = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (n = !0)), (r || n) && this._fillPoles(t, r, n);
                    }
                    _ensureNoPoleVertices() {
                        const t = this._vertexBuffer;
                        for (let r = 0; r < t.length; r += 2) {
                            const n = t[r + 1];
                            n === eo && (t[r + 1] = -32767), n === dl && (t[r + 1] = 32766);
                        }
                    }
                    _generatePoleQuad(t, r, n, l, p, d) {
                        l > p != (d === eo) ? (t.push(r), t.push(n), t.push(this._vertexToIndex(l, d)), t.push(n), t.push(this._vertexToIndex(p, d)), t.push(this._vertexToIndex(l, d))) : (t.push(n), t.push(r), t.push(this._vertexToIndex(l, d)), t.push(this._vertexToIndex(p, d)), t.push(n), t.push(this._vertexToIndex(l, d)));
                    }
                    _fillPoles(t, r, n) {
                        const l = this._vertexBuffer, p = yt, d = t.length;
                        for (let m = 2; m < d; m += 3) {
                            const _ = t[m - 2], v = t[m - 1], b = t[m], S = l[2 * _], I = l[2 * _ + 1], A = l[2 * v], k = l[2 * v + 1], D = l[2 * b], N = l[2 * b + 1];
                            r && (I === 0 && k === 0 && this._generatePoleQuad(t, _, v, S, A, eo), k === 0 && N === 0 && this._generatePoleQuad(t, v, b, A, D, eo), N === 0 && I === 0 && this._generatePoleQuad(t, b, _, D, S, eo)), n && (I === p && k === p && this._generatePoleQuad(t, _, v, S, A, dl), k === p && N === p && this._generatePoleQuad(t, v, b, A, D, dl), N === p && I === p && this._generatePoleQuad(t, b, _, D, S, dl));
                        }
                    }
                    _initializeVertices(t) {
                        for (let r = 0; r < t.length; r += 2) this._vertexToIndex(t[r], t[r + 1]);
                    }
                    subdividePolygonInternal(t, r) {
                        if (this._used) throw new Error("Subdivision: multiple use not allowed.");
                        this._used = !0;
                        const { flattened: n, holeIndices: l } = function (m) {
                            const _ = [], v = [];
                            for (const b of m) if (b.length !== 0) {
                                b !== m[0] && _.push(v.length / 2);
                                for (let S = 0; S < b.length; S++) v.push(b[S].x), v.push(b[S].y);
                            }
                            return { flattened: v, holeIndices: _ };
                        }(t);
                        let p;
                        this._initializeVertices(n);
                        try {
                            const m = function (v, b, S = 2) {
                                const I = b && b.length, A = I ? b[0] * S : v.length;
                                let k = $u(v, 0, A, S, !0);
                                const D = [];
                                if (!k || k.next === k.prev) return D;
                                let N, G, ie;
                                if (I && (k = function (H, C, F, X) {
                                    const ue = [];
                                    for (let Me = 0, me = C.length; Me < me; Me++) {
                                        const xe = $u(H, C[Me] * X, Me < me - 1 ? C[Me + 1] * X : H.length, X, !1);
                                        xe === xe.next && (xe.steiner = !0), ue.push(tf(xe));
                                    }
                                    ue.sort(Jd);
                                    for (let Me = 0; Me < ue.length; Me++) F = Qd(ue[Me], F);
                                    return F;
                                }(v, b, k, S)), v.length > 80 * S) {
                                    N = 1 / 0, G = 1 / 0;
                                    let H = -1 / 0, C = -1 / 0;
                                    for (let F = S; F < A; F += S) {
                                        const X = v[F], ue = v[F + 1];
                                        X < N && (N = X), ue < G && (G = ue), X > H && (H = X), ue > C && (C = ue);
                                    }
                                    ie = Math.max(H - N, C - G), ie = ie !== 0 ? 32767 / ie : 0;
                                }
                                return cl(k, D, S, N, G, ie, 0), D;
                            }(n, l), _ = this._convertIndices(n, m);
                            p = this._subdivideTrianglesScanline(_);
                        } catch (m) {
                            console.error(m);
                        }
                        let d = [];
                        return r && (d = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(p), { verticesFlattened: this._vertexBuffer, indicesTriangles: p, indicesLineList: d };
                    }
                    _convertIndices(t, r) {
                        const n = [];
                        for (let l = 0; l < r.length; l++) n.push(this._vertexToIndex(t[2 * r[l]], t[2 * r[l] + 1]));
                        return n;
                    }
                    _pointArrayToIndices(t) {
                        const r = [];
                        for (let n = 0; n < t.length; n++) {
                            const l = t[n];
                            r.push(this._vertexToIndex(l.x, l.y));
                        }
                        return r;
                    }
                }
                function qu(a, t, r, n = !0) {
                    return new af(r, t).subdividePolygonInternal(a, n);
                }
                function Qn(a, t, r = !1) {
                    if (!a || a.length < 1) return [];
                    if (a.length < 2) return [];
                    const n = a[0], l = a[a.length - 1], p = r && (n.x !== l.x || n.y !== l.y);
                    if (t < 2) return p ? [...a, a[0]] : [...a];
                    const d = Math.floor(yt / t), m = [];
                    m.push(new $e(a[0].x, a[0].y));
                    const _ = a.length, v = p ? _ : _ - 1;
                    for (let b = 0; b < v; b++) {
                        const S = a[b], I = b < _ - 1 ? a[b + 1] : a[0], A = S.x, k = S.y, D = I.x, N = I.y, G = A !== D, ie = k !== N;
                        if (!G && !ie) continue;
                        const H = D - A, C = N - k, F = Math.abs(H), X = Math.abs(C);
                        let ue = A, Me = k;
                        for (; ;) {
                            const xe = H > 0 ? (Math.floor(ue / d) + 1) * d : (Math.ceil(ue / d) - 1) * d, Ae = C > 0 ? (Math.floor(Me / d) + 1) * d : (Math.ceil(Me / d) - 1) * d, Ie = Math.abs(ue - xe), ke = Math.abs(Me - Ae), we = Math.abs(ue - D), Be = Math.abs(Me - N), Ge = G ? Ie / F : Number.POSITIVE_INFINITY, Ve = ie ? ke / X : Number.POSITIVE_INFINITY;
                            if ((we <= Ie || !G) && (Be <= ke || !ie)) break;
                            if (Ge < Ve && G || !ie) {
                                ue = xe, Me += C * Ge;
                                const Oe = new $e(ue, Math.round(Me));
                                m[m.length - 1].x === Oe.x && m[m.length - 1].y === Oe.y || m.push(Oe);
                            } else {
                                ue += H * Ve, Me = Ae;
                                const Oe = new $e(Math.round(ue), Me);
                                m[m.length - 1].x === Oe.x && m[m.length - 1].y === Oe.y || m.push(Oe);
                            }
                        }
                        const me = new $e(D, N);
                        m[m.length - 1].x === me.x && m[m.length - 1].y === me.y || m.push(me);
                    }
                    return m;
                }
                function nf(a, t, r) {
                    if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
                    let n = 0, l = a[2 * t[0]];
                    for (let _ = 1; _ < t.length; _++) {
                        const v = a[2 * t[_]];
                        v < l && (l = v, n = _);
                    }
                    const p = t.length;
                    let d = n, m = (d + 1) % p;
                    for (; ;) {
                        const _ = d - 1 >= 0 ? d - 1 : p - 1, v = (m + 1) % p, b = a[2 * t[_]], S = a[2 * t[v]], I = a[2 * t[d]], A = a[2 * t[d] + 1], k = a[2 * t[m] + 1];
                        let D = !1;
                        if (b < S) D = !0;
                        else if (b > S) D = !1;
                        else {
                            const N = k - A, G = -(a[2 * t[m]] - I), ie = A < k ? 1 : -1;
                            ((b - I) * N + (a[2 * t[_] + 1] - A) * G) * ie > ((S - I) * N + (a[2 * t[v] + 1] - A) * G) * ie && (D = !0);
                        }
                        if (D) {
                            const N = t[_], G = t[d], ie = t[m];
                            N !== G && N !== ie && G !== ie && r.push(ie, G, N), d--, d < 0 && (d = p - 1);
                        } else {
                            const N = t[v], G = t[d], ie = t[m];
                            N !== G && N !== ie && G !== ie && r.push(ie, G, N), m++, m >= p && (m = 0);
                        }
                        if (_ === v) break;
                    }
                }
                function Hu(a, t, r, n, l, p, d, m, _) {
                    const v = l.length / 2, b = d && m && _;
                    if (v < mt.MAX_VERTEX_ARRAY_LENGTH) {
                        const S = t.prepareSegment(v, r, n), I = S.vertexLength;
                        for (let D = 0; D < p.length; D += 3) n.emplaceBack(I + p[D], I + p[D + 1], I + p[D + 2]);
                        let A, k;
                        S.vertexLength += v, S.primitiveLength += p.length / 3, b && (k = d.prepareSegment(v, r, m), A = k.vertexLength, k.vertexLength += v);
                        for (let D = 0; D < l.length; D += 2) a(l[D], l[D + 1]);
                        if (b) for (let D = 0; D < _.length; D++) {
                            const N = _[D];
                            for (let G = 1; G < N.length; G += 2) m.emplaceBack(A + N[G - 1], A + N[G]);
                            k.primitiveLength += N.length / 2;
                        }
                    } else (function (S, I, A, k, D, N) {
                        const G = [];
                        for (let X = 0; X < k.length / 2; X++) G.push(-1);
                        const ie = { count: 0 };
                        let H = 0, C = S.getOrCreateLatestSegment(I, A), F = C.vertexLength;
                        for (let X = 2; X < D.length; X += 3) {
                            const ue = D[X - 2], Me = D[X - 1], me = D[X];
                            let xe = G[ue] < H, Ae = G[Me] < H, Ie = G[me] < H;
                            C.vertexLength + ((xe ? 1 : 0) + (Ae ? 1 : 0) + (Ie ? 1 : 0)) > mt.MAX_VERTEX_ARRAY_LENGTH && (C = S.createNewSegment(I, A), H = ie.count, xe = !0, Ae = !0, Ie = !0, F = 0);
                            const ke = fl(G, k, N, ie, ue, xe, C), we = fl(G, k, N, ie, Me, Ae, C), Be = fl(G, k, N, ie, me, Ie, C);
                            A.emplaceBack(F + ke - H, F + we - H, F + Be - H), C.primitiveLength++;
                        }
                    })(t, r, n, l, p, a), b && function (S, I, A, k, D, N) {
                        const G = [];
                        for (let X = 0; X < k.length / 2; X++) G.push(-1);
                        const ie = { count: 0 };
                        let H = 0, C = S.getOrCreateLatestSegment(I, A), F = C.vertexLength;
                        for (let X = 0; X < D.length; X++) {
                            const ue = D[X];
                            for (let Me = 1; Me < D[X].length; Me += 2) {
                                const me = ue[Me - 1], xe = ue[Me];
                                let Ae = G[me] < H, Ie = G[xe] < H;
                                C.vertexLength + ((Ae ? 1 : 0) + (Ie ? 1 : 0)) > mt.MAX_VERTEX_ARRAY_LENGTH && (C = S.createNewSegment(I, A), H = ie.count, Ae = !0, Ie = !0, F = 0);
                                const ke = fl(G, k, N, ie, me, Ae, C), we = fl(G, k, N, ie, xe, Ie, C);
                                A.emplaceBack(F + ke - H, F + we - H), C.primitiveLength++;
                            }
                        }
                    }(d, r, m, l, _, a), t.forceNewSegmentOnNextPrepare(), d == null || d.forceNewSegmentOnNextPrepare();
                }
                function fl(a, t, r, n, l, p, d) {
                    if (p) {
                        const m = n.count;
                        return r(t[2 * l], t[2 * l + 1]), a[l] = n.count, n.count++, d.vertexLength++, m;
                    }
                    return a[l];
                }
                class Nh {
                    constructor(t) {
                        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r) => r.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new ze(), this.indexArray = new ft(), this.indexArray2 = new Kt(), this.programConfigurations = new Xr(t.layers, t.zoom), this.segments = new mt(), this.segments2 = new mt(), this.stateDependentLayerIds = this.layers.filter((r) => r.isStateDependent()).map((r) => r.id);
                    }
                    populate(t, r, n) {
                        this.hasPattern = Dh("fill", this.layers, r);
                        const l = this.layers[0].layout.get("fill-sort-key"), p = !l.isConstant(), d = [];
                        for (const { feature: m, id: _, index: v, sourceLayerIndex: b } of t) {
                            const S = this.layers[0]._featureFilter.needGeometry, I = Kn(m, S);
                            if (!this.layers[0]._featureFilter.filter(new Tt(this.zoom), I, n)) continue;
                            const A = p ? l.evaluate(I, {}, n, r.availableImages) : void 0, k = { id: _, properties: m.properties, type: m.type, sourceLayerIndex: b, index: v, geometry: S ? I.geometry : Xn(m), patterns: {}, sortKey: A };
                            d.push(k);
                        }
                        p && d.sort((m, _) => m.sortKey - _.sortKey);
                        for (const m of d) {
                            const { geometry: _, index: v, sourceLayerIndex: b } = m;
                            if (this.hasPattern) {
                                const S = Lh("fill", this.layers, m, this.zoom, r);
                                this.patternFeatures.push(S);
                            } else this.addFeature(m, _, v, n, {}, r.subdivisionGranularity);
                            r.featureIndex.insert(t[v].feature, _, v, b, this.index);
                        }
                    }
                    update(t, r, n) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, n);
                    }
                    addFeatures(t, r, n) {
                        for (const l of this.patternFeatures) this.addFeature(l, l.geometry, l.index, r, n, t.subdivisionGranularity);
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0;
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload;
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Hd), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
                    }
                    addFeature(t, r, n, l, p, d) {
                        for (const m of ws(r, 500)) {
                            const _ = qu(m, l, d.fill.getGranularityForZoomLevel(l.z)), v = this.layoutVertexArray;
                            Hu((b, S) => {
                                v.emplaceBack(b, S);
                            }, this.segments, this.layoutVertexArray, this.indexArray, _.verticesFlattened, _.indicesTriangles, this.segments2, this.indexArray2, _.indicesLineList);
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, p, l);
                    }
                }
                let Wu, Xu;
                Le("FillBucket", Nh, { omit: ["layers", "patternFeatures"] });
                var sf = {
                    get paint() {
                        return Xu = Xu || new Gt({ "fill-antialias": new je(O.paint_fill["fill-antialias"]), "fill-opacity": new He(O.paint_fill["fill-opacity"]), "fill-color": new He(O.paint_fill["fill-color"]), "fill-outline-color": new He(O.paint_fill["fill-outline-color"]), "fill-translate": new je(O.paint_fill["fill-translate"]), "fill-translate-anchor": new je(O.paint_fill["fill-translate-anchor"]), "fill-pattern": new Zn(O.paint_fill["fill-pattern"]) });
                    }, get layout() {
                        return Wu = Wu || new Gt({ "fill-sort-key": new He(O.layout_fill["fill-sort-key"]) });
                    }
                };
                class of extends Xi {
                    constructor(t) {
                        super(t, sf);
                    }
                    recalculate(t, r) {
                        super.recalculate(t, r);
                        const n = this.paint._values["fill-outline-color"];
                        n.value.kind === "constant" && n.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
                    }
                    createBucket(t) {
                        return new Nh(t);
                    }
                    queryRadius() {
                        return Cc(this.paint.get("fill-translate"));
                    }
                    queryIntersectsFeature({ queryGeometry: t, geometry: r, transform: n, pixelsToTileUnits: l }) {
                        return ku(Ac(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -n.bearingInRadians, l), r);
                    }
                    isTileClipped() {
                        return !0;
                    }
                }
                const lf = Ct([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), cf = Ct([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: hf } = lf;
                var Oh, Ku, jh, Yu, $h, Ju, Qu, Rc = {};
                function ep() {
                    if (Ku) return Oh;
                    Ku = 1;
                    var a = ct();
                    function t(l, p, d, m, _) {
                        this.properties = {}, this.extent = d, this.type = 0, this._pbf = l, this._geometry = -1, this._keys = m, this._values = _, l.readFields(r, this, p);
                    }
                    function r(l, p, d) {
                        l == 1 ? p.id = d.readVarint() : l == 2 ? function (m, _) {
                            for (var v = m.readVarint() + m.pos; m.pos < v;) {
                                var b = _._keys[m.readVarint()], S = _._values[m.readVarint()];
                                _.properties[b] = S;
                            }
                        }(d, p) : l == 3 ? p.type = d.readVarint() : l == 4 && (p._geometry = d.pos);
                    }
                    function n(l) {
                        for (var p, d, m = 0, _ = 0, v = l.length, b = v - 1; _ < v; b = _++) m += ((d = l[b]).x - (p = l[_]).x) * (p.y + d.y);
                        return m;
                    }
                    return Oh = t, t.types = ["Unknown", "Point", "LineString", "Polygon"], t.prototype.loadGeometry = function () {
                        var l = this._pbf;
                        l.pos = this._geometry;
                        for (var p, d = l.readVarint() + l.pos, m = 1, _ = 0, v = 0, b = 0, S = []; l.pos < d;) {
                            if (_ <= 0) {
                                var I = l.readVarint();
                                m = 7 & I, _ = I >> 3;
                            }
                            if (_--, m === 1 || m === 2) v += l.readSVarint(), b += l.readSVarint(), m === 1 && (p && S.push(p), p = []), p.push(new a(v, b));
                            else {
                                if (m !== 7) throw new Error("unknown command " + m);
                                p && p.push(p[0].clone());
                            }
                        }
                        return p && S.push(p), S;
                    }, t.prototype.bbox = function () {
                        var l = this._pbf;
                        l.pos = this._geometry;
                        for (var p = l.readVarint() + l.pos, d = 1, m = 0, _ = 0, v = 0, b = 1 / 0, S = -1 / 0, I = 1 / 0, A = -1 / 0; l.pos < p;) {
                            if (m <= 0) {
                                var k = l.readVarint();
                                d = 7 & k, m = k >> 3;
                            }
                            if (m--, d === 1 || d === 2) (_ += l.readSVarint()) < b && (b = _), _ > S && (S = _), (v += l.readSVarint()) < I && (I = v), v > A && (A = v);
                            else if (d !== 7) throw new Error("unknown command " + d);
                        }
                        return [b, I, S, A];
                    }, t.prototype.toGeoJSON = function (l, p, d) {
                        var m, _, v = this.extent * Math.pow(2, d), b = this.extent * l, S = this.extent * p, I = this.loadGeometry(), A = t.types[this.type];
                        function k(G) {
                            for (var ie = 0; ie < G.length; ie++) {
                                var H = G[ie];
                                G[ie] = [360 * (H.x + b) / v - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (H.y + S) / v) * Math.PI / 180)) - 90];
                            }
                        }
                        switch (this.type) {
                            case 1:
                                var D = [];
                                for (m = 0; m < I.length; m++) D[m] = I[m][0];
                                k(I = D);
                                break;
                            case 2:
                                for (m = 0; m < I.length; m++) k(I[m]);
                                break;
                            case 3:
                                for (I = function (G) {
                                    var ie = G.length;
                                    if (ie <= 1) return [G];
                                    for (var H, C, F = [], X = 0; X < ie; X++) {
                                        var ue = n(G[X]);
                                        ue !== 0 && (C === void 0 && (C = ue < 0), C === ue < 0 ? (H && F.push(H), H = [G[X]]) : H.push(G[X]));
                                    }
                                    return H && F.push(H), F;
                                }(I), m = 0; m < I.length; m++) for (_ = 0; _ < I[m].length; _++) k(I[m][_]);
                        }
                        I.length === 1 ? I = I[0] : A = "Multi" + A;
                        var N = { type: "Feature", geometry: { type: A, coordinates: I }, properties: this.properties };
                        return "id" in this && (N.id = this.id), N;
                    }, Oh;
                }
                function tp() {
                    if (Yu) return jh;
                    Yu = 1;
                    var a = ep();
                    function t(n, l) {
                        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = n, this._keys = [], this._values = [], this._features = [], n.readFields(r, this, l), this.length = this._features.length;
                    }
                    function r(n, l, p) {
                        n === 15 ? l.version = p.readVarint() : n === 1 ? l.name = p.readString() : n === 5 ? l.extent = p.readVarint() : n === 2 ? l._features.push(p.pos) : n === 3 ? l._keys.push(p.readString()) : n === 4 && l._values.push(function (d) {
                            for (var m = null, _ = d.readVarint() + d.pos; d.pos < _;) {
                                var v = d.readVarint() >> 3;
                                m = v === 1 ? d.readString() : v === 2 ? d.readFloat() : v === 3 ? d.readDouble() : v === 4 ? d.readVarint64() : v === 5 ? d.readVarint() : v === 6 ? d.readSVarint() : v === 7 ? d.readBoolean() : null;
                            }
                            return m;
                        }(p));
                    }
                    return jh = t, t.prototype.feature = function (n) {
                        if (n < 0 || n >= this._features.length) throw new Error("feature index out of bounds");
                        this._pbf.pos = this._features[n];
                        var l = this._pbf.readVarint() + this._pbf.pos;
                        return new a(this._pbf, l, this.extent, this._keys, this._values);
                    }, jh;
                }
                function ip() {
                    return Qu || (Qu = 1, Rc.VectorTile = function () {
                        if (Ju) return $h;
                        Ju = 1;
                        var a = tp();
                        function t(r, n, l) {
                            if (r === 3) {
                                var p = new a(l, l.readVarint() + l.pos);
                                p.length && (n[p.name] = p);
                            }
                        }
                        return $h = function (r, n) {
                            this.layers = r.readFields(t, {}, n);
                        }, $h;
                    }(), Rc.VectorTileFeature = ep(), Rc.VectorTileLayer = tp()), Rc;
                }
                var ml = Fe(ip());
                const uf = ml.VectorTileFeature.types, Uh = Math.pow(2, 13);
                function gl(a, t, r, n, l, p, d, m) {
                    a.emplaceBack(t, r, 2 * Math.floor(n * Uh) + d, l * Uh * 2, p * Uh * 2, Math.round(m));
                }
                class Vh {
                    constructor(t) {
                        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r) => r.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Ce(), this.centroidVertexArray = new ye(), this.indexArray = new ft(), this.programConfigurations = new Xr(t.layers, t.zoom), this.segments = new mt(), this.stateDependentLayerIds = this.layers.filter((r) => r.isStateDependent()).map((r) => r.id);
                    }
                    populate(t, r, n) {
                        this.features = [], this.hasPattern = Dh("fill-extrusion", this.layers, r);
                        for (const { feature: l, id: p, index: d, sourceLayerIndex: m } of t) {
                            const _ = this.layers[0]._featureFilter.needGeometry, v = Kn(l, _);
                            if (!this.layers[0]._featureFilter.filter(new Tt(this.zoom), v, n)) continue;
                            const b = { id: p, sourceLayerIndex: m, index: d, geometry: _ ? v.geometry : Xn(l), properties: l.properties, type: l.type, patterns: {} };
                            this.hasPattern ? this.features.push(Lh("fill-extrusion", this.layers, b, this.zoom, r)) : this.addFeature(b, b.geometry, d, n, {}, r.subdivisionGranularity), r.featureIndex.insert(l, b.geometry, d, m, this.index, !0);
                        }
                    }
                    addFeatures(t, r, n) {
                        for (const l of this.features) {
                            const { geometry: p } = l;
                            this.addFeature(l, p, l.index, r, n, t.subdivisionGranularity);
                        }
                    }
                    update(t, r, n) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, n);
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload;
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, hf), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, cf.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
                    }
                    addFeature(t, r, n, l, p, d) {
                        for (const m of ws(r, 500)) {
                            const _ = { x: 0, y: 0, sampleCount: 0 }, v = this.layoutVertexArray.length;
                            this.processPolygon(_, l, t, m, d);
                            const b = this.layoutVertexArray.length - v, S = Math.floor(_.x / _.sampleCount), I = Math.floor(_.y / _.sampleCount);
                            for (let A = 0; A < b; A++) this.centroidVertexArray.emplaceBack(S, I);
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, p, l);
                    }
                    processPolygon(t, r, n, l, p) {
                        if (l.length < 1 || rp(l[0])) return;
                        for (const S of l) S.length !== 0 && pf(t, S);
                        const d = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, m = p.fill.getGranularityForZoomLevel(r.z), _ = uf[n.type] === "Polygon";
                        for (const S of l) {
                            if (S.length === 0 || rp(S)) continue;
                            const I = Qn(S, m, _);
                            this._generateSideFaces(I, d);
                        }
                        if (!_) return;
                        const v = qu(l, r, m, !1), b = this.layoutVertexArray;
                        Hu((S, I) => {
                            gl(b, S, I, 0, 0, 1, 1, 0);
                        }, this.segments, this.layoutVertexArray, this.indexArray, v.verticesFlattened, v.indicesTriangles);
                    }
                    _generateSideFaces(t, r) {
                        let n = 0;
                        for (let l = 1; l < t.length; l++) {
                            const p = t[l], d = t[l - 1];
                            if (df(p, d)) continue;
                            r.segment.vertexLength + 4 > mt.MAX_VERTEX_ARRAY_LENGTH && (r.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                            const m = p.sub(d)._perp()._unit(), _ = d.dist(p);
                            n + _ > 32768 && (n = 0), gl(this.layoutVertexArray, p.x, p.y, m.x, m.y, 0, 0, n), gl(this.layoutVertexArray, p.x, p.y, m.x, m.y, 0, 1, n), n += _, gl(this.layoutVertexArray, d.x, d.y, m.x, m.y, 0, 0, n), gl(this.layoutVertexArray, d.x, d.y, m.x, m.y, 0, 1, n);
                            const v = r.segment.vertexLength;
                            this.indexArray.emplaceBack(v, v + 2, v + 1), this.indexArray.emplaceBack(v + 1, v + 2, v + 3), r.segment.vertexLength += 4, r.segment.primitiveLength += 2;
                        }
                    }
                }
                function pf(a, t) {
                    for (let r = 0; r < t.length; r++) {
                        const n = t[r];
                        r === t.length - 1 && t[0].x === n.x && t[0].y === n.y || (a.x += n.x, a.y += n.y, a.sampleCount++);
                    }
                }
                function df(a, t) {
                    return a.x === t.x && (a.x < 0 || a.x > yt) || a.y === t.y && (a.y < 0 || a.y > yt);
                }
                function rp(a) {
                    return a.every((t) => t.x < 0) || a.every((t) => t.x > yt) || a.every((t) => t.y < 0) || a.every((t) => t.y > yt);
                }
                let ap;
                Le("FillExtrusionBucket", Vh, { omit: ["layers", "features"] });
                var ff = {
                    get paint() {
                        return ap = ap || new Gt({ "fill-extrusion-opacity": new je(O["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new He(O["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new je(O["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new je(O["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Zn(O["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new He(O["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new He(O["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new je(O["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
                    }
                };
                class mf extends Xi {
                    constructor(t) {
                        super(t, ff);
                    }
                    createBucket(t) {
                        return new Vh(t);
                    }
                    queryRadius() {
                        return Cc(this.paint.get("fill-extrusion-translate"));
                    }
                    is3D() {
                        return !0;
                    }
                    queryIntersectsFeature({ queryGeometry: t, feature: r, featureState: n, geometry: l, transform: p, pixelsToTileUnits: d, pixelPosMatrix: m }) {
                        const _ = Ac(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -p.bearingInRadians, d), v = this.paint.get("fill-extrusion-height").evaluate(r, n), b = this.paint.get("fill-extrusion-base").evaluate(r, n), S = function (A, k, D) {
                            const N = [];
                            for (const G of A) {
                                const ie = [G.x, G.y, 0, 1];
                                mi(ie, ie, k), N.push(new $e(ie[0] / ie[3], ie[1] / ie[3]));
                            }
                            return N;
                        }(_, m), I = function (A, k, D, N) {
                            const G = [], ie = [], H = N[8] * k, C = N[9] * k, F = N[10] * k, X = N[11] * k, ue = N[8] * D, Me = N[9] * D, me = N[10] * D, xe = N[11] * D;
                            for (const Ae of A) {
                                const Ie = [], ke = [];
                                for (const we of Ae) {
                                    const Be = we.x, Ge = we.y, Ve = N[0] * Be + N[4] * Ge + N[12], Oe = N[1] * Be + N[5] * Ge + N[13], at = N[2] * Be + N[6] * Ge + N[14], Ot = N[3] * Be + N[7] * Ge + N[15], Jt = at + F, xi = Ot + X, nr = Ve + ue, Vi = Oe + Me, pi = at + me, Et = Ot + xe, ri = new $e((Ve + H) / xi, (Oe + C) / xi);
                                    ri.z = Jt / xi, Ie.push(ri);
                                    const di = new $e(nr / Et, Vi / Et);
                                    di.z = pi / Et, ke.push(di);
                                }
                                G.push(Ie), ie.push(ke);
                            }
                            return [G, ie];
                        }(l, b, v, m);
                        return function (A, k, D) {
                            let N = 1 / 0;
                            ku(D, k) && (N = np(D, k[0]));
                            for (let G = 0; G < k.length; G++) {
                                const ie = k[G], H = A[G];
                                for (let C = 0; C < ie.length - 1; C++) {
                                    const F = ie[C], X = [F, ie[C + 1], H[C + 1], H[C], F];
                                    Au(D, X) && (N = Math.min(N, np(D, X)));
                                }
                            }
                            return N !== 1 / 0 && N;
                        }(I[0], I[1], S);
                    }
                }
                function _l(a, t) {
                    return a.x * t.x + a.y * t.y;
                }
                function np(a, t) {
                    if (a.length === 1) {
                        let r = 0;
                        const n = t[r++];
                        let l;
                        for (; !l || n.equals(l);) if (l = t[r++], !l) return 1 / 0;
                        for (; r < t.length; r++) {
                            const p = t[r], d = a[0], m = l.sub(n), _ = p.sub(n), v = d.sub(n), b = _l(m, m), S = _l(m, _), I = _l(_, _), A = _l(v, m), k = _l(v, _), D = b * I - S * S, N = (I * A - S * k) / D, G = (b * k - S * A) / D, ie = n.z * (1 - N - G) + l.z * N + p.z * G;
                            if (isFinite(ie)) return ie;
                        }
                        return 1 / 0;
                    }
                    {
                        let r = 1 / 0;
                        for (const n of t) r = Math.min(r, n.z);
                        return r;
                    }
                }
                const gf = Ct([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: _f } = gf, yf = Ct([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: vf } = yf, xf = ml.VectorTileFeature.types, bf = Math.cos(Math.PI / 180 * 37.5), sp = Math.pow(2, 14) / 0.5;
                class Zh {
                    constructor(t) {
                        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r) => r.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((r) => {
                            this.gradients[r.id] = {};
                        }), this.layoutVertexArray = new Ne(), this.layoutVertexArray2 = new tt(), this.indexArray = new ft(), this.programConfigurations = new Xr(t.layers, t.zoom), this.segments = new mt(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((r) => r.isStateDependent()).map((r) => r.id);
                    }
                    populate(t, r, n) {
                        this.hasPattern = Dh("line", this.layers, r);
                        const l = this.layers[0].layout.get("line-sort-key"), p = !l.isConstant(), d = [];
                        for (const { feature: m, id: _, index: v, sourceLayerIndex: b } of t) {
                            const S = this.layers[0]._featureFilter.needGeometry, I = Kn(m, S);
                            if (!this.layers[0]._featureFilter.filter(new Tt(this.zoom), I, n)) continue;
                            const A = p ? l.evaluate(I, {}, n) : void 0, k = { id: _, properties: m.properties, type: m.type, sourceLayerIndex: b, index: v, geometry: S ? I.geometry : Xn(m), patterns: {}, sortKey: A };
                            d.push(k);
                        }
                        p && d.sort((m, _) => m.sortKey - _.sortKey);
                        for (const m of d) {
                            const { geometry: _, index: v, sourceLayerIndex: b } = m;
                            if (this.hasPattern) {
                                const S = Lh("line", this.layers, m, this.zoom, r);
                                this.patternFeatures.push(S);
                            } else this.addFeature(m, _, v, n, {}, r.subdivisionGranularity);
                            r.featureIndex.insert(t[v].feature, _, v, b, this.index);
                        }
                    }
                    update(t, r, n) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, n);
                    }
                    addFeatures(t, r, n) {
                        for (const l of this.patternFeatures) this.addFeature(l, l.geometry, l.index, r, n, t.subdivisionGranularity);
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0;
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload;
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, vf)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, _f), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
                    }
                    lineFeatureClips(t) {
                        if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
                    }
                    addFeature(t, r, n, l, p, d) {
                        const m = this.layers[0].layout, _ = m.get("line-join").evaluate(t, {}), v = m.get("line-cap"), b = m.get("line-miter-limit"), S = m.get("line-round-limit");
                        this.lineClips = this.lineFeatureClips(t);
                        for (const I of r) this.addLine(I, t, _, v, b, S, l, d);
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, p, l);
                    }
                    addLine(t, r, n, l, p, d, m, _) {
                        if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = Qn(t, m ? _.line.getGranularityForZoomLevel(m.z) : 1), this.lineClips) {
                            this.lineClipsArray.push(this.lineClips);
                            for (let H = 0; H < t.length - 1; H++) this.totalDistance += t[H].dist(t[H + 1]);
                            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
                        }
                        const v = xf[r.type] === "Polygon";
                        let b = t.length;
                        for (; b >= 2 && t[b - 1].equals(t[b - 2]);) b--;
                        let S = 0;
                        for (; S < b - 1 && t[S].equals(t[S + 1]);) S++;
                        if (b < (v ? 3 : 2)) return;
                        n === "bevel" && (p = 1.05);
                        const I = this.overscaling <= 16 ? 15 * yt / (512 * this.overscaling) : 0, A = this.segments.prepareSegment(10 * b, this.layoutVertexArray, this.indexArray);
                        let k, D, N, G, ie;
                        this.e1 = this.e2 = -1, v && (k = t[b - 2], ie = t[S].sub(k)._unit()._perp());
                        for (let H = S; H < b; H++) {
                            if (N = H === b - 1 ? v ? t[S + 1] : void 0 : t[H + 1], N && t[H].equals(N)) continue;
                            ie && (G = ie), k && (D = k), k = t[H], ie = N ? N.sub(k)._unit()._perp() : G, G = G || ie;
                            let C = G.add(ie);
                            C.x === 0 && C.y === 0 || C._unit();
                            const F = G.x * ie.x + G.y * ie.y, X = C.x * ie.x + C.y * ie.y, ue = X !== 0 ? 1 / X : 1 / 0, Me = 2 * Math.sqrt(2 - 2 * X), me = X < bf && D && N, xe = G.x * ie.y - G.y * ie.x > 0;
                            if (me && H > S) {
                                const ke = k.dist(D);
                                if (ke > 2 * I) {
                                    const we = k.sub(k.sub(D)._mult(I / ke)._round());
                                    this.updateDistance(D, we), this.addCurrentVertex(we, G, 0, 0, A), D = we;
                                }
                            }
                            const Ae = D && N;
                            let Ie = Ae ? n : v ? "butt" : l;
                            if (Ae && Ie === "round" && (ue < d ? Ie = "miter" : ue <= 2 && (Ie = "fakeround")), Ie === "miter" && ue > p && (Ie = "bevel"), Ie === "bevel" && (ue > 2 && (Ie = "flipbevel"), ue < p && (Ie = "miter")), D && this.updateDistance(D, k), Ie === "miter") C._mult(ue), this.addCurrentVertex(k, C, 0, 0, A);
                            else if (Ie === "flipbevel") {
                                if (ue > 100) C = ie.mult(-1);
                                else {
                                    const ke = ue * G.add(ie).mag() / G.sub(ie).mag();
                                    C._perp()._mult(ke * (xe ? -1 : 1));
                                }
                                this.addCurrentVertex(k, C, 0, 0, A), this.addCurrentVertex(k, C.mult(-1), 0, 0, A);
                            } else if (Ie === "bevel" || Ie === "fakeround") {
                                const ke = -Math.sqrt(ue * ue - 1), we = xe ? ke : 0, Be = xe ? 0 : ke;
                                if (D && this.addCurrentVertex(k, G, we, Be, A), Ie === "fakeround") {
                                    const Ge = Math.round(180 * Me / Math.PI / 20);
                                    for (let Ve = 1; Ve < Ge; Ve++) {
                                        let Oe = Ve / Ge;
                                        if (Oe !== 0.5) {
                                            const Ot = Oe - 0.5;
                                            Oe += Oe * Ot * (Oe - 1) * ((1.0904 + F * (F * (3.55645 - 1.43519 * F) - 3.2452)) * Ot * Ot + (0.848013 + F * (0.215638 * F - 1.06021)));
                                        }
                                        const at = ie.sub(G)._mult(Oe)._add(G)._unit()._mult(xe ? -1 : 1);
                                        this.addHalfVertex(k, at.x, at.y, !1, xe, 0, A);
                                    }
                                }
                                N && this.addCurrentVertex(k, ie, -we, -Be, A);
                            } else if (Ie === "butt") this.addCurrentVertex(k, C, 0, 0, A);
                            else if (Ie === "square") {
                                const ke = D ? 1 : -1;
                                this.addCurrentVertex(k, C, ke, ke, A);
                            } else Ie === "round" && (D && (this.addCurrentVertex(k, G, 0, 0, A), this.addCurrentVertex(k, G, 1, 1, A, !0)), N && (this.addCurrentVertex(k, ie, -1, -1, A, !0), this.addCurrentVertex(k, ie, 0, 0, A)));
                            if (me && H < b - 1) {
                                const ke = k.dist(N);
                                if (ke > 2 * I) {
                                    const we = k.add(N.sub(k)._mult(I / ke)._round());
                                    this.updateDistance(k, we), this.addCurrentVertex(we, ie, 0, 0, A), k = we;
                                }
                            }
                        }
                    }
                    addCurrentVertex(t, r, n, l, p, d = !1) {
                        const m = r.y * l - r.x, _ = -r.y - r.x * l;
                        this.addHalfVertex(t, r.x + r.y * n, r.y - r.x * n, d, !1, n, p), this.addHalfVertex(t, m, _, d, !0, -l, p), this.distance > sp / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, r, n, l, p, d));
                    }
                    addHalfVertex({ x: t, y: r }, n, l, p, d, m, _) {
                        const v = 0.5 * (this.lineClips ? this.scaledDistance * (sp - 1) : this.scaledDistance);
                        this.layoutVertexArray.emplaceBack((t << 1) + (p ? 1 : 0), (r << 1) + (d ? 1 : 0), Math.round(63 * n) + 128, Math.round(63 * l) + 128, 1 + (m === 0 ? 0 : m < 0 ? -1 : 1) | (63 & v) << 2, v >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
                        const b = _.vertexLength++;
                        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, b, this.e2), _.primitiveLength++), d ? this.e2 = b : this.e1 = b;
                    }
                    updateScaledDistance() {
                        this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
                    }
                    updateDistance(t, r) {
                        this.distance += t.dist(r), this.updateScaledDistance();
                    }
                }
                let op, lp;
                Le("LineBucket", Zh, { omit: ["layers", "patternFeatures"] });
                var cp = {
                    get paint() {
                        return lp = lp || new Gt({ "line-opacity": new He(O.paint_line["line-opacity"]), "line-color": new He(O.paint_line["line-color"]), "line-translate": new je(O.paint_line["line-translate"]), "line-translate-anchor": new je(O.paint_line["line-translate-anchor"]), "line-width": new He(O.paint_line["line-width"]), "line-gap-width": new He(O.paint_line["line-gap-width"]), "line-offset": new He(O.paint_line["line-offset"]), "line-blur": new He(O.paint_line["line-blur"]), "line-dasharray": new Qo(O.paint_line["line-dasharray"]), "line-pattern": new Zn(O.paint_line["line-pattern"]), "line-gradient": new el(O.paint_line["line-gradient"]) });
                    }, get layout() {
                        return op = op || new Gt({ "line-cap": new je(O.layout_line["line-cap"]), "line-join": new He(O.layout_line["line-join"]), "line-miter-limit": new je(O.layout_line["line-miter-limit"]), "line-round-limit": new je(O.layout_line["line-round-limit"]), "line-sort-key": new He(O.layout_line["line-sort-key"]) });
                    }
                };
                class wf extends He {
                    possiblyEvaluate(t, r) {
                        return r = new Tt(Math.floor(r.zoom), { now: r.now, fadeDuration: r.fadeDuration, zoomHistory: r.zoomHistory, transition: r.transition }), super.possiblyEvaluate(t, r);
                    }
                    evaluate(t, r, n, l) {
                        return r = Di({}, r, { zoom: Math.floor(r.zoom) }), super.evaluate(t, r, n, l);
                    }
                }
                let Dc;
                class Sf extends Xi {
                    constructor(t) {
                        super(t, cp), this.gradientVersion = 0, Dc || (Dc = new wf(cp.paint.properties["line-width"].specification), Dc.useIntegerZoom = !0);
                    }
                    _handleSpecialPaintPropertyUpdate(t) {
                        if (t === "line-gradient") {
                            const r = this.gradientExpression();
                            this.stepInterpolant = !!function (n) {
                                return n._styleExpression !== void 0;
                            }(r) && r._styleExpression.expression instanceof $r, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
                        }
                    }
                    gradientExpression() {
                        return this._transitionablePaint._values["line-gradient"].value.expression;
                    }
                    recalculate(t, r) {
                        super.recalculate(t, r), this.paint._values["line-floorwidth"] = Dc.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
                    }
                    createBucket(t) {
                        return new Zh(t);
                    }
                    queryRadius(t) {
                        const r = t, n = hp(ol("line-width", this, r), ol("line-gap-width", this, r)), l = ol("line-offset", this, r);
                        return n / 2 + Math.abs(l) + Cc(this.paint.get("line-translate"));
                    }
                    queryIntersectsFeature({ queryGeometry: t, feature: r, featureState: n, geometry: l, transform: p, pixelsToTileUnits: d }) {
                        const m = Ac(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -p.bearingInRadians, d), _ = d / 2 * hp(this.paint.get("line-width").evaluate(r, n), this.paint.get("line-gap-width").evaluate(r, n)), v = this.paint.get("line-offset").evaluate(r, n);
                        return v && (l = function (b, S) {
                            const I = [];
                            for (let A = 0; A < b.length; A++) {
                                const k = b[A], D = [];
                                for (let N = 0; N < k.length; N++) {
                                    const G = k[N - 1], ie = k[N], H = k[N + 1], C = N === 0 ? new $e(0, 0) : ie.sub(G)._unit()._perp(), F = N === k.length - 1 ? new $e(0, 0) : H.sub(ie)._unit()._perp(), X = C._add(F)._unit(), ue = X.x * F.x + X.y * F.y;
                                    ue !== 0 && X._mult(1 / ue), D.push(X._mult(S)._add(ie));
                                }
                                I.push(D);
                            }
                            return I;
                        }(l, v * d)), function (b, S, I) {
                            for (let A = 0; A < S.length; A++) {
                                const k = S[A];
                                if (b.length >= 3) {
                                    for (let D = 0; D < k.length; D++) if (Yn(b, k[D])) return !0;
                                }
                                if (Fd(b, k, I)) return !0;
                            }
                            return !1;
                        }(m, l, _);
                    }
                    isTileClipped() {
                        return !0;
                    }
                }
                function hp(a, t) {
                    return t > 0 ? t + 2 * a : a;
                }
                const Tf = Ct([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Pf = Ct([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
                Ct([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
                const Mf = Ct([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
                Ct([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
                const up = Ct([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), If = Ct([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
                function Cf(a, t, r) {
                    return a.sections.forEach((n) => {
                        n.text = function (l, p, d) {
                            const m = p.layout.get("text-transform").evaluate(d, {});
                            return m === "uppercase" ? l = l.toLocaleUpperCase() : m === "lowercase" && (l = l.toLocaleLowerCase()), Ar.applyArabicShaping && (l = Ar.applyArabicShaping(l)), l;
                        }(n.text, t, r);
                    }), a;
                }
                Ct([{ name: "triangle", components: 3, type: "Uint16" }]), Ct([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Ct([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Ct([{ type: "Float32", name: "offsetX" }]), Ct([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Ct([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
                const yl = { "!": "ï¸•", "#": "ï¼ƒ", $: "ï¼„", "%": "ï¼…", "&": "ï¼†", "(": "ï¸µ", ")": "ï¸¶", "*": "ï¼Š", "+": "ï¼‹", ",": "ï¸", "-": "ï¸²", ".": "ãƒ»", "/": "ï¼", ":": "ï¸“", ";": "ï¸”", "<": "ï¸¿", "=": "ï¼", ">": "ï¹€", "?": "ï¸–", "@": "ï¼ ", "[": "ï¹‡", "\\": "ï¼¼", "]": "ï¹ˆ", "^": "ï¼¾", _: "ï¸³", "`": "ï½€", "{": "ï¸·", "|": "â€•", "}": "ï¸¸", "~": "ï½ž", "Â¢": "ï¿ ", "Â£": "ï¿¡", "Â¥": "ï¿¥", "Â¦": "ï¿¤", "Â¬": "ï¿¢", "Â¯": "ï¿£", "â€“": "ï¸²", "â€”": "ï¸±", "â€˜": "ï¹ƒ", "â€™": "ï¹„", "â€œ": "ï¹", "â€": "ï¹‚", "â€¦": "ï¸™", "â€§": "ãƒ»", "â‚©": "ï¿¦", "ã€": "ï¸‘", "ã€‚": "ï¸’", "ã€ˆ": "ï¸¿", "ã€‰": "ï¹€", "ã€Š": "ï¸½", "ã€‹": "ï¸¾", "ã€Œ": "ï¹", "ã€": "ï¹‚", "ã€Ž": "ï¹ƒ", "ã€": "ï¹„", "ã€": "ï¸»", "ã€‘": "ï¸¼", "ã€”": "ï¸¹", "ã€•": "ï¸º", "ã€–": "ï¸—", "ã€—": "ï¸˜", "ï¼": "ï¸•", "ï¼ˆ": "ï¸µ", "ï¼‰": "ï¸¶", "ï¼Œ": "ï¸", "ï¼": "ï¸²", "ï¼Ž": "ãƒ»", "ï¼š": "ï¸“", "ï¼›": "ï¸”", "ï¼œ": "ï¸¿", "ï¼ž": "ï¹€", "ï¼Ÿ": "ï¸–", "ï¼»": "ï¹‡", "ï¼½": "ï¹ˆ", "ï¼¿": "ï¸³", "ï½›": "ï¸·", "ï½œ": "â€•", "ï½": "ï¸¸", "ï½Ÿ": "ï¸µ", "ï½ ": "ï¸¶", "ï½¡": "ï¸’", "ï½¢": "ï¹", "ï½£": "ï¹‚" };
                var pp, Gh, dp, Yt = 24, qh = {};
                function Af() {
                    return pp || (pp = 1, qh.read = function (a, t, r, n, l) {
                        var p, d, m = 8 * l - n - 1, _ = (1 << m) - 1, v = _ >> 1, b = -7, S = r ? l - 1 : 0, I = r ? -1 : 1, A = a[t + S];
                        for (S += I, p = A & (1 << -b) - 1, A >>= -b, b += m; b > 0; p = 256 * p + a[t + S], S += I, b -= 8);
                        for (d = p & (1 << -b) - 1, p >>= -b, b += n; b > 0; d = 256 * d + a[t + S], S += I, b -= 8);
                        if (p === 0) p = 1 - v;
                        else {
                            if (p === _) return d ? NaN : 1 / 0 * (A ? -1 : 1);
                            d += Math.pow(2, n), p -= v;
                        }
                        return (A ? -1 : 1) * d * Math.pow(2, p - n);
                    }, qh.write = function (a, t, r, n, l, p) {
                        var d, m, _, v = 8 * p - l - 1, b = (1 << v) - 1, S = b >> 1, I = l === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, A = n ? 0 : p - 1, k = n ? 1 : -1, D = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
                        for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (m = isNaN(t) ? 1 : 0, d = b) : (d = Math.floor(Math.log(t) / Math.LN2), t * (_ = Math.pow(2, -d)) < 1 && (d--, _ *= 2), (t += d + S >= 1 ? I / _ : I * Math.pow(2, 1 - S)) * _ >= 2 && (d++, _ /= 2), d + S >= b ? (m = 0, d = b) : d + S >= 1 ? (m = (t * _ - 1) * Math.pow(2, l), d += S) : (m = t * Math.pow(2, S - 1) * Math.pow(2, l), d = 0)); l >= 8; a[r + A] = 255 & m, A += k, m /= 256, l -= 8);
                        for (d = d << l | m, v += l; v > 0; a[r + A] = 255 & d, A += k, d /= 256, v -= 8);
                        a[r + A - k] |= 128 * D;
                    }), qh;
                }
                function fp() {
                    if (dp) return Gh;
                    dp = 1, Gh = t;
                    var a = Af();
                    function t(C) {
                        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(C) ? C : new Uint8Array(C || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
                    }
                    t.Varint = 0, t.Fixed64 = 1, t.Bytes = 2, t.Fixed32 = 5;
                    var r = 4294967296, n = 1 / r, l = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
                    function p(C) {
                        return C.type === t.Bytes ? C.readVarint() + C.pos : C.pos + 1;
                    }
                    function d(C, F, X) {
                        return X ? 4294967296 * F + (C >>> 0) : 4294967296 * (F >>> 0) + (C >>> 0);
                    }
                    function m(C, F, X) {
                        var ue = F <= 16383 ? 1 : F <= 2097151 ? 2 : F <= 268435455 ? 3 : Math.floor(Math.log(F) / (7 * Math.LN2));
                        X.realloc(ue);
                        for (var Me = X.pos - 1; Me >= C; Me--) X.buf[Me + ue] = X.buf[Me];
                    }
                    function _(C, F) {
                        for (var X = 0; X < C.length; X++) F.writeVarint(C[X]);
                    }
                    function v(C, F) {
                        for (var X = 0; X < C.length; X++) F.writeSVarint(C[X]);
                    }
                    function b(C, F) {
                        for (var X = 0; X < C.length; X++) F.writeFloat(C[X]);
                    }
                    function S(C, F) {
                        for (var X = 0; X < C.length; X++) F.writeDouble(C[X]);
                    }
                    function I(C, F) {
                        for (var X = 0; X < C.length; X++) F.writeBoolean(C[X]);
                    }
                    function A(C, F) {
                        for (var X = 0; X < C.length; X++) F.writeFixed32(C[X]);
                    }
                    function k(C, F) {
                        for (var X = 0; X < C.length; X++) F.writeSFixed32(C[X]);
                    }
                    function D(C, F) {
                        for (var X = 0; X < C.length; X++) F.writeFixed64(C[X]);
                    }
                    function N(C, F) {
                        for (var X = 0; X < C.length; X++) F.writeSFixed64(C[X]);
                    }
                    function G(C, F) {
                        return (C[F] | C[F + 1] << 8 | C[F + 2] << 16) + 16777216 * C[F + 3];
                    }
                    function ie(C, F, X) {
                        C[X] = F, C[X + 1] = F >>> 8, C[X + 2] = F >>> 16, C[X + 3] = F >>> 24;
                    }
                    function H(C, F) {
                        return (C[F] | C[F + 1] << 8 | C[F + 2] << 16) + (C[F + 3] << 24);
                    }
                    return t.prototype = {
                        destroy: function () {
                            this.buf = null;
                        }, readFields: function (C, F, X) {
                            for (X = X || this.length; this.pos < X;) {
                                var ue = this.readVarint(), Me = ue >> 3, me = this.pos;
                                this.type = 7 & ue, C(Me, F, this), this.pos === me && this.skip(ue);
                            }
                            return F;
                        }, readMessage: function (C, F) {
                            return this.readFields(C, F, this.readVarint() + this.pos);
                        }, readFixed32: function () {
                            var C = G(this.buf, this.pos);
                            return this.pos += 4, C;
                        }, readSFixed32: function () {
                            var C = H(this.buf, this.pos);
                            return this.pos += 4, C;
                        }, readFixed64: function () {
                            var C = G(this.buf, this.pos) + G(this.buf, this.pos + 4) * r;
                            return this.pos += 8, C;
                        }, readSFixed64: function () {
                            var C = G(this.buf, this.pos) + H(this.buf, this.pos + 4) * r;
                            return this.pos += 8, C;
                        }, readFloat: function () {
                            var C = a.read(this.buf, this.pos, !0, 23, 4);
                            return this.pos += 4, C;
                        }, readDouble: function () {
                            var C = a.read(this.buf, this.pos, !0, 52, 8);
                            return this.pos += 8, C;
                        }, readVarint: function (C) {
                            var F, X, ue = this.buf;
                            return F = 127 & (X = ue[this.pos++]), X < 128 ? F : (F |= (127 & (X = ue[this.pos++])) << 7, X < 128 ? F : (F |= (127 & (X = ue[this.pos++])) << 14, X < 128 ? F : (F |= (127 & (X = ue[this.pos++])) << 21, X < 128 ? F : function (Me, me, xe) {
                                var Ae, Ie, ke = xe.buf;
                                if (Ae = (112 & (Ie = ke[xe.pos++])) >> 4, Ie < 128 || (Ae |= (127 & (Ie = ke[xe.pos++])) << 3, Ie < 128) || (Ae |= (127 & (Ie = ke[xe.pos++])) << 10, Ie < 128) || (Ae |= (127 & (Ie = ke[xe.pos++])) << 17, Ie < 128) || (Ae |= (127 & (Ie = ke[xe.pos++])) << 24, Ie < 128) || (Ae |= (1 & (Ie = ke[xe.pos++])) << 31, Ie < 128)) return d(Me, Ae, me);
                                throw new Error("Expected varint not more than 10 bytes");
                            }(F |= (15 & (X = ue[this.pos])) << 28, C, this))));
                        }, readVarint64: function () {
                            return this.readVarint(!0);
                        }, readSVarint: function () {
                            var C = this.readVarint();
                            return C % 2 == 1 ? (C + 1) / -2 : C / 2;
                        }, readBoolean: function () {
                            return !!this.readVarint();
                        }, readString: function () {
                            var C = this.readVarint() + this.pos, F = this.pos;
                            return this.pos = C, C - F >= 12 && l ? function (X, ue, Me) {
                                return l.decode(X.subarray(ue, Me));
                            }(this.buf, F, C) : function (X, ue, Me) {
                                for (var me = "", xe = ue; xe < Me;) {
                                    var Ae, Ie, ke, we = X[xe], Be = null, Ge = we > 239 ? 4 : we > 223 ? 3 : we > 191 ? 2 : 1;
                                    if (xe + Ge > Me) break;
                                    Ge === 1 ? we < 128 && (Be = we) : Ge === 2 ? (192 & (Ae = X[xe + 1])) == 128 && (Be = (31 & we) << 6 | 63 & Ae) <= 127 && (Be = null) : Ge === 3 ? (Ie = X[xe + 2], (192 & (Ae = X[xe + 1])) == 128 && (192 & Ie) == 128 && ((Be = (15 & we) << 12 | (63 & Ae) << 6 | 63 & Ie) <= 2047 || Be >= 55296 && Be <= 57343) && (Be = null)) : Ge === 4 && (Ie = X[xe + 2], ke = X[xe + 3], (192 & (Ae = X[xe + 1])) == 128 && (192 & Ie) == 128 && (192 & ke) == 128 && ((Be = (15 & we) << 18 | (63 & Ae) << 12 | (63 & Ie) << 6 | 63 & ke) <= 65535 || Be >= 1114112) && (Be = null)), Be === null ? (Be = 65533, Ge = 1) : Be > 65535 && (Be -= 65536, me += String.fromCharCode(Be >>> 10 & 1023 | 55296), Be = 56320 | 1023 & Be), me += String.fromCharCode(Be), xe += Ge;
                                }
                                return me;
                            }(this.buf, F, C);
                        }, readBytes: function () {
                            var C = this.readVarint() + this.pos, F = this.buf.subarray(this.pos, C);
                            return this.pos = C, F;
                        }, readPackedVarint: function (C, F) {
                            if (this.type !== t.Bytes) return C.push(this.readVarint(F));
                            var X = p(this);
                            for (C = C || []; this.pos < X;) C.push(this.readVarint(F));
                            return C;
                        }, readPackedSVarint: function (C) {
                            if (this.type !== t.Bytes) return C.push(this.readSVarint());
                            var F = p(this);
                            for (C = C || []; this.pos < F;) C.push(this.readSVarint());
                            return C;
                        }, readPackedBoolean: function (C) {
                            if (this.type !== t.Bytes) return C.push(this.readBoolean());
                            var F = p(this);
                            for (C = C || []; this.pos < F;) C.push(this.readBoolean());
                            return C;
                        }, readPackedFloat: function (C) {
                            if (this.type !== t.Bytes) return C.push(this.readFloat());
                            var F = p(this);
                            for (C = C || []; this.pos < F;) C.push(this.readFloat());
                            return C;
                        }, readPackedDouble: function (C) {
                            if (this.type !== t.Bytes) return C.push(this.readDouble());
                            var F = p(this);
                            for (C = C || []; this.pos < F;) C.push(this.readDouble());
                            return C;
                        }, readPackedFixed32: function (C) {
                            if (this.type !== t.Bytes) return C.push(this.readFixed32());
                            var F = p(this);
                            for (C = C || []; this.pos < F;) C.push(this.readFixed32());
                            return C;
                        }, readPackedSFixed32: function (C) {
                            if (this.type !== t.Bytes) return C.push(this.readSFixed32());
                            var F = p(this);
                            for (C = C || []; this.pos < F;) C.push(this.readSFixed32());
                            return C;
                        }, readPackedFixed64: function (C) {
                            if (this.type !== t.Bytes) return C.push(this.readFixed64());
                            var F = p(this);
                            for (C = C || []; this.pos < F;) C.push(this.readFixed64());
                            return C;
                        }, readPackedSFixed64: function (C) {
                            if (this.type !== t.Bytes) return C.push(this.readSFixed64());
                            var F = p(this);
                            for (C = C || []; this.pos < F;) C.push(this.readSFixed64());
                            return C;
                        }, skip: function (C) {
                            var F = 7 & C;
                            if (F === t.Varint) for (; this.buf[this.pos++] > 127;);
                            else if (F === t.Bytes) this.pos = this.readVarint() + this.pos;
                            else if (F === t.Fixed32) this.pos += 4;
                            else {
                                if (F !== t.Fixed64) throw new Error("Unimplemented type: " + F);
                                this.pos += 8;
                            }
                        }, writeTag: function (C, F) {
                            this.writeVarint(C << 3 | F);
                        }, realloc: function (C) {
                            for (var F = this.length || 16; F < this.pos + C;) F *= 2;
                            if (F !== this.length) {
                                var X = new Uint8Array(F);
                                X.set(this.buf), this.buf = X, this.length = F;
                            }
                        }, finish: function () {
                            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
                        }, writeFixed32: function (C) {
                            this.realloc(4), ie(this.buf, C, this.pos), this.pos += 4;
                        }, writeSFixed32: function (C) {
                            this.realloc(4), ie(this.buf, C, this.pos), this.pos += 4;
                        }, writeFixed64: function (C) {
                            this.realloc(8), ie(this.buf, -1 & C, this.pos), ie(this.buf, Math.floor(C * n), this.pos + 4), this.pos += 8;
                        }, writeSFixed64: function (C) {
                            this.realloc(8), ie(this.buf, -1 & C, this.pos), ie(this.buf, Math.floor(C * n), this.pos + 4), this.pos += 8;
                        }, writeVarint: function (C) {
                            (C = +C || 0) > 268435455 || C < 0 ? function (F, X) {
                                var ue, Me;
                                if (F >= 0 ? (ue = F % 4294967296 | 0, Me = F / 4294967296 | 0) : (Me = ~(-F / 4294967296), 4294967295 ^ (ue = ~(-F % 4294967296)) ? ue = ue + 1 | 0 : (ue = 0, Me = Me + 1 | 0)), F >= 18446744073709552e3 || F < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
                                X.realloc(10), function (me, xe, Ae) {
                                    Ae.buf[Ae.pos++] = 127 & me | 128, me >>>= 7, Ae.buf[Ae.pos++] = 127 & me | 128, me >>>= 7, Ae.buf[Ae.pos++] = 127 & me | 128, me >>>= 7, Ae.buf[Ae.pos++] = 127 & me | 128, Ae.buf[Ae.pos] = 127 & (me >>>= 7);
                                }(ue, 0, X), function (me, xe) {
                                    var Ae = (7 & me) << 4;
                                    xe.buf[xe.pos++] |= Ae | ((me >>>= 3) ? 128 : 0), me && (xe.buf[xe.pos++] = 127 & me | ((me >>>= 7) ? 128 : 0), me && (xe.buf[xe.pos++] = 127 & me | ((me >>>= 7) ? 128 : 0), me && (xe.buf[xe.pos++] = 127 & me | ((me >>>= 7) ? 128 : 0), me && (xe.buf[xe.pos++] = 127 & me | ((me >>>= 7) ? 128 : 0), me && (xe.buf[xe.pos++] = 127 & me)))));
                                }(Me, X);
                            }(C, this) : (this.realloc(4), this.buf[this.pos++] = 127 & C | (C > 127 ? 128 : 0), C <= 127 || (this.buf[this.pos++] = 127 & (C >>>= 7) | (C > 127 ? 128 : 0), C <= 127 || (this.buf[this.pos++] = 127 & (C >>>= 7) | (C > 127 ? 128 : 0), C <= 127 || (this.buf[this.pos++] = C >>> 7 & 127))));
                        }, writeSVarint: function (C) {
                            this.writeVarint(C < 0 ? 2 * -C - 1 : 2 * C);
                        }, writeBoolean: function (C) {
                            this.writeVarint(!!C);
                        }, writeString: function (C) {
                            C = String(C), this.realloc(4 * C.length), this.pos++;
                            var F = this.pos;
                            this.pos = function (ue, Me, me) {
                                for (var xe, Ae, Ie = 0; Ie < Me.length; Ie++) {
                                    if ((xe = Me.charCodeAt(Ie)) > 55295 && xe < 57344) {
                                        if (!Ae) {
                                            xe > 56319 || Ie + 1 === Me.length ? (ue[me++] = 239, ue[me++] = 191, ue[me++] = 189) : Ae = xe;
                                            continue;
                                        }
                                        if (xe < 56320) {
                                            ue[me++] = 239, ue[me++] = 191, ue[me++] = 189, Ae = xe;
                                            continue;
                                        }
                                        xe = Ae - 55296 << 10 | xe - 56320 | 65536, Ae = null;
                                    } else Ae && (ue[me++] = 239, ue[me++] = 191, ue[me++] = 189, Ae = null);
                                    xe < 128 ? ue[me++] = xe : (xe < 2048 ? ue[me++] = xe >> 6 | 192 : (xe < 65536 ? ue[me++] = xe >> 12 | 224 : (ue[me++] = xe >> 18 | 240, ue[me++] = xe >> 12 & 63 | 128), ue[me++] = xe >> 6 & 63 | 128), ue[me++] = 63 & xe | 128);
                                }
                                return me;
                            }(this.buf, C, this.pos);
                            var X = this.pos - F;
                            X >= 128 && m(F, X, this), this.pos = F - 1, this.writeVarint(X), this.pos += X;
                        }, writeFloat: function (C) {
                            this.realloc(4), a.write(this.buf, C, this.pos, !0, 23, 4), this.pos += 4;
                        }, writeDouble: function (C) {
                            this.realloc(8), a.write(this.buf, C, this.pos, !0, 52, 8), this.pos += 8;
                        }, writeBytes: function (C) {
                            var F = C.length;
                            this.writeVarint(F), this.realloc(F);
                            for (var X = 0; X < F; X++) this.buf[this.pos++] = C[X];
                        }, writeRawMessage: function (C, F) {
                            this.pos++;
                            var X = this.pos;
                            C(F, this);
                            var ue = this.pos - X;
                            ue >= 128 && m(X, ue, this), this.pos = X - 1, this.writeVarint(ue), this.pos += ue;
                        }, writeMessage: function (C, F, X) {
                            this.writeTag(C, t.Bytes), this.writeRawMessage(F, X);
                        }, writePackedVarint: function (C, F) {
                            F.length && this.writeMessage(C, _, F);
                        }, writePackedSVarint: function (C, F) {
                            F.length && this.writeMessage(C, v, F);
                        }, writePackedBoolean: function (C, F) {
                            F.length && this.writeMessage(C, I, F);
                        }, writePackedFloat: function (C, F) {
                            F.length && this.writeMessage(C, b, F);
                        }, writePackedDouble: function (C, F) {
                            F.length && this.writeMessage(C, S, F);
                        }, writePackedFixed32: function (C, F) {
                            F.length && this.writeMessage(C, A, F);
                        }, writePackedSFixed32: function (C, F) {
                            F.length && this.writeMessage(C, k, F);
                        }, writePackedFixed64: function (C, F) {
                            F.length && this.writeMessage(C, D, F);
                        }, writePackedSFixed64: function (C, F) {
                            F.length && this.writeMessage(C, N, F);
                        }, writeBytesField: function (C, F) {
                            this.writeTag(C, t.Bytes), this.writeBytes(F);
                        }, writeFixed32Field: function (C, F) {
                            this.writeTag(C, t.Fixed32), this.writeFixed32(F);
                        }, writeSFixed32Field: function (C, F) {
                            this.writeTag(C, t.Fixed32), this.writeSFixed32(F);
                        }, writeFixed64Field: function (C, F) {
                            this.writeTag(C, t.Fixed64), this.writeFixed64(F);
                        }, writeSFixed64Field: function (C, F) {
                            this.writeTag(C, t.Fixed64), this.writeSFixed64(F);
                        }, writeVarintField: function (C, F) {
                            this.writeTag(C, t.Varint), this.writeVarint(F);
                        }, writeSVarintField: function (C, F) {
                            this.writeTag(C, t.Varint), this.writeSVarint(F);
                        }, writeStringField: function (C, F) {
                            this.writeTag(C, t.Bytes), this.writeString(F);
                        }, writeFloatField: function (C, F) {
                            this.writeTag(C, t.Fixed32), this.writeFloat(F);
                        }, writeDoubleField: function (C, F) {
                            this.writeTag(C, t.Fixed64), this.writeDouble(F);
                        }, writeBooleanField: function (C, F) {
                            this.writeVarintField(C, !!F);
                        }
                    }, Gh;
                }
                var Hh = Fe(fp());
                const Wh = 3;
                function kf(a, t, r) {
                    a === 1 && r.readMessage(zf, t);
                }
                function zf(a, t, r) {
                    if (a === 3) {
                        const { id: n, bitmap: l, width: p, height: d, left: m, top: _, advance: v } = r.readMessage(Ef, {});
                        t.push({ id: n, bitmap: new ll({ width: p + 2 * Wh, height: d + 2 * Wh }, l), metrics: { width: p, height: d, left: m, top: _, advance: v } });
                    }
                }
                function Ef(a, t, r) {
                    a === 1 ? t.id = r.readVarint() : a === 2 ? t.bitmap = r.readBytes() : a === 3 ? t.width = r.readVarint() : a === 4 ? t.height = r.readVarint() : a === 5 ? t.left = r.readSVarint() : a === 6 ? t.top = r.readSVarint() : a === 7 && (t.advance = r.readVarint());
                }
                const Rf = Wh;
                function mp(a) {
                    let t = 0, r = 0;
                    for (const d of a) t += d.w * d.h, r = Math.max(r, d.w);
                    a.sort((d, m) => m.h - d.h);
                    const n = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), r), h: 1 / 0 }];
                    let l = 0, p = 0;
                    for (const d of a) for (let m = n.length - 1; m >= 0; m--) {
                        const _ = n[m];
                        if (!(d.w > _.w || d.h > _.h)) {
                            if (d.x = _.x, d.y = _.y, p = Math.max(p, d.y + d.h), l = Math.max(l, d.x + d.w), d.w === _.w && d.h === _.h) {
                                const v = n.pop();
                                m < n.length && (n[m] = v);
                            } else d.h === _.h ? (_.x += d.w, _.w -= d.w) : d.w === _.w ? (_.y += d.h, _.h -= d.h) : (n.push({ x: _.x + d.w, y: _.y, w: _.w - d.w, h: d.h }), _.y += d.h, _.h -= d.h);
                            break;
                        }
                    }
                    return { w: l, h: p, fill: t / (l * p) || 0 };
                }
                const Ui = 1;
                class Xh {
                    constructor(t, { pixelRatio: r, version: n, stretchX: l, stretchY: p, content: d, textFitWidth: m, textFitHeight: _ }) {
                        this.paddedRect = t, this.pixelRatio = r, this.stretchX = l, this.stretchY = p, this.content = d, this.version = n, this.textFitWidth = m, this.textFitHeight = _;
                    }
                    get tl() {
                        return [this.paddedRect.x + Ui, this.paddedRect.y + Ui];
                    }
                    get br() {
                        return [this.paddedRect.x + this.paddedRect.w - Ui, this.paddedRect.y + this.paddedRect.h - Ui];
                    }
                    get tlbr() {
                        return this.tl.concat(this.br);
                    }
                    get displaySize() {
                        return [(this.paddedRect.w - 2 * Ui) / this.pixelRatio, (this.paddedRect.h - 2 * Ui) / this.pixelRatio];
                    }
                }
                class gp {
                    constructor(t, r) {
                        const n = {}, l = {};
                        this.haveRenderCallbacks = [];
                        const p = [];
                        this.addImages(t, n, p), this.addImages(r, l, p);
                        const { w: d, h: m } = mp(p), _ = new rr({ width: d || 1, height: m || 1 });
                        for (const v in t) {
                            const b = t[v], S = n[v].paddedRect;
                            rr.copy(b.data, _, { x: 0, y: 0 }, { x: S.x + Ui, y: S.y + Ui }, b.data);
                        }
                        for (const v in r) {
                            const b = r[v], S = l[v].paddedRect, I = S.x + Ui, A = S.y + Ui, k = b.data.width, D = b.data.height;
                            rr.copy(b.data, _, { x: 0, y: 0 }, { x: I, y: A }, b.data), rr.copy(b.data, _, { x: 0, y: D - 1 }, { x: I, y: A - 1 }, { width: k, height: 1 }), rr.copy(b.data, _, { x: 0, y: 0 }, { x: I, y: A + D }, { width: k, height: 1 }), rr.copy(b.data, _, { x: k - 1, y: 0 }, { x: I - 1, y: A }, { width: 1, height: D }), rr.copy(b.data, _, { x: 0, y: 0 }, { x: I + k, y: A }, { width: 1, height: D });
                        }
                        this.image = _, this.iconPositions = n, this.patternPositions = l;
                    }
                    addImages(t, r, n) {
                        for (const l in t) {
                            const p = t[l], d = { x: 0, y: 0, w: p.data.width + 2 * Ui, h: p.data.height + 2 * Ui };
                            n.push(d), r[l] = new Xh(d, p), p.hasRenderCallback && this.haveRenderCallbacks.push(l);
                        }
                    }
                    patchUpdatedImages(t, r) {
                        t.dispatchRenderCallbacks(this.haveRenderCallbacks);
                        for (const n in t.updatedImages) this.patchUpdatedImage(this.iconPositions[n], t.getImage(n), r), this.patchUpdatedImage(this.patternPositions[n], t.getImage(n), r);
                    }
                    patchUpdatedImage(t, r, n) {
                        if (!t || !r || t.version === r.version) return;
                        t.version = r.version;
                        const [l, p] = t.tl;
                        n.update(r.data, void 0, { x: l, y: p });
                    }
                }
                var en;
                Le("ImagePosition", Xh), Le("ImageAtlas", gp), M.al = void 0, (en = M.al || (M.al = {}))[en.none = 0] = "none", en[en.horizontal = 1] = "horizontal", en[en.vertical = 2] = "vertical", en[en.horizontalOnly = 3] = "horizontalOnly";
                const Lc = -17;
                class vl {
                    constructor() {
                        this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
                    }
                    static forText(t, r, n) {
                        const l = new vl();
                        return l.scale = t || 1, l.fontStack = r, l.verticalAlign = n || "bottom", l;
                    }
                    static forImage(t, r) {
                        const n = new vl();
                        return n.imageName = t, n.verticalAlign = r || "bottom", n;
                    }
                }
                class to {
                    constructor() {
                        this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
                    }
                    static fromFeature(t, r) {
                        const n = new to();
                        for (let l = 0; l < t.sections.length; l++) {
                            const p = t.sections[l];
                            p.image ? n.addImageSection(p) : n.addTextSection(p, r);
                        }
                        return n;
                    }
                    length() {
                        return this.text.length;
                    }
                    getSection(t) {
                        return this.sections[this.sectionIndex[t]];
                    }
                    getSectionIndex(t) {
                        return this.sectionIndex[t];
                    }
                    getCharCode(t) {
                        return this.text.charCodeAt(t);
                    }
                    verticalizePunctuation() {
                        this.text = function (t) {
                            let r = "";
                            for (let n = 0; n < t.length; n++) {
                                const l = t.charCodeAt(n + 1) || null, p = t.charCodeAt(n - 1) || null;
                                r += l && Un(l) && !yl[t[n + 1]] || p && Un(p) && !yl[t[n - 1]] || !yl[t[n]] ? t[n] : yl[t[n]];
                            }
                            return r;
                        }(this.text);
                    }
                    trim() {
                        let t = 0;
                        for (let n = 0; n < this.text.length && Fc[this.text.charCodeAt(n)]; n++) t++;
                        let r = this.text.length;
                        for (let n = this.text.length - 1; n >= 0 && n >= t && Fc[this.text.charCodeAt(n)]; n--) r--;
                        this.text = this.text.substring(t, r), this.sectionIndex = this.sectionIndex.slice(t, r);
                    }
                    substring(t, r) {
                        const n = new to();
                        return n.text = this.text.substring(t, r), n.sectionIndex = this.sectionIndex.slice(t, r), n.sections = this.sections, n;
                    }
                    toString() {
                        return this.text;
                    }
                    getMaxScale() {
                        return this.sectionIndex.reduce((t, r) => Math.max(t, this.sections[r].scale), 0);
                    }
                    getMaxImageSize(t) {
                        let r = 0, n = 0;
                        for (let l = 0; l < this.length(); l++) {
                            const p = this.getSection(l);
                            if (p.imageName) {
                                const d = t[p.imageName];
                                if (!d) continue;
                                const m = d.displaySize;
                                r = Math.max(r, m[0]), n = Math.max(n, m[1]);
                            }
                        }
                        return { maxImageWidth: r, maxImageHeight: n };
                    }
                    addTextSection(t, r) {
                        this.text += t.text, this.sections.push(vl.forText(t.scale, t.fontStack || r, t.verticalAlign));
                        const n = this.sections.length - 1;
                        for (let l = 0; l < t.text.length; ++l) this.sectionIndex.push(n);
                    }
                    addImageSection(t) {
                        const r = t.image ? t.image.name : "";
                        if (r.length === 0) return void wi("Can't add FormattedSection with an empty image.");
                        const n = this.getNextImageSectionCharCode();
                        n ? (this.text += String.fromCharCode(n), this.sections.push(vl.forImage(r, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : wi("Reached maximum number of images 6401");
                    }
                    getNextImageSectionCharCode() {
                        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
                    }
                }
                function Bc(a, t, r, n, l, p, d, m, _, v, b, S, I, A, k) {
                    const D = to.fromFeature(a, l);
                    let N;
                    S === M.al.vertical && D.verticalizePunctuation();
                    const { processBidirectionalText: G, processStyledBidirectionalText: ie } = Ar;
                    if (G && D.sections.length === 1) {
                        N = [];
                        const F = G(D.toString(), Kh(D, v, p, t, n, A));
                        for (const X of F) {
                            const ue = new to();
                            ue.text = X, ue.sections = D.sections;
                            for (let Me = 0; Me < X.length; Me++) ue.sectionIndex.push(0);
                            N.push(ue);
                        }
                    } else if (ie) {
                        N = [];
                        const F = ie(D.text, D.sectionIndex, Kh(D, v, p, t, n, A));
                        for (const X of F) {
                            const ue = new to();
                            ue.text = X[0], ue.sectionIndex = X[1], ue.sections = D.sections, N.push(ue);
                        }
                    } else N = function (F, X) {
                        const ue = [], Me = F.text;
                        let me = 0;
                        for (const xe of X) ue.push(F.substring(me, xe)), me = xe;
                        return me < Me.length && ue.push(F.substring(me, Me.length)), ue;
                    }(D, Kh(D, v, p, t, n, A));
                    const H = [], C = { positionedLines: H, text: D.toString(), top: b[1], bottom: b[1], left: b[0], right: b[0], writingMode: S, iconsInText: !1, verticalizable: !1 };
                    return function (F, X, ue, Me, me, xe, Ae, Ie, ke, we, Be, Ge) {
                        let Ve = 0, Oe = 0, at = 0, Ot = 0;
                        const Jt = Ie === "right" ? 1 : Ie === "left" ? 0 : 0.5, xi = Yt / Ge;
                        let nr = 0;
                        for (const Et of me) {
                            Et.trim();
                            const ri = Et.getMaxScale(), di = { positionedGlyphs: [], lineOffset: 0 };
                            F.positionedLines[nr] = di;
                            const fi = di.positionedGlyphs;
                            let Ri = 0;
                            if (!Et.length()) {
                                Oe += xe, ++nr;
                                continue;
                            }
                            const sr = Ff(Me, Et, xi);
                            for (let Zi = 0; Zi < Et.length(); Zi++) {
                                const Qt = Et.getSection(Zi), ni = Et.getSectionIndex(Zi), si = Et.getCharCode(Zi), Wt = Nf(ke, Be, si);
                                let Mt;
                                if (Qt.imageName) {
                                    if (F.iconsInText = !0, Qt.scale = Qt.scale * xi, Mt = jf(Qt, Wt, ri, sr, Me), !Mt) continue;
                                    Ri = Math.max(Ri, Mt.imageOffset);
                                } else if (Mt = Of(Qt, si, Wt, sr, X, ue), !Mt) continue;
                                const { rect: Er, metrics: no, baselineOffset: Rr } = Mt;
                                fi.push({ glyph: si, imageName: Qt.imageName, x: Ve, y: Oe + Rr + Lc, vertical: Wt, scale: Qt.scale, fontStack: Qt.fontStack, sectionIndex: ni, metrics: no, rect: Er }), Wt ? (F.verticalizable = !0, Ve += (Qt.imageName ? no.advance : Yt) * Qt.scale + we) : Ve += no.advance * Qt.scale + we;
                            }
                            fi.length !== 0 && (at = Math.max(Ve - we, at), $f(fi, 0, fi.length - 1, Jt)), Ve = 0, di.lineOffset = Math.max(Ri, (ri - 1) * Yt);
                            const ai = xe * ri + Ri;
                            Oe += ai, Ot = Math.max(ai, Ot), ++nr;
                        }
                        const { horizontalAlign: Vi, verticalAlign: pi } = Yh(Ae);
                        (function (Et, ri, di, fi, Ri, sr, ai, Zi, Qt) {
                            const ni = (ri - di) * Ri;
                            let si = 0;
                            si = sr !== ai ? -Zi * fi - Lc : -fi * Qt * ai + 0.5 * ai;
                            for (const Wt of Et) for (const Mt of Wt.positionedGlyphs) Mt.x += ni, Mt.y += si;
                        })(F.positionedLines, Jt, Vi, pi, at, Ot, xe, Oe, me.length), F.top += -pi * Oe, F.bottom = F.top + Oe, F.left += -Vi * at, F.right = F.left + at;
                    }(C, t, r, n, N, d, m, _, S, v, I, k), !function (F) {
                        for (const X of F) if (X.positionedGlyphs.length !== 0) return !1;
                        return !0;
                    }(H) && C;
                }
                const Fc = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, Df = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, Lf = { 40: !0 };
                function _p(a, t, r, n, l, p) {
                    if (t.imageName) {
                        const d = n[t.imageName];
                        return d ? d.displaySize[0] * t.scale * Yt / p + l : 0;
                    }
                    {
                        const d = r[t.fontStack], m = d && d[a];
                        return m ? m.metrics.advance * t.scale + l : 0;
                    }
                }
                function yp(a, t, r, n) {
                    const l = Math.pow(a - t, 2);
                    return n ? a < t ? l / 2 : 2 * l : l + Math.abs(r) * r;
                }
                function Bf(a, t, r) {
                    let n = 0;
                    return a === 10 && (n -= 1e4), r && (n += 150), a !== 40 && a !== 65288 || (n += 50), t !== 41 && t !== 65289 || (n += 50), n;
                }
                function vp(a, t, r, n, l, p) {
                    let d = null, m = yp(t, r, l, p);
                    for (const _ of n) {
                        const v = yp(t - _.x, r, l, p) + _.badness;
                        v <= m && (d = _, m = v);
                    }
                    return { index: a, x: t, priorBreak: d, badness: m };
                }
                function xp(a) {
                    return a ? xp(a.priorBreak).concat(a.index) : [];
                }
                function Kh(a, t, r, n, l, p) {
                    if (!a) return [];
                    const d = [], m = function (S, I, A, k, D, N) {
                        let G = 0;
                        for (let ie = 0; ie < S.length(); ie++) {
                            const H = S.getSection(ie);
                            G += _p(S.getCharCode(ie), H, k, D, I, N);
                        }
                        return G / Math.max(1, Math.ceil(G / A));
                    }(a, t, r, n, l, p), _ = a.text.indexOf("â€‹") >= 0;
                    let v = 0;
                    for (let S = 0; S < a.length(); S++) {
                        const I = a.getSection(S), A = a.getCharCode(S);
                        if (Fc[A] || (v += _p(A, I, n, l, t, p)), S < a.length() - 1) {
                            const k = !((b = A) < 11904) && (!!rt["CJK Compatibility Forms"](b) || !!rt["CJK Compatibility"](b) || !!rt["CJK Strokes"](b) || !!rt["CJK Symbols and Punctuation"](b) || !!rt["Enclosed CJK Letters and Months"](b) || !!rt["Halfwidth and Fullwidth Forms"](b) || !!rt["Ideographic Description Characters"](b) || !!rt["Vertical Forms"](b) || Yo.test(String.fromCodePoint(b)));
                            (Df[A] || k || I.imageName || S !== a.length() - 2 && Lf[a.getCharCode(S + 1)]) && d.push(vp(S + 1, v, m, d, Bf(A, a.getCharCode(S + 1), k && _), !1));
                        }
                    }
                    var b;
                    return xp(vp(a.length(), v, m, d, 0, !0));
                }
                function Yh(a) {
                    let t = 0.5, r = 0.5;
                    switch (a) {
                        case "right":
                        case "top-right":
                        case "bottom-right":
                            t = 1;
                            break;
                        case "left":
                        case "top-left":
                        case "bottom-left":
                            t = 0;
                    }
                    switch (a) {
                        case "bottom":
                        case "bottom-right":
                        case "bottom-left":
                            r = 1;
                            break;
                        case "top":
                        case "top-right":
                        case "top-left":
                            r = 0;
                    }
                    return { horizontalAlign: t, verticalAlign: r };
                }
                function Ff(a, t, r) {
                    const n = t.getMaxScale() * Yt, { maxImageWidth: l, maxImageHeight: p } = t.getMaxImageSize(a), d = Math.max(n, p * r);
                    return { verticalLineContentWidth: Math.max(n, l * r), horizontalLineContentHeight: d };
                }
                function bp(a) {
                    switch (a) {
                        case "top":
                            return 0;
                        case "center":
                            return 0.5;
                        default:
                            return 1;
                    }
                }
                function Nf(a, t, r) {
                    return !(a === M.al.horizontal || !t && !Hs(r) || t && (Fc[r] || (n = r, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(n)))));
                    var n;
                }
                function Of(a, t, r, n, l, p) {
                    const d = p[a.fontStack], m = function (v, b, S, I) {
                        if (v && v.rect) return v;
                        const A = b[S.fontStack], k = A && A[I];
                        return k ? { rect: null, metrics: k.metrics } : null;
                    }(d && d[t], l, a, t);
                    if (m === null) return null;
                    let _;
                    if (r) _ = n.verticalLineContentWidth - a.scale * Yt;
                    else {
                        const v = bp(a.verticalAlign);
                        _ = (n.horizontalLineContentHeight - a.scale * Yt) * v;
                    }
                    return { rect: m.rect, metrics: m.metrics, baselineOffset: _ };
                }
                function jf(a, t, r, n, l) {
                    const p = l[a.imageName];
                    if (!p) return null;
                    const d = p.paddedRect, m = p.displaySize, _ = { width: m[0], height: m[1], left: Ui, top: -3, advance: t ? m[1] : m[0] };
                    let v;
                    if (t) v = n.verticalLineContentWidth - m[1] * a.scale;
                    else {
                        const b = bp(a.verticalAlign);
                        v = (n.horizontalLineContentHeight - m[1] * a.scale) * b;
                    }
                    return { rect: d, metrics: _, baselineOffset: v, imageOffset: (t ? m[0] : m[1]) * a.scale - Yt * r };
                }
                function $f(a, t, r, n) {
                    if (n === 0) return;
                    const l = a[r], p = (a[r].x + l.metrics.advance * l.scale) * n;
                    for (let d = t; d <= r; d++) a[d].x -= p;
                }
                function Uf(a, t, r) {
                    const { horizontalAlign: n, verticalAlign: l } = Yh(r), p = t[0] - a.displaySize[0] * n, d = t[1] - a.displaySize[1] * l;
                    return { image: a, top: d, bottom: d + a.displaySize[1], left: p, right: p + a.displaySize[0] };
                }
                function wp(a) {
                    var t, r;
                    let n = a.left, l = a.top, p = a.right - n, d = a.bottom - l;
                    const m = (t = a.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink", _ = (r = a.image.textFitHeight) !== null && r !== void 0 ? r : "stretchOrShrink", v = (a.image.content[2] - a.image.content[0]) / (a.image.content[3] - a.image.content[1]);
                    if (_ === "proportional") {
                        if (m === "stretchOnly" && p / d < v || m === "proportional") {
                            const b = Math.ceil(d * v);
                            n *= b / p, p = b;
                        }
                    } else if (m === "proportional" && _ === "stretchOnly" && v !== 0 && p / d > v) {
                        const b = Math.ceil(p / v);
                        l *= b / d, d = b;
                    }
                    return { x1: n, y1: l, x2: n + p, y2: l + d };
                }
                function Sp(a, t, r, n, l, p) {
                    const d = a.image;
                    let m;
                    if (d.content) {
                        const N = d.content, G = d.pixelRatio || 1;
                        m = [N[0] / G, N[1] / G, d.displaySize[0] - N[2] / G, d.displaySize[1] - N[3] / G];
                    }
                    const _ = t.left * p, v = t.right * p;
                    let b, S, I, A;
                    r === "width" || r === "both" ? (A = l[0] + _ - n[3], S = l[0] + v + n[1]) : (A = l[0] + (_ + v - d.displaySize[0]) / 2, S = A + d.displaySize[0]);
                    const k = t.top * p, D = t.bottom * p;
                    return r === "height" || r === "both" ? (b = l[1] + k - n[0], I = l[1] + D + n[2]) : (b = l[1] + (k + D - d.displaySize[1]) / 2, I = b + d.displaySize[1]), { image: d, top: b, right: S, bottom: I, left: A, collisionPadding: m };
                }
                const xl = 255, Kr = 128, tn = xl * Kr;
                function Tp(a, t) {
                    const { expression: r } = t;
                    if (r.kind === "constant") return { kind: "constant", layoutSize: r.evaluate(new Tt(a + 1)) };
                    if (r.kind === "source") return { kind: "source" };
                    {
                        const { zoomStops: n, interpolationType: l } = r;
                        let p = 0;
                        for (; p < n.length && n[p] <= a;) p++;
                        p = Math.max(0, p - 1);
                        let d = p;
                        for (; d < n.length && n[d] < a + 1;) d++;
                        d = Math.min(n.length - 1, d);
                        const m = n[p], _ = n[d];
                        return r.kind === "composite" ? { kind: "composite", minZoom: m, maxZoom: _, interpolationType: l } : { kind: "camera", minZoom: m, maxZoom: _, minSize: r.evaluate(new Tt(m)), maxSize: r.evaluate(new Tt(_)), interpolationType: l };
                    }
                }
                function Jh(a, t, r) {
                    let n = "never";
                    const l = a.get(t);
                    return l ? n = l : a.get(r) && (n = "always"), n;
                }
                const Vf = ml.VectorTileFeature.types, Zf = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
                function Nc(a, t, r, n, l, p, d, m, _, v, b, S, I) {
                    const A = m ? Math.min(tn, Math.round(m[0])) : 0, k = m ? Math.min(tn, Math.round(m[1])) : 0;
                    a.emplaceBack(t, r, Math.round(32 * n), Math.round(32 * l), p, d, (A << 1) + (_ ? 1 : 0), k, 16 * v, 16 * b, 256 * S, 256 * I);
                }
                function Qh(a, t, r) {
                    a.emplaceBack(t.x, t.y, r), a.emplaceBack(t.x, t.y, r), a.emplaceBack(t.x, t.y, r), a.emplaceBack(t.x, t.y, r);
                }
                function Gf(a) {
                    for (const t of a.sections) if (Th(t.text)) return !0;
                    return !1;
                }
                class eu {
                    constructor(t) {
                        this.layoutVertexArray = new At(), this.indexArray = new ft(), this.programConfigurations = t, this.segments = new mt(), this.dynamicLayoutVertexArray = new xt(), this.opacityVertexArray = new kt(), this.hasVisibleVertices = !1, this.placedSymbolArray = new J();
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
                    }
                    upload(t, r, n, l) {
                        this.isEmpty() || (n && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Tf.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, r), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Pf.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Zf, !0), this.opacityVertexBuffer.itemSize = 1), (n || l) && this.programConfigurations.upload(t));
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
                    }
                }
                Le("SymbolBuffers", eu);
                class tu {
                    constructor(t, r, n) {
                        this.layoutVertexArray = new t(), this.layoutAttributes = r, this.indexArray = new n(), this.segments = new mt(), this.collisionVertexArray = new wt();
                    }
                    upload(t) {
                        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Mf.members, !0);
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
                    }
                }
                Le("CollisionBuffers", tu);
                class io {
                    constructor(t) {
                        this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((d) => d.id), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
                        const r = this.layers[0]._unevaluatedLayout._values;
                        this.textSizeData = Tp(this.zoom, r["text-size"]), this.iconSizeData = Tp(this.zoom, r["icon-size"]);
                        const n = this.layers[0].layout, l = n.get("symbol-sort-key"), p = n.get("symbol-z-order");
                        this.canOverlap = Jh(n, "text-overlap", "text-allow-overlap") !== "never" || Jh(n, "icon-overlap", "icon-allow-overlap") !== "never" || n.get("text-ignore-placement") || n.get("icon-ignore-placement"), this.sortFeaturesByKey = p !== "viewport-y" && !l.isConstant(), this.sortFeaturesByY = (p === "viewport-y" || p === "auto" && !this.sortFeaturesByKey) && this.canOverlap, n.get("symbol-placement") === "point" && (this.writingModes = n.get("text-writing-mode").map((d) => M.al[d])), this.stateDependentLayerIds = this.layers.filter((d) => d.isStateDependent()).map((d) => d.id), this.sourceID = t.sourceID;
                    }
                    createArrays() {
                        this.text = new eu(new Xr(this.layers, this.zoom, (t) => /^text/.test(t))), this.icon = new eu(new Xr(this.layers, this.zoom, (t) => /^icon/.test(t))), this.glyphOffsetArray = new ae(), this.lineVertexArray = new te(), this.symbolInstances = new ee(), this.textAnchorOffsets = new be();
                    }
                    calculateGlyphDependencies(t, r, n, l, p) {
                        for (let d = 0; d < t.length; d++) if (r[t.charCodeAt(d)] = !0, (n || l) && p) {
                            const m = yl[t.charAt(d)];
                            m && (r[m.charCodeAt(0)] = !0);
                        }
                    }
                    populate(t, r, n) {
                        const l = this.layers[0], p = l.layout, d = p.get("text-font"), m = p.get("text-field"), _ = p.get("icon-image"), v = (m.value.kind !== "constant" || m.value.value instanceof zi && !m.value.value.isEmpty() || m.value.value.toString().length > 0) && (d.value.kind !== "constant" || d.value.value.length > 0), b = _.value.kind !== "constant" || !!_.value.value || Object.keys(_.parameters).length > 0, S = p.get("symbol-sort-key");
                        if (this.features = [], !v && !b) return;
                        const I = r.iconDependencies, A = r.glyphDependencies, k = r.availableImages, D = new Tt(this.zoom);
                        for (const { feature: N, id: G, index: ie, sourceLayerIndex: H } of t) {
                            const C = l._featureFilter.needGeometry, F = Kn(N, C);
                            if (!l._featureFilter.filter(D, F, n)) continue;
                            let X, ue;
                            if (C || (F.geometry = Xn(N)), v) {
                                const me = l.getValueAndResolveTokens("text-field", F, n, k), xe = zi.factory(me), Ae = this.hasRTLText = this.hasRTLText || Gf(xe);
                                (!Ae || Ar.getRTLTextPluginStatus() === "unavailable" || Ae && Ar.isParsed()) && (X = Cf(xe, l, F));
                            }
                            if (b) {
                                const me = l.getValueAndResolveTokens("icon-image", F, n, k);
                                ue = me instanceof Oi ? me : Oi.fromString(me);
                            }
                            if (!X && !ue) continue;
                            const Me = this.sortFeaturesByKey ? S.evaluate(F, {}, n) : void 0;
                            if (this.features.push({ id: G, text: X, icon: ue, index: ie, sourceLayerIndex: H, geometry: F.geometry, properties: N.properties, type: Vf[N.type], sortKey: Me }), ue && (I[ue.name] = !0), X) {
                                const me = d.evaluate(F, {}, n).join(","), xe = p.get("text-rotation-alignment") !== "viewport" && p.get("symbol-placement") !== "point";
                                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(M.al.vertical) >= 0;
                                for (const Ae of X.sections) if (Ae.image) I[Ae.image.name] = !0;
                                else {
                                    const Ie = qs(X.toString()), ke = Ae.fontStack || me, we = A[ke] = A[ke] || {};
                                    this.calculateGlyphDependencies(Ae.text, we, xe, this.allowVerticalPlacement, Ie);
                                }
                            }
                        }
                        p.get("symbol-placement") === "line" && (this.features = function (N) {
                            const G = {}, ie = {}, H = [];
                            let C = 0;
                            function F(me) {
                                H.push(N[me]), C++;
                            }
                            function X(me, xe, Ae) {
                                const Ie = ie[me];
                                return delete ie[me], ie[xe] = Ie, H[Ie].geometry[0].pop(), H[Ie].geometry[0] = H[Ie].geometry[0].concat(Ae[0]), Ie;
                            }
                            function ue(me, xe, Ae) {
                                const Ie = G[xe];
                                return delete G[xe], G[me] = Ie, H[Ie].geometry[0].shift(), H[Ie].geometry[0] = Ae[0].concat(H[Ie].geometry[0]), Ie;
                            }
                            function Me(me, xe, Ae) {
                                const Ie = Ae ? xe[0][xe[0].length - 1] : xe[0][0];
                                return `${me}:${Ie.x}:${Ie.y}`;
                            }
                            for (let me = 0; me < N.length; me++) {
                                const xe = N[me], Ae = xe.geometry, Ie = xe.text ? xe.text.toString() : null;
                                if (!Ie) {
                                    F(me);
                                    continue;
                                }
                                const ke = Me(Ie, Ae), we = Me(Ie, Ae, !0);
                                if (ke in ie && we in G && ie[ke] !== G[we]) {
                                    const Be = ue(ke, we, Ae), Ge = X(ke, we, H[Be].geometry);
                                    delete G[ke], delete ie[we], ie[Me(Ie, H[Ge].geometry, !0)] = Ge, H[Be].geometry = null;
                                } else ke in ie ? X(ke, we, Ae) : we in G ? ue(ke, we, Ae) : (F(me), G[ke] = C - 1, ie[we] = C - 1);
                            }
                            return H.filter((me) => me.geometry);
                        }(this.features)), this.sortFeaturesByKey && this.features.sort((N, G) => N.sortKey - G.sortKey);
                    }
                    update(t, r, n) {
                        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, r, this.layers, n), this.icon.programConfigurations.updatePaintArrays(t, r, this.layers, n));
                    }
                    isEmpty() {
                        return this.symbolInstances.length === 0 && !this.hasRTLText;
                    }
                    uploadPending() {
                        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
                    }
                    upload(t) {
                        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
                    }
                    destroyDebugData() {
                        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
                    }
                    destroy() {
                        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
                    }
                    addToLineVertexArray(t, r) {
                        const n = this.lineVertexArray.length;
                        if (t.segment !== void 0) {
                            let l = t.dist(r[t.segment + 1]), p = t.dist(r[t.segment]);
                            const d = {};
                            for (let m = t.segment + 1; m < r.length; m++) d[m] = { x: r[m].x, y: r[m].y, tileUnitDistanceFromAnchor: l }, m < r.length - 1 && (l += r[m + 1].dist(r[m]));
                            for (let m = t.segment || 0; m >= 0; m--) d[m] = { x: r[m].x, y: r[m].y, tileUnitDistanceFromAnchor: p }, m > 0 && (p += r[m - 1].dist(r[m]));
                            for (let m = 0; m < r.length; m++) {
                                const _ = d[m];
                                this.lineVertexArray.emplaceBack(_.x, _.y, _.tileUnitDistanceFromAnchor);
                            }
                        }
                        return { lineStartIndex: n, lineLength: this.lineVertexArray.length - n };
                    }
                    addSymbols(t, r, n, l, p, d, m, _, v, b, S, I) {
                        const A = t.indexArray, k = t.layoutVertexArray, D = t.segments.prepareSegment(4 * r.length, k, A, this.canOverlap ? d.sortKey : void 0), N = this.glyphOffsetArray.length, G = D.vertexLength, ie = this.allowVerticalPlacement && m === M.al.vertical ? Math.PI / 2 : 0, H = d.text && d.text.sections;
                        for (let C = 0; C < r.length; C++) {
                            const { tl: F, tr: X, bl: ue, br: Me, tex: me, pixelOffsetTL: xe, pixelOffsetBR: Ae, minFontScaleX: Ie, minFontScaleY: ke, glyphOffset: we, isSDF: Be, sectionIndex: Ge } = r[C], Ve = D.vertexLength, Oe = we[1];
                            Nc(k, _.x, _.y, F.x, Oe + F.y, me.x, me.y, n, Be, xe.x, xe.y, Ie, ke), Nc(k, _.x, _.y, X.x, Oe + X.y, me.x + me.w, me.y, n, Be, Ae.x, xe.y, Ie, ke), Nc(k, _.x, _.y, ue.x, Oe + ue.y, me.x, me.y + me.h, n, Be, xe.x, Ae.y, Ie, ke), Nc(k, _.x, _.y, Me.x, Oe + Me.y, me.x + me.w, me.y + me.h, n, Be, Ae.x, Ae.y, Ie, ke), Qh(t.dynamicLayoutVertexArray, _, ie), A.emplaceBack(Ve, Ve + 2, Ve + 1), A.emplaceBack(Ve + 1, Ve + 2, Ve + 3), D.vertexLength += 4, D.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(we[0]), C !== r.length - 1 && Ge === r[C + 1].sectionIndex || t.programConfigurations.populatePaintArrays(k.length, d, d.index, {}, I, H && H[Ge]);
                        }
                        t.placedSymbolArray.emplaceBack(_.x, _.y, N, this.glyphOffsetArray.length - N, G, v, b, _.segment, n ? n[0] : 0, n ? n[1] : 0, l[0], l[1], m, 0, !1, 0, S);
                    }
                    _addCollisionDebugVertex(t, r, n, l, p, d) {
                        return r.emplaceBack(0, 0), t.emplaceBack(n.x, n.y, l, p, Math.round(d.x), Math.round(d.y));
                    }
                    addCollisionDebugVertices(t, r, n, l, p, d, m) {
                        const _ = p.segments.prepareSegment(4, p.layoutVertexArray, p.indexArray), v = _.vertexLength, b = p.layoutVertexArray, S = p.collisionVertexArray, I = m.anchorX, A = m.anchorY;
                        this._addCollisionDebugVertex(b, S, d, I, A, new $e(t, r)), this._addCollisionDebugVertex(b, S, d, I, A, new $e(n, r)), this._addCollisionDebugVertex(b, S, d, I, A, new $e(n, l)), this._addCollisionDebugVertex(b, S, d, I, A, new $e(t, l)), _.vertexLength += 4;
                        const k = p.indexArray;
                        k.emplaceBack(v, v + 1), k.emplaceBack(v + 1, v + 2), k.emplaceBack(v + 2, v + 3), k.emplaceBack(v + 3, v), _.primitiveLength += 4;
                    }
                    addDebugCollisionBoxes(t, r, n, l) {
                        for (let p = t; p < r; p++) {
                            const d = this.collisionBoxArray.get(p);
                            this.addCollisionDebugVertices(d.x1, d.y1, d.x2, d.y2, l ? this.textCollisionBox : this.iconCollisionBox, d.anchorPoint, n);
                        }
                    }
                    generateCollisionDebugBuffers() {
                        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new tu(zt, up.members, Kt), this.iconCollisionBox = new tu(zt, up.members, Kt);
                        for (let t = 0; t < this.symbolInstances.length; t++) {
                            const r = this.symbolInstances.get(t);
                            this.addDebugCollisionBoxes(r.textBoxStartIndex, r.textBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.iconBoxStartIndex, r.iconBoxEndIndex, r, !1), this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex, r, !1);
                        }
                    }
                    _deserializeCollisionBoxesForSymbol(t, r, n, l, p, d, m, _, v) {
                        const b = {};
                        for (let S = r; S < n; S++) {
                            const I = t.get(S);
                            b.textBox = { x1: I.x1, y1: I.y1, x2: I.x2, y2: I.y2, anchorPointX: I.anchorPointX, anchorPointY: I.anchorPointY }, b.textFeatureIndex = I.featureIndex;
                            break;
                        }
                        for (let S = l; S < p; S++) {
                            const I = t.get(S);
                            b.verticalTextBox = { x1: I.x1, y1: I.y1, x2: I.x2, y2: I.y2, anchorPointX: I.anchorPointX, anchorPointY: I.anchorPointY }, b.verticalTextFeatureIndex = I.featureIndex;
                            break;
                        }
                        for (let S = d; S < m; S++) {
                            const I = t.get(S);
                            b.iconBox = { x1: I.x1, y1: I.y1, x2: I.x2, y2: I.y2, anchorPointX: I.anchorPointX, anchorPointY: I.anchorPointY }, b.iconFeatureIndex = I.featureIndex;
                            break;
                        }
                        for (let S = _; S < v; S++) {
                            const I = t.get(S);
                            b.verticalIconBox = { x1: I.x1, y1: I.y1, x2: I.x2, y2: I.y2, anchorPointX: I.anchorPointX, anchorPointY: I.anchorPointY }, b.verticalIconFeatureIndex = I.featureIndex;
                            break;
                        }
                        return b;
                    }
                    deserializeCollisionBoxes(t) {
                        this.collisionArrays = [];
                        for (let r = 0; r < this.symbolInstances.length; r++) {
                            const n = this.symbolInstances.get(r);
                            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, n.textBoxStartIndex, n.textBoxEndIndex, n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n.iconBoxStartIndex, n.iconBoxEndIndex, n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex));
                        }
                    }
                    hasTextData() {
                        return this.text.segments.get().length > 0;
                    }
                    hasIconData() {
                        return this.icon.segments.get().length > 0;
                    }
                    hasDebugData() {
                        return this.textCollisionBox && this.iconCollisionBox;
                    }
                    hasTextCollisionBoxData() {
                        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
                    }
                    hasIconCollisionBoxData() {
                        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
                    }
                    addIndicesForPlacedSymbol(t, r) {
                        const n = t.placedSymbolArray.get(r), l = n.vertexStartIndex + 4 * n.numGlyphs;
                        for (let p = n.vertexStartIndex; p < l; p += 4) t.indexArray.emplaceBack(p, p + 2, p + 1), t.indexArray.emplaceBack(p + 1, p + 2, p + 3);
                    }
                    getSortedSymbolIndexes(t) {
                        if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
                        const r = Math.sin(t), n = Math.cos(t), l = [], p = [], d = [];
                        for (let m = 0; m < this.symbolInstances.length; ++m) {
                            d.push(m);
                            const _ = this.symbolInstances.get(m);
                            l.push(0 | Math.round(r * _.anchorX + n * _.anchorY)), p.push(_.featureIndex);
                        }
                        return d.sort((m, _) => l[m] - l[_] || p[_] - p[m]), d;
                    }
                    addToSortKeyRanges(t, r) {
                        const n = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                        n && n.sortKey === r ? n.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: r, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
                    }
                    sortFeatures(t) {
                        if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                            for (const r of this.symbolInstanceIndexes) {
                                const n = this.symbolInstances.get(r);
                                this.featureSortOrder.push(n.featureIndex), [n.rightJustifiedTextSymbolIndex, n.centerJustifiedTextSymbolIndex, n.leftJustifiedTextSymbolIndex].forEach((l, p, d) => {
                                    l >= 0 && d.indexOf(l) === p && this.addIndicesForPlacedSymbol(this.text, l);
                                }), n.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, n.verticalPlacedTextSymbolIndex), n.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, n.placedIconSymbolIndex), n.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, n.verticalPlacedIconSymbolIndex);
                            }
                            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
                        }
                    }
                }
                let Pp, Mp;
                Le("SymbolBucket", io, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), io.MAX_GLYPHS = 65535, io.addDynamicAttributes = Qh;
                var iu = {
                    get paint() {
                        return Mp = Mp || new Gt({ "icon-opacity": new He(O.paint_symbol["icon-opacity"]), "icon-color": new He(O.paint_symbol["icon-color"]), "icon-halo-color": new He(O.paint_symbol["icon-halo-color"]), "icon-halo-width": new He(O.paint_symbol["icon-halo-width"]), "icon-halo-blur": new He(O.paint_symbol["icon-halo-blur"]), "icon-translate": new je(O.paint_symbol["icon-translate"]), "icon-translate-anchor": new je(O.paint_symbol["icon-translate-anchor"]), "text-opacity": new He(O.paint_symbol["text-opacity"]), "text-color": new He(O.paint_symbol["text-color"], { runtimeType: Lt, getOverride: (a) => a.textColor, hasOverride: (a) => !!a.textColor }), "text-halo-color": new He(O.paint_symbol["text-halo-color"]), "text-halo-width": new He(O.paint_symbol["text-halo-width"]), "text-halo-blur": new He(O.paint_symbol["text-halo-blur"]), "text-translate": new je(O.paint_symbol["text-translate"]), "text-translate-anchor": new je(O.paint_symbol["text-translate-anchor"]) });
                    }, get layout() {
                        return Pp = Pp || new Gt({ "symbol-placement": new je(O.layout_symbol["symbol-placement"]), "symbol-spacing": new je(O.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new je(O.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new He(O.layout_symbol["symbol-sort-key"]), "symbol-z-order": new je(O.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new je(O.layout_symbol["icon-allow-overlap"]), "icon-overlap": new je(O.layout_symbol["icon-overlap"]), "icon-ignore-placement": new je(O.layout_symbol["icon-ignore-placement"]), "icon-optional": new je(O.layout_symbol["icon-optional"]), "icon-rotation-alignment": new je(O.layout_symbol["icon-rotation-alignment"]), "icon-size": new He(O.layout_symbol["icon-size"]), "icon-text-fit": new je(O.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new je(O.layout_symbol["icon-text-fit-padding"]), "icon-image": new He(O.layout_symbol["icon-image"]), "icon-rotate": new He(O.layout_symbol["icon-rotate"]), "icon-padding": new He(O.layout_symbol["icon-padding"]), "icon-keep-upright": new je(O.layout_symbol["icon-keep-upright"]), "icon-offset": new He(O.layout_symbol["icon-offset"]), "icon-anchor": new He(O.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new je(O.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new je(O.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new je(O.layout_symbol["text-rotation-alignment"]), "text-field": new He(O.layout_symbol["text-field"]), "text-font": new He(O.layout_symbol["text-font"]), "text-size": new He(O.layout_symbol["text-size"]), "text-max-width": new He(O.layout_symbol["text-max-width"]), "text-line-height": new je(O.layout_symbol["text-line-height"]), "text-letter-spacing": new He(O.layout_symbol["text-letter-spacing"]), "text-justify": new He(O.layout_symbol["text-justify"]), "text-radial-offset": new He(O.layout_symbol["text-radial-offset"]), "text-variable-anchor": new je(O.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new He(O.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new He(O.layout_symbol["text-anchor"]), "text-max-angle": new je(O.layout_symbol["text-max-angle"]), "text-writing-mode": new je(O.layout_symbol["text-writing-mode"]), "text-rotate": new He(O.layout_symbol["text-rotate"]), "text-padding": new je(O.layout_symbol["text-padding"]), "text-keep-upright": new je(O.layout_symbol["text-keep-upright"]), "text-transform": new He(O.layout_symbol["text-transform"]), "text-offset": new He(O.layout_symbol["text-offset"]), "text-allow-overlap": new je(O.layout_symbol["text-allow-overlap"]), "text-overlap": new je(O.layout_symbol["text-overlap"]), "text-ignore-placement": new je(O.layout_symbol["text-ignore-placement"]), "text-optional": new je(O.layout_symbol["text-optional"]) });
                    }
                };
                class Ip {
                    constructor(t) {
                        if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
                        this.type = t.property.overrides ? t.property.overrides.runtimeType : We, this.defaultValue = t;
                    }
                    evaluate(t) {
                        if (t.formattedSection) {
                            const r = this.defaultValue.property.overrides;
                            if (r && r.hasOverride(t.formattedSection)) return r.getOverride(t.formattedSection);
                        }
                        return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
                    }
                    eachChild(t) {
                        this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
                    }
                    outputDefined() {
                        return !1;
                    }
                    serialize() {
                        return null;
                    }
                }
                Le("FormatSectionOverride", Ip, { omit: ["defaultValue"] });
                class Oc extends Xi {
                    constructor(t) {
                        super(t, iu);
                    }
                    recalculate(t, r) {
                        if (super.recalculate(t, r), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
                            const n = this.layout.get("text-writing-mode");
                            if (n) {
                                const l = [];
                                for (const p of n) l.indexOf(p) < 0 && l.push(p);
                                this.layout._values["text-writing-mode"] = l;
                            } else this.layout._values["text-writing-mode"] = ["horizontal"];
                        }
                        this._setPaintOverrides();
                    }
                    getValueAndResolveTokens(t, r, n, l) {
                        const p = this.layout.get(t).evaluate(r, {}, n, l), d = this._unevaluatedLayout._values[t];
                        return d.isDataDriven() || Rn(d.value) || !p ? p : function (m, _) {
                            return _.replace(/{([^{}]+)}/g, (v, b) => m && b in m ? String(m[b]) : "");
                        }(r.properties, p);
                    }
                    createBucket(t) {
                        return new io(t);
                    }
                    queryRadius() {
                        return 0;
                    }
                    queryIntersectsFeature() {
                        throw new Error("Should take a different path in FeatureIndex");
                    }
                    _setPaintOverrides() {
                        for (const t of iu.paint.overridableProperties) {
                            if (!Oc.hasPaintOverride(this.layout, t)) continue;
                            const r = this.paint.get(t), n = new Ip(r), l = new Ds(n, r.property.specification);
                            let p = null;
                            p = r.value.kind === "constant" || r.value.kind === "source" ? new Fo("source", l) : new Bs("composite", l, r.value.zoomStops), this.paint._values[t] = new Mi(r.property, p, r.parameters);
                        }
                    }
                    _handleOverridablePaintPropertyUpdate(t, r, n) {
                        return !(!this.layout || r.isDataDriven() || n.isDataDriven()) && Oc.hasPaintOverride(this.layout, t);
                    }
                    static hasPaintOverride(t, r) {
                        const n = t.get("text-field"), l = iu.paint.properties[r];
                        let p = !1;
                        const d = (m) => {
                            for (const _ of m) if (l.overrides && l.overrides.hasOverride(_)) return void (p = !0);
                        };
                        if (n.value.kind === "constant" && n.value.value instanceof zi) d(n.value.value.sections);
                        else if (n.value.kind === "source") {
                            const m = (v) => {
                                p || (v instanceof Ke && Ft(v.value) === fn ? d(v.value.sections) : v instanceof ys ? d(v.sections) : v.eachChild(m));
                            }, _ = n.value;
                            _._styleExpression && m(_._styleExpression.expression);
                        }
                        return p;
                    }
                }
                let Cp;
                var qf = {
                    get paint() {
                        return Cp = Cp || new Gt({ "background-color": new je(O.paint_background["background-color"]), "background-pattern": new Qo(O.paint_background["background-pattern"]), "background-opacity": new je(O.paint_background["background-opacity"]) });
                    }
                };
                class Hf extends Xi {
                    constructor(t) {
                        super(t, qf);
                    }
                }
                let Ap;
                var Wf = {
                    get paint() {
                        return Ap = Ap || new Gt({ "raster-opacity": new je(O.paint_raster["raster-opacity"]), "raster-hue-rotate": new je(O.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new je(O.paint_raster["raster-brightness-min"]), "raster-brightness-max": new je(O.paint_raster["raster-brightness-max"]), "raster-saturation": new je(O.paint_raster["raster-saturation"]), "raster-contrast": new je(O.paint_raster["raster-contrast"]), "raster-resampling": new je(O.paint_raster["raster-resampling"]), "raster-fade-duration": new je(O.paint_raster["raster-fade-duration"]) });
                    }
                };
                class Xf extends Xi {
                    constructor(t) {
                        super(t, Wf);
                    }
                }
                class Kf extends Xi {
                    constructor(t) {
                        super(t, {}), this.onAdd = (r) => {
                            this.implementation.onAdd && this.implementation.onAdd(r, r.painter.context.gl);
                        }, this.onRemove = (r) => {
                            this.implementation.onRemove && this.implementation.onRemove(r, r.painter.context.gl);
                        }, this.implementation = t;
                    }
                    is3D() {
                        return this.implementation.renderingMode === "3d";
                    }
                    hasOffscreenPass() {
                        return this.implementation.prerender !== void 0;
                    }
                    recalculate() {
                    }
                    updateTransitions() {
                    }
                    hasTransition() {
                        return !1;
                    }
                    serialize() {
                        throw new Error("Custom layers cannot be serialized");
                    }
                }
                class Yf {
                    constructor(t) {
                        this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
                            this._triggered = !1, this._methodToThrottle();
                        });
                    }
                    trigger() {
                        this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
                            this._triggered = !1, this._methodToThrottle();
                        }, 0));
                    }
                    remove() {
                        delete this._channel, this._methodToThrottle = () => {
                        };
                    }
                }
                const Jf = { once: !0 }, ru = 63710088e-1;
                class rn {
                    constructor(t, r) {
                        if (isNaN(t) || isNaN(r)) throw new Error(`Invalid LngLat object: (${t}, ${r})`);
                        if (this.lng = +t, this.lat = +r, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
                    }
                    wrap() {
                        return new rn(Nr(this.lng, -180, 180), this.lat);
                    }
                    toArray() {
                        return [this.lng, this.lat];
                    }
                    toString() {
                        return `LngLat(${this.lng}, ${this.lat})`;
                    }
                    distanceTo(t) {
                        const r = Math.PI / 180, n = this.lat * r, l = t.lat * r, p = Math.sin(n) * Math.sin(l) + Math.cos(n) * Math.cos(l) * Math.cos((t.lng - this.lng) * r);
                        return ru * Math.acos(Math.min(p, 1));
                    }
                    static convert(t) {
                        if (t instanceof rn) return t;
                        if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new rn(Number(t[0]), Number(t[1]));
                        if (!Array.isArray(t) && typeof t == "object" && t !== null) return new rn(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
                        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
                    }
                }
                const kp = 2 * Math.PI * ru;
                function zp(a) {
                    return kp * Math.cos(a * Math.PI / 180);
                }
                function Ep(a) {
                    return (180 + a) / 360;
                }
                function Rp(a) {
                    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a * Math.PI / 360))) / 360;
                }
                function Dp(a, t) {
                    return a / zp(t);
                }
                function au(a) {
                    return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90;
                }
                function Lp(a, t) {
                    return a * zp(au(t));
                }
                class bl {
                    constructor(t, r, n = 0) {
                        this.x = +t, this.y = +r, this.z = +n;
                    }
                    static fromLngLat(t, r = 0) {
                        const n = rn.convert(t);
                        return new bl(Ep(n.lng), Rp(n.lat), Dp(r, n.lat));
                    }
                    toLngLat() {
                        return new rn(360 * this.x - 180, au(this.y));
                    }
                    toAltitude() {
                        return Lp(this.z, this.y);
                    }
                    meterInMercatorCoordinateUnits() {
                        return 1 / kp * (t = au(this.y), 1 / Math.cos(t * Math.PI / 180));
                        var t;
                    }
                }
                function Bp(a, t, r) {
                    var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
                    return [a * n - 2 * Math.PI * 6378137 / 2, t * n - 2 * Math.PI * 6378137 / 2];
                }
                class nu {
                    constructor(t, r, n) {
                        if (!function (l, p, d) {
                            return !(l < 0 || l > 25 || d < 0 || d >= Math.pow(2, l) || p < 0 || p >= Math.pow(2, l));
                        }(t, r, n)) throw new Error(`x=${r}, y=${n}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
                        this.z = t, this.x = r, this.y = n, this.key = ro(0, t, t, r, n);
                    }
                    equals(t) {
                        return this.z === t.z && this.x === t.x && this.y === t.y;
                    }
                    url(t, r, n) {
                        const l = (d = this.y, m = this.z, _ = Bp(256 * (p = this.x), 256 * (d = Math.pow(2, m) - d - 1), m), v = Bp(256 * (p + 1), 256 * (d + 1), m), _[0] + "," + _[1] + "," + v[0] + "," + v[1]);
                        var p, d, m, _, v;
                        const b = function (S, I, A) {
                            let k, D = "";
                            for (let N = S; N > 0; N--) k = 1 << N - 1, D += (I & k ? 1 : 0) + (A & k ? 2 : 0);
                            return D;
                        }(this.z, this.x, this.y);
                        return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(n === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r > 1 ? "@2x" : "").replace(/{quadkey}/g, b).replace(/{bbox-epsg-3857}/g, l);
                    }
                    isChildOf(t) {
                        const r = this.z - t.z;
                        return r > 0 && t.x === this.x >> r && t.y === this.y >> r;
                    }
                    getTilePoint(t) {
                        const r = Math.pow(2, this.z);
                        return new $e((t.x * r - this.x) * yt, (t.y * r - this.y) * yt);
                    }
                    toString() {
                        return `${this.z}/${this.x}/${this.y}`;
                    }
                }
                class Fp {
                    constructor(t, r) {
                        this.wrap = t, this.canonical = r, this.key = ro(t, r.z, r.z, r.x, r.y);
                    }
                }
                class ar {
                    constructor(t, r, n, l, p) {
                        if (this.terrainRttPosMatrix32f = null, t < n) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${n}`);
                        this.overscaledZ = t, this.wrap = r, this.canonical = new nu(n, +l, +p), this.key = ro(r, t, n, l, p);
                    }
                    clone() {
                        return new ar(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
                    }
                    equals(t) {
                        return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
                    }
                    scaledTo(t) {
                        if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
                        const r = this.canonical.z - t;
                        return t > this.canonical.z ? new ar(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new ar(t, this.wrap, t, this.canonical.x >> r, this.canonical.y >> r);
                    }
                    calculateScaledKey(t, r) {
                        if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
                        const n = this.canonical.z - t;
                        return t > this.canonical.z ? ro(this.wrap * +r, t, this.canonical.z, this.canonical.x, this.canonical.y) : ro(this.wrap * +r, t, t, this.canonical.x >> n, this.canonical.y >> n);
                    }
                    isChildOf(t) {
                        if (t.wrap !== this.wrap) return !1;
                        const r = this.canonical.z - t.canonical.z;
                        return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> r && t.canonical.y === this.canonical.y >> r;
                    }
                    children(t) {
                        if (this.overscaledZ >= t) return [new ar(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
                        const r = this.canonical.z + 1, n = 2 * this.canonical.x, l = 2 * this.canonical.y;
                        return [new ar(r, this.wrap, r, n, l), new ar(r, this.wrap, r, n + 1, l), new ar(r, this.wrap, r, n, l + 1), new ar(r, this.wrap, r, n + 1, l + 1)];
                    }
                    isLessThan(t) {
                        return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
                    }
                    wrapped() {
                        return new ar(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
                    }
                    unwrapTo(t) {
                        return new ar(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
                    }
                    overscaleFactor() {
                        return Math.pow(2, this.overscaledZ - this.canonical.z);
                    }
                    toUnwrapped() {
                        return new Fp(this.wrap, this.canonical);
                    }
                    toString() {
                        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
                    }
                    getTilePoint(t) {
                        return this.canonical.getTilePoint(new bl(t.x - this.wrap, t.y));
                    }
                }
                function ro(a, t, r, n, l) {
                    (a *= 2) < 0 && (a = -1 * a - 1);
                    const p = 1 << r;
                    return (p * p * a + p * l + n).toString(36) + r.toString(36) + t.toString(36);
                }
                Le("CanonicalTileID", nu), Le("OverscaledTileID", ar, { omit: ["terrainRttPosMatrix32f"] });
                class Np {
                    constructor(t, r, n, l = 1, p = 1, d = 1, m = 0) {
                        if (this.uid = t, r.height !== r.width) throw new RangeError("DEM tiles must be square");
                        if (n && !["mapbox", "terrarium", "custom"].includes(n)) return void wi(`"${n}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
                        this.stride = r.height;
                        const _ = this.dim = r.height - 2;
                        switch (this.data = new Uint32Array(r.data.buffer), n) {
                            case "terrarium":
                                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                                break;
                            case "custom":
                                this.redFactor = l, this.greenFactor = p, this.blueFactor = d, this.baseShift = m;
                                break;
                            default:
                                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
                        }
                        for (let v = 0; v < _; v++) this.data[this._idx(-1, v)] = this.data[this._idx(0, v)], this.data[this._idx(_, v)] = this.data[this._idx(_ - 1, v)], this.data[this._idx(v, -1)] = this.data[this._idx(v, 0)], this.data[this._idx(v, _)] = this.data[this._idx(v, _ - 1)];
                        this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(_, -1)] = this.data[this._idx(_ - 1, 0)], this.data[this._idx(-1, _)] = this.data[this._idx(0, _ - 1)], this.data[this._idx(_, _)] = this.data[this._idx(_ - 1, _ - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
                        for (let v = 0; v < _; v++) for (let b = 0; b < _; b++) {
                            const S = this.get(v, b);
                            S > this.max && (this.max = S), S < this.min && (this.min = S);
                        }
                    }
                    get(t, r) {
                        const n = new Uint8Array(this.data.buffer), l = 4 * this._idx(t, r);
                        return this.unpack(n[l], n[l + 1], n[l + 2]);
                    }
                    getUnpackVector() {
                        return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
                    }
                    _idx(t, r) {
                        if (t < -1 || t >= this.dim + 1 || r < -1 || r >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
                        return (r + 1) * this.stride + (t + 1);
                    }
                    unpack(t, r, n) {
                        return t * this.redFactor + r * this.greenFactor + n * this.blueFactor - this.baseShift;
                    }
                    getPixels() {
                        return new rr({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
                    }
                    backfillBorder(t, r, n) {
                        if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
                        let l = r * this.dim, p = r * this.dim + this.dim, d = n * this.dim, m = n * this.dim + this.dim;
                        switch (r) {
                            case -1:
                                l = p - 1;
                                break;
                            case 1:
                                p = l + 1;
                        }
                        switch (n) {
                            case -1:
                                d = m - 1;
                                break;
                            case 1:
                                m = d + 1;
                        }
                        const _ = -r * this.dim, v = -n * this.dim;
                        for (let b = d; b < m; b++) for (let S = l; S < p; S++) this.data[this._idx(S, b)] = t.data[this._idx(S + _, b + v)];
                    }
                }
                Le("DEMData", Np);
                class Op {
                    constructor(t) {
                        this._stringToNumber = {}, this._numberToString = [];
                        for (let r = 0; r < t.length; r++) {
                            const n = t[r];
                            this._stringToNumber[n] = r, this._numberToString[r] = n;
                        }
                    }
                    encode(t) {
                        return this._stringToNumber[t];
                    }
                    decode(t) {
                        if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
                        return this._numberToString[t];
                    }
                }
                class jp {
                    constructor(t, r, n, l, p) {
                        this.type = "Feature", this._vectorTileFeature = t, t._z = r, t._x = n, t._y = l, this.properties = t.properties, this.id = p;
                    }
                    get geometry() {
                        return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
                    }
                    set geometry(t) {
                        this._geometry = t;
                    }
                    toJSON() {
                        const t = { geometry: this.geometry };
                        for (const r in this) r !== "_geometry" && r !== "_vectorTileFeature" && (t[r] = this[r]);
                        return t;
                    }
                }
                class $p {
                    constructor(t, r) {
                        this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Ka(yt, 16, 0), this.grid3D = new Ka(yt, 16, 0), this.featureIndexArray = new _e(), this.promoteId = r;
                    }
                    insert(t, r, n, l, p, d) {
                        const m = this.featureIndexArray.length;
                        this.featureIndexArray.emplaceBack(n, l, p);
                        const _ = d ? this.grid3D : this.grid;
                        for (let v = 0; v < r.length; v++) {
                            const b = r[v], S = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                            for (let I = 0; I < b.length; I++) {
                                const A = b[I];
                                S[0] = Math.min(S[0], A.x), S[1] = Math.min(S[1], A.y), S[2] = Math.max(S[2], A.x), S[3] = Math.max(S[3], A.y);
                            }
                            S[0] < yt && S[1] < yt && S[2] >= 0 && S[3] >= 0 && _.insert(m, S[0], S[1], S[2], S[3]);
                        }
                    }
                    loadVTLayers() {
                        return this.vtLayers || (this.vtLayers = new ml.VectorTile(new Hh(this.rawTileData)).layers, this.sourceLayerCoder = new Op(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
                    }
                    query(t, r, n, l) {
                        this.loadVTLayers();
                        const p = t.params, d = yt / t.tileSize / t.scale, m = Fn(p.filter), _ = t.queryGeometry, v = t.queryPadding * d, b = Vp(_), S = this.grid.query(b.minX - v, b.minY - v, b.maxX + v, b.maxY + v), I = Vp(t.cameraQueryGeometry), A = this.grid3D.query(I.minX - v, I.minY - v, I.maxX + v, I.maxY + v, (N, G, ie, H) => function (C, F, X, ue, Me) {
                            for (const xe of C) if (F <= xe.x && X <= xe.y && ue >= xe.x && Me >= xe.y) return !0;
                            const me = [new $e(F, X), new $e(F, Me), new $e(ue, Me), new $e(ue, X)];
                            if (C.length > 2) {
                                for (const xe of me) if (Yn(C, xe)) return !0;
                            }
                            for (let xe = 0; xe < C.length - 1; xe++) if (Od(C[xe], C[xe + 1], me)) return !0;
                            return !1;
                        }(t.cameraQueryGeometry, N - v, G - v, ie + v, H + v));
                        for (const N of A) S.push(N);
                        S.sort(Qf);
                        const k = {};
                        let D;
                        for (let N = 0; N < S.length; N++) {
                            const G = S[N];
                            if (G === D) continue;
                            D = G;
                            const ie = this.featureIndexArray.get(G);
                            let H = null;
                            this.loadMatchingFeature(k, ie.bucketIndex, ie.sourceLayerIndex, ie.featureIndex, m, p.layers, p.availableImages, r, n, l, (C, F, X) => (H || (H = Xn(C)), F.queryIntersectsFeature({ queryGeometry: _, feature: C, featureState: X, geometry: H, zoom: this.z, transform: t.transform, pixelsToTileUnits: d, pixelPosMatrix: t.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: t.getElevation })));
                        }
                        return k;
                    }
                    loadMatchingFeature(t, r, n, l, p, d, m, _, v, b, S) {
                        const I = this.bucketLayerIDs[r];
                        if (d && !I.some((N) => d.has(N))) return;
                        const A = this.sourceLayerCoder.decode(n), k = this.vtLayers[A].feature(l);
                        if (p.needGeometry) {
                            const N = Kn(k, !0);
                            if (!p.filter(new Tt(this.tileID.overscaledZ), N, this.tileID.canonical)) return;
                        } else if (!p.filter(new Tt(this.tileID.overscaledZ), k)) return;
                        const D = this.getId(k, A);
                        for (let N = 0; N < I.length; N++) {
                            const G = I[N];
                            if (d && !d.has(G)) continue;
                            const ie = _[G];
                            if (!ie) continue;
                            let H = {};
                            D && b && (H = b.getState(ie.sourceLayer || "_geojsonTileLayer", D));
                            const C = Di({}, v[G]);
                            C.paint = Up(C.paint, ie.paint, k, H, m), C.layout = Up(C.layout, ie.layout, k, H, m);
                            const F = !S || S(k, ie, H);
                            if (!F) continue;
                            const X = new jp(k, this.z, this.x, this.y, D);
                            X.layer = C;
                            let ue = t[G];
                            ue === void 0 && (ue = t[G] = []), ue.push({ featureIndex: l, feature: X, intersectionZ: F });
                        }
                    }
                    lookupSymbolFeatures(t, r, n, l, p, d, m, _) {
                        const v = {};
                        this.loadVTLayers();
                        const b = Fn(p);
                        for (const S of t) this.loadMatchingFeature(v, n, l, S, b, d, m, _, r);
                        return v;
                    }
                    hasLayer(t) {
                        for (const r of this.bucketLayerIDs) for (const n of r) if (t === n) return !0;
                        return !1;
                    }
                    getId(t, r) {
                        var n;
                        let l = t.id;
                        return this.promoteId && (l = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r]], typeof l == "boolean" && (l = Number(l)), l === void 0 && (!((n = t.properties) === null || n === void 0) && n.cluster) && this.promoteId && (l = Number(t.properties.cluster_id))), l;
                    }
                }
                function Up(a, t, r, n, l) {
                    return ea(a, (p, d) => {
                        const m = t instanceof Xs ? t.get(d) : null;
                        return m && m.evaluate ? m.evaluate(r, n, l) : m;
                    });
                }
                function Vp(a) {
                    let t = 1 / 0, r = 1 / 0, n = -1 / 0, l = -1 / 0;
                    for (const p of a) t = Math.min(t, p.x), r = Math.min(r, p.y), n = Math.max(n, p.x), l = Math.max(l, p.y);
                    return { minX: t, minY: r, maxX: n, maxY: l };
                }
                function Qf(a, t) {
                    return t - a;
                }
                function Zp(a, t, r, n, l) {
                    const p = [];
                    for (let d = 0; d < a.length; d++) {
                        const m = a[d];
                        let _;
                        for (let v = 0; v < m.length - 1; v++) {
                            let b = m[v], S = m[v + 1];
                            b.x < t && S.x < t || (b.x < t ? b = new $e(t, b.y + (t - b.x) / (S.x - b.x) * (S.y - b.y))._round() : S.x < t && (S = new $e(t, b.y + (t - b.x) / (S.x - b.x) * (S.y - b.y))._round()), b.y < r && S.y < r || (b.y < r ? b = new $e(b.x + (r - b.y) / (S.y - b.y) * (S.x - b.x), r)._round() : S.y < r && (S = new $e(b.x + (r - b.y) / (S.y - b.y) * (S.x - b.x), r)._round()), b.x >= n && S.x >= n || (b.x >= n ? b = new $e(n, b.y + (n - b.x) / (S.x - b.x) * (S.y - b.y))._round() : S.x >= n && (S = new $e(n, b.y + (n - b.x) / (S.x - b.x) * (S.y - b.y))._round()), b.y >= l && S.y >= l || (b.y >= l ? b = new $e(b.x + (l - b.y) / (S.y - b.y) * (S.x - b.x), l)._round() : S.y >= l && (S = new $e(b.x + (l - b.y) / (S.y - b.y) * (S.x - b.x), l)._round()), _ && b.equals(_[_.length - 1]) || (_ = [b], p.push(_)), _.push(S)))));
                        }
                    }
                    return p;
                }
                Le("FeatureIndex", $p, { omit: ["rawTileData", "sourceLayerCoder"] });
                class an extends $e {
                    constructor(t, r, n, l) {
                        super(t, r), this.angle = n, l !== void 0 && (this.segment = l);
                    }
                    clone() {
                        return new an(this.x, this.y, this.angle, this.segment);
                    }
                }
                function Gp(a, t, r, n, l) {
                    if (t.segment === void 0 || r === 0) return !0;
                    let p = t, d = t.segment + 1, m = 0;
                    for (; m > -r / 2;) {
                        if (d--, d < 0) return !1;
                        m -= a[d].dist(p), p = a[d];
                    }
                    m += a[d].dist(a[d + 1]), d++;
                    const _ = [];
                    let v = 0;
                    for (; m < r / 2;) {
                        const b = a[d], S = a[d + 1];
                        if (!S) return !1;
                        let I = a[d - 1].angleTo(b) - b.angleTo(S);
                        for (I = Math.abs((I + 3 * Math.PI) % (2 * Math.PI) - Math.PI), _.push({ distance: m, angleDelta: I }), v += I; m - _[0].distance > n;) v -= _.shift().angleDelta;
                        if (v > l) return !1;
                        d++, m += b.dist(S);
                    }
                    return !0;
                }
                function qp(a) {
                    let t = 0;
                    for (let r = 0; r < a.length - 1; r++) t += a[r].dist(a[r + 1]);
                    return t;
                }
                function Hp(a, t, r) {
                    return a ? 0.6 * t * r : 0;
                }
                function Wp(a, t) {
                    return Math.max(a ? a.right - a.left : 0, t ? t.right - t.left : 0);
                }
                function em(a, t, r, n, l, p) {
                    const d = Hp(r, l, p), m = Wp(r, n) * p;
                    let _ = 0;
                    const v = qp(a) / 2;
                    for (let b = 0; b < a.length - 1; b++) {
                        const S = a[b], I = a[b + 1], A = S.dist(I);
                        if (_ + A > v) {
                            const k = (v - _) / A, D = gr.number(S.x, I.x, k), N = gr.number(S.y, I.y, k), G = new an(D, N, I.angleTo(S), b);
                            return G._round(), !d || Gp(a, G, m, d, t) ? G : void 0;
                        }
                        _ += A;
                    }
                }
                function tm(a, t, r, n, l, p, d, m, _) {
                    const v = Hp(n, p, d), b = Wp(n, l), S = b * d, I = a[0].x === 0 || a[0].x === _ || a[0].y === 0 || a[0].y === _;
                    return t - S < t / 4 && (t = S + t / 4), Xp(a, I ? t / 2 * m % t : (b / 2 + 2 * p) * d * m % t, t, v, r, S, I, !1, _);
                }
                function Xp(a, t, r, n, l, p, d, m, _) {
                    const v = p / 2, b = qp(a);
                    let S = 0, I = t - r, A = [];
                    for (let k = 0; k < a.length - 1; k++) {
                        const D = a[k], N = a[k + 1], G = D.dist(N), ie = N.angleTo(D);
                        for (; I + r < S + G;) {
                            I += r;
                            const H = (I - S) / G, C = gr.number(D.x, N.x, H), F = gr.number(D.y, N.y, H);
                            if (C >= 0 && C < _ && F >= 0 && F < _ && I - v >= 0 && I + v <= b) {
                                const X = new an(C, F, ie, k);
                                X._round(), n && !Gp(a, X, p, n, l) || A.push(X);
                            }
                        }
                        S += G;
                    }
                    return m || A.length || d || (A = Xp(a, S / 2, r, n, l, p, d, !0, _)), A;
                }
                Le("Anchor", an);
                const wl = Ui;
                function Kp(a, t, r, n) {
                    const l = [], p = a.image, d = p.pixelRatio, m = p.paddedRect.w - 2 * wl, _ = p.paddedRect.h - 2 * wl;
                    let v = { x1: a.left, y1: a.top, x2: a.right, y2: a.bottom };
                    const b = p.stretchX || [[0, m]], S = p.stretchY || [[0, _]], I = (we, Be) => we + Be[1] - Be[0], A = b.reduce(I, 0), k = S.reduce(I, 0), D = m - A, N = _ - k;
                    let G = 0, ie = A, H = 0, C = k, F = 0, X = D, ue = 0, Me = N;
                    if (p.content && n) {
                        const we = p.content, Be = we[2] - we[0], Ge = we[3] - we[1];
                        (p.textFitWidth || p.textFitHeight) && (v = wp(a)), G = jc(b, 0, we[0]), H = jc(S, 0, we[1]), ie = jc(b, we[0], we[2]), C = jc(S, we[1], we[3]), F = we[0] - G, ue = we[1] - H, X = Be - ie, Me = Ge - C;
                    }
                    const me = v.x1, xe = v.y1, Ae = v.x2 - me, Ie = v.y2 - xe, ke = (we, Be, Ge, Ve) => {
                        const Oe = $c(we.stretch - G, ie, Ae, me), at = Uc(we.fixed - F, X, we.stretch, A), Ot = $c(Be.stretch - H, C, Ie, xe), Jt = Uc(Be.fixed - ue, Me, Be.stretch, k), xi = $c(Ge.stretch - G, ie, Ae, me), nr = Uc(Ge.fixed - F, X, Ge.stretch, A), Vi = $c(Ve.stretch - H, C, Ie, xe), pi = Uc(Ve.fixed - ue, Me, Ve.stretch, k), Et = new $e(Oe, Ot), ri = new $e(xi, Ot), di = new $e(xi, Vi), fi = new $e(Oe, Vi), Ri = new $e(at / d, Jt / d), sr = new $e(nr / d, pi / d), ai = t * Math.PI / 180;
                        if (ai) {
                            const ni = Math.sin(ai), si = Math.cos(ai), Wt = [si, -ni, ni, si];
                            Et._matMult(Wt), ri._matMult(Wt), fi._matMult(Wt), di._matMult(Wt);
                        }
                        const Zi = we.stretch + we.fixed, Qt = Be.stretch + Be.fixed;
                        return { tl: Et, tr: ri, bl: fi, br: di, tex: { x: p.paddedRect.x + wl + Zi, y: p.paddedRect.y + wl + Qt, w: Ge.stretch + Ge.fixed - Zi, h: Ve.stretch + Ve.fixed - Qt }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Ri, pixelOffsetBR: sr, minFontScaleX: X / d / Ae, minFontScaleY: Me / d / Ie, isSDF: r };
                    };
                    if (n && (p.stretchX || p.stretchY)) {
                        const we = Yp(b, D, A), Be = Yp(S, N, k);
                        for (let Ge = 0; Ge < we.length - 1; Ge++) {
                            const Ve = we[Ge], Oe = we[Ge + 1];
                            for (let at = 0; at < Be.length - 1; at++) l.push(ke(Ve, Be[at], Oe, Be[at + 1]));
                        }
                    } else l.push(ke({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: m + 1 }, { fixed: 0, stretch: _ + 1 }));
                    return l;
                }
                function jc(a, t, r) {
                    let n = 0;
                    for (const l of a) n += Math.max(t, Math.min(r, l[1])) - Math.max(t, Math.min(r, l[0]));
                    return n;
                }
                function Yp(a, t, r) {
                    const n = [{ fixed: -1, stretch: 0 }];
                    for (const [l, p] of a) {
                        const d = n[n.length - 1];
                        n.push({ fixed: l - d.stretch, stretch: d.stretch }), n.push({ fixed: l - d.stretch, stretch: d.stretch + (p - l) });
                    }
                    return n.push({ fixed: t + wl, stretch: r }), n;
                }
                function $c(a, t, r, n) {
                    return a / t * r + n;
                }
                function Uc(a, t, r, n) {
                    return a - t * r / n;
                }
                class Vc {
                    constructor(t, r, n, l, p, d, m, _, v, b) {
                        var S;
                        if (this.boxStartIndex = t.length, v) {
                            let I = d.top, A = d.bottom;
                            const k = d.collisionPadding;
                            k && (I -= k[1], A += k[3]);
                            let D = A - I;
                            D > 0 && (D = Math.max(10, D), this.circleDiameter = D);
                        } else {
                            const I = !((S = d.image) === null || S === void 0) && S.content && (d.image.textFitWidth || d.image.textFitHeight) ? wp(d) : { x1: d.left, y1: d.top, x2: d.right, y2: d.bottom };
                            I.y1 = I.y1 * m - _[0], I.y2 = I.y2 * m + _[2], I.x1 = I.x1 * m - _[3], I.x2 = I.x2 * m + _[1];
                            const A = d.collisionPadding;
                            if (A && (I.x1 -= A[0] * m, I.y1 -= A[1] * m, I.x2 += A[2] * m, I.y2 += A[3] * m), b) {
                                const k = new $e(I.x1, I.y1), D = new $e(I.x2, I.y1), N = new $e(I.x1, I.y2), G = new $e(I.x2, I.y2), ie = b * Math.PI / 180;
                                k._rotate(ie), D._rotate(ie), N._rotate(ie), G._rotate(ie), I.x1 = Math.min(k.x, D.x, N.x, G.x), I.x2 = Math.max(k.x, D.x, N.x, G.x), I.y1 = Math.min(k.y, D.y, N.y, G.y), I.y2 = Math.max(k.y, D.y, N.y, G.y);
                            }
                            t.emplaceBack(r.x, r.y, I.x1, I.y1, I.x2, I.y2, n, l, p);
                        }
                        this.boxEndIndex = t.length;
                    }
                }
                class im {
                    constructor(t = [], r = (n, l) => n < l ? -1 : n > l ? 1 : 0) {
                        if (this.data = t, this.length = this.data.length, this.compare = r, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
                    }
                    push(t) {
                        this.data.push(t), this._up(this.length++);
                    }
                    pop() {
                        if (this.length === 0) return;
                        const t = this.data[0], r = this.data.pop();
                        return --this.length > 0 && (this.data[0] = r, this._down(0)), t;
                    }
                    peek() {
                        return this.data[0];
                    }
                    _up(t) {
                        const { data: r, compare: n } = this, l = r[t];
                        for (; t > 0;) {
                            const p = t - 1 >> 1, d = r[p];
                            if (n(l, d) >= 0) break;
                            r[t] = d, t = p;
                        }
                        r[t] = l;
                    }
                    _down(t) {
                        const { data: r, compare: n } = this, l = this.length >> 1, p = r[t];
                        for (; t < l;) {
                            let d = 1 + (t << 1);
                            const m = d + 1;
                            if (m < this.length && n(r[m], r[d]) < 0 && (d = m), n(r[d], p) >= 0) break;
                            r[t] = r[d], t = d;
                        }
                        r[t] = p;
                    }
                }
                function rm(a, t = 1, r = !1) {
                    let n = 1 / 0, l = 1 / 0, p = -1 / 0, d = -1 / 0;
                    const m = a[0];
                    for (let A = 0; A < m.length; A++) {
                        const k = m[A];
                        (!A || k.x < n) && (n = k.x), (!A || k.y < l) && (l = k.y), (!A || k.x > p) && (p = k.x), (!A || k.y > d) && (d = k.y);
                    }
                    const _ = Math.min(p - n, d - l);
                    let v = _ / 2;
                    const b = new im([], am);
                    if (_ === 0) return new $e(n, l);
                    for (let A = n; A < p; A += _) for (let k = l; k < d; k += _) b.push(new ao(A + v, k + v, v, a));
                    let S = function (A) {
                        let k = 0, D = 0, N = 0;
                        const G = A[0];
                        for (let ie = 0, H = G.length, C = H - 1; ie < H; C = ie++) {
                            const F = G[ie], X = G[C], ue = F.x * X.y - X.x * F.y;
                            D += (F.x + X.x) * ue, N += (F.y + X.y) * ue, k += 3 * ue;
                        }
                        return new ao(D / k, N / k, 0, A);
                    }(a), I = b.length;
                    for (; b.length;) {
                        const A = b.pop();
                        (A.d > S.d || !S.d) && (S = A, r && console.log("found best %d after %d probes", Math.round(1e4 * A.d) / 1e4, I)), A.max - S.d <= t || (v = A.h / 2, b.push(new ao(A.p.x - v, A.p.y - v, v, a)), b.push(new ao(A.p.x + v, A.p.y - v, v, a)), b.push(new ao(A.p.x - v, A.p.y + v, v, a)), b.push(new ao(A.p.x + v, A.p.y + v, v, a)), I += 4);
                    }
                    return r && (console.log(`num probes: ${I}`), console.log(`best distance: ${S.d}`)), S.p;
                }
                function am(a, t) {
                    return t.max - a.max;
                }
                function ao(a, t, r, n) {
                    this.p = new $e(a, t), this.h = r, this.d = function (l, p) {
                        let d = !1, m = 1 / 0;
                        for (let _ = 0; _ < p.length; _++) {
                            const v = p[_];
                            for (let b = 0, S = v.length, I = S - 1; b < S; I = b++) {
                                const A = v[b], k = v[I];
                                A.y > l.y != k.y > l.y && l.x < (k.x - A.x) * (l.y - A.y) / (k.y - A.y) + A.x && (d = !d), m = Math.min(m, zu(l, A, k));
                            }
                        }
                        return (d ? 1 : -1) * Math.sqrt(m);
                    }(this.p, n), this.max = this.d + this.h * Math.SQRT2;
                }
                var vi;
                M.aB = void 0, (vi = M.aB || (M.aB = {}))[vi.center = 1] = "center", vi[vi.left = 2] = "left", vi[vi.right = 3] = "right", vi[vi.top = 4] = "top", vi[vi.bottom = 5] = "bottom", vi[vi["top-left"] = 6] = "top-left", vi[vi["top-right"] = 7] = "top-right", vi[vi["bottom-left"] = 8] = "bottom-left", vi[vi["bottom-right"] = 9] = "bottom-right";
                const nn = 7, su = Number.POSITIVE_INFINITY;
                function Jp(a, t) {
                    return t[1] !== su ? function (r, n, l) {
                        let p = 0, d = 0;
                        switch (n = Math.abs(n), l = Math.abs(l), r) {
                            case "top-right":
                            case "top-left":
                            case "top":
                                d = l - nn;
                                break;
                            case "bottom-right":
                            case "bottom-left":
                            case "bottom":
                                d = -l + nn;
                        }
                        switch (r) {
                            case "top-right":
                            case "bottom-right":
                            case "right":
                                p = -n;
                                break;
                            case "top-left":
                            case "bottom-left":
                            case "left":
                                p = n;
                        }
                        return [p, d];
                    }(a, t[0], t[1]) : function (r, n) {
                        let l = 0, p = 0;
                        n < 0 && (n = 0);
                        const d = n / Math.SQRT2;
                        switch (r) {
                            case "top-right":
                            case "top-left":
                                p = d - nn;
                                break;
                            case "bottom-right":
                            case "bottom-left":
                                p = -d + nn;
                                break;
                            case "bottom":
                                p = -n + nn;
                                break;
                            case "top":
                                p = n - nn;
                        }
                        switch (r) {
                            case "top-right":
                            case "bottom-right":
                                l = -d;
                                break;
                            case "top-left":
                            case "bottom-left":
                                l = d;
                                break;
                            case "left":
                                l = n;
                                break;
                            case "right":
                                l = -n;
                        }
                        return [l, p];
                    }(a, t[0]);
                }
                function Qp(a, t, r) {
                    var n;
                    const l = a.layout, p = (n = l.get("text-variable-anchor-offset")) === null || n === void 0 ? void 0 : n.evaluate(t, {}, r);
                    if (p) {
                        const m = p.values, _ = [];
                        for (let v = 0; v < m.length; v += 2) {
                            const b = _[v] = m[v], S = m[v + 1].map((I) => I * Yt);
                            b.startsWith("top") ? S[1] -= nn : b.startsWith("bottom") && (S[1] += nn), _[v + 1] = S;
                        }
                        return new Pi(_);
                    }
                    const d = l.get("text-variable-anchor");
                    if (d) {
                        let m;
                        m = a._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [l.get("text-radial-offset").evaluate(t, {}, r) * Yt, su] : l.get("text-offset").evaluate(t, {}, r).map((v) => v * Yt);
                        const _ = [];
                        for (const v of d) _.push(v, Jp(v, m));
                        return new Pi(_);
                    }
                    return null;
                }
                function ou(a) {
                    switch (a) {
                        case "right":
                        case "top-right":
                        case "bottom-right":
                            return "right";
                        case "left":
                        case "top-left":
                        case "bottom-left":
                            return "left";
                    }
                    return "center";
                }
                function nm(a, t, r, n, l, p, d, m, _, v, b, S) {
                    let I = p.textMaxSize.evaluate(t, {});
                    I === void 0 && (I = d);
                    const A = a.layers[0].layout, k = A.get("icon-offset").evaluate(t, {}, b), D = td(r.horizontal), N = d / 24, G = a.tilePixelRatio * N, ie = a.tilePixelRatio * I / 24, H = a.tilePixelRatio * m, C = a.tilePixelRatio * A.get("symbol-spacing"), F = A.get("text-padding") * a.tilePixelRatio, X = function (Ge, Ve, Oe, at = 1) {
                        const Ot = Ge.get("icon-padding").evaluate(Ve, {}, Oe), Jt = Ot && Ot.values;
                        return [Jt[0] * at, Jt[1] * at, Jt[2] * at, Jt[3] * at];
                    }(A, t, b, a.tilePixelRatio), ue = A.get("text-max-angle") / 180 * Math.PI, Me = A.get("text-rotation-alignment") !== "viewport" && A.get("symbol-placement") !== "point", me = A.get("icon-rotation-alignment") === "map" && A.get("symbol-placement") !== "point", xe = A.get("symbol-placement"), Ae = C / 2, Ie = A.get("icon-text-fit");
                    let ke;
                    n && Ie !== "none" && (a.allowVerticalPlacement && r.vertical && (ke = Sp(n, r.vertical, Ie, A.get("icon-text-fit-padding"), k, N)), D && (n = Sp(n, D, Ie, A.get("icon-text-fit-padding"), k, N)));
                    const we = b ? S.line.getGranularityForZoomLevel(b.z) : 1, Be = (Ge, Ve) => {
                        Ve.x < 0 || Ve.x >= yt || Ve.y < 0 || Ve.y >= yt || function (Oe, at, Ot, Jt, xi, nr, Vi, pi, Et, ri, di, fi, Ri, sr, ai, Zi, Qt, ni, si, Wt, Mt, Er, no, Rr, lm) {
                            const so = Oe.addToLineVertexArray(at, Ot);
                            let es, oo, lo, co, nd = 0, sd = 0, od = 0, ld = 0, mu = -1, gu = -1;
                            const ba = {};
                            let cd = kr("");
                            if (Oe.allowVerticalPlacement && Jt.vertical) {
                                const Ci = pi.layout.get("text-rotate").evaluate(Mt, {}, Rr) + 90;
                                lo = new Vc(Et, at, ri, di, fi, Jt.vertical, Ri, sr, ai, Ci), Vi && (co = new Vc(Et, at, ri, di, fi, Vi, Qt, ni, ai, Ci));
                            }
                            if (xi) {
                                const Ci = pi.layout.get("icon-rotate").evaluate(Mt, {}), or = pi.layout.get("icon-text-fit") !== "none", ts = Kp(xi, Ci, no, or), Lr = Vi ? Kp(Vi, Ci, no, or) : void 0;
                                oo = new Vc(Et, at, ri, di, fi, xi, Qt, ni, !1, Ci), nd = 4 * ts.length;
                                const is = Oe.iconSizeData;
                                let Yr = null;
                                is.kind === "source" ? (Yr = [Kr * pi.layout.get("icon-size").evaluate(Mt, {})], Yr[0] > tn && wi(`${Oe.layerIds[0]}: Value for "icon-size" is >= ${xl}. Reduce your "icon-size".`)) : is.kind === "composite" && (Yr = [Kr * Er.compositeIconSizes[0].evaluate(Mt, {}, Rr), Kr * Er.compositeIconSizes[1].evaluate(Mt, {}, Rr)], (Yr[0] > tn || Yr[1] > tn) && wi(`${Oe.layerIds[0]}: Value for "icon-size" is >= ${xl}. Reduce your "icon-size".`)), Oe.addSymbols(Oe.icon, ts, Yr, Wt, si, Mt, M.al.none, at, so.lineStartIndex, so.lineLength, -1, Rr), mu = Oe.icon.placedSymbolArray.length - 1, Lr && (sd = 4 * Lr.length, Oe.addSymbols(Oe.icon, Lr, Yr, Wt, si, Mt, M.al.vertical, at, so.lineStartIndex, so.lineLength, -1, Rr), gu = Oe.icon.placedSymbolArray.length - 1);
                            }
                            const hd = Object.keys(Jt.horizontal);
                            for (const Ci of hd) {
                                const or = Jt.horizontal[Ci];
                                if (!es) {
                                    cd = kr(or.text);
                                    const Lr = pi.layout.get("text-rotate").evaluate(Mt, {}, Rr);
                                    es = new Vc(Et, at, ri, di, fi, or, Ri, sr, ai, Lr);
                                }
                                const ts = or.positionedLines.length === 1;
                                if (od += ed(Oe, at, or, nr, pi, ai, Mt, Zi, so, Jt.vertical ? M.al.horizontal : M.al.horizontalOnly, ts ? hd : [Ci], ba, mu, Er, Rr), ts) break;
                            }
                            Jt.vertical && (ld += ed(Oe, at, Jt.vertical, nr, pi, ai, Mt, Zi, so, M.al.vertical, ["vertical"], ba, gu, Er, Rr));
                            const cm = es ? es.boxStartIndex : Oe.collisionBoxArray.length, hm = es ? es.boxEndIndex : Oe.collisionBoxArray.length, um = lo ? lo.boxStartIndex : Oe.collisionBoxArray.length, pm = lo ? lo.boxEndIndex : Oe.collisionBoxArray.length, dm = oo ? oo.boxStartIndex : Oe.collisionBoxArray.length, fm = oo ? oo.boxEndIndex : Oe.collisionBoxArray.length, mm = co ? co.boxStartIndex : Oe.collisionBoxArray.length, gm = co ? co.boxEndIndex : Oe.collisionBoxArray.length;
                            let Dr = -1;
                            const Gc = (Ci, or) => Ci && Ci.circleDiameter ? Math.max(Ci.circleDiameter, or) : or;
                            Dr = Gc(es, Dr), Dr = Gc(lo, Dr), Dr = Gc(oo, Dr), Dr = Gc(co, Dr);
                            const ud = Dr > -1 ? 1 : 0;
                            ud && (Dr *= lm / Yt), Oe.glyphOffsetArray.length >= io.MAX_GLYPHS && wi("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Mt.sortKey !== void 0 && Oe.addToSortKeyRanges(Oe.symbolInstances.length, Mt.sortKey);
                            const _m = Qp(pi, Mt, Rr), [ym, vm] = function (Ci, or) {
                                const ts = Ci.length, Lr = or == null ? void 0 : or.values;
                                if ((Lr == null ? void 0 : Lr.length) > 0) for (let is = 0; is < Lr.length; is += 2) {
                                    const Yr = Lr[is + 1];
                                    Ci.emplaceBack(M.aB[Lr[is]], Yr[0], Yr[1]);
                                }
                                return [ts, Ci.length];
                            }(Oe.textAnchorOffsets, _m);
                            Oe.symbolInstances.emplaceBack(at.x, at.y, ba.right >= 0 ? ba.right : -1, ba.center >= 0 ? ba.center : -1, ba.left >= 0 ? ba.left : -1, ba.vertical || -1, mu, gu, cd, cm, hm, um, pm, dm, fm, mm, gm, ri, od, ld, nd, sd, ud, 0, Ri, Dr, ym, vm);
                        }(a, Ve, Ge, r, n, l, ke, a.layers[0], a.collisionBoxArray, t.index, t.sourceLayerIndex, a.index, G, [F, F, F, F], Me, _, H, X, me, k, t, p, v, b, d);
                    };
                    if (xe === "line") for (const Ge of Zp(t.geometry, 0, 0, yt, yt)) {
                        const Ve = Qn(Ge, we), Oe = tm(Ve, C, ue, r.vertical || D, n, 24, ie, a.overscaling, yt);
                        for (const at of Oe) D && sm(a, D.text, Ae, at) || Be(Ve, at);
                    }
                    else if (xe === "line-center") {
                        for (const Ge of t.geometry) if (Ge.length > 1) {
                            const Ve = Qn(Ge, we), Oe = em(Ve, ue, r.vertical || D, n, 24, ie);
                            Oe && Be(Ve, Oe);
                        }
                    } else if (t.type === "Polygon") for (const Ge of ws(t.geometry, 0)) {
                        const Ve = rm(Ge, 16);
                        Be(Qn(Ge[0], we, !0), new an(Ve.x, Ve.y, 0));
                    }
                    else if (t.type === "LineString") for (const Ge of t.geometry) {
                        const Ve = Qn(Ge, we);
                        Be(Ve, new an(Ve[0].x, Ve[0].y, 0));
                    }
                    else if (t.type === "Point") for (const Ge of t.geometry) for (const Ve of Ge) Be([Ve], new an(Ve.x, Ve.y, 0));
                }
                function ed(a, t, r, n, l, p, d, m, _, v, b, S, I, A, k) {
                    const D = function (ie, H, C, F, X, ue, Me, me) {
                        const xe = F.layout.get("text-rotate").evaluate(ue, {}) * Math.PI / 180, Ae = [];
                        for (const Ie of H.positionedLines) for (const ke of Ie.positionedGlyphs) {
                            if (!ke.rect) continue;
                            const we = ke.rect || {};
                            let Be = Rf + 1, Ge = !0, Ve = 1, Oe = 0;
                            const at = (X || me) && ke.vertical, Ot = ke.metrics.advance * ke.scale / 2;
                            if (me && H.verticalizable && (Oe = Ie.lineOffset / 2 - (ke.imageName ? -(Yt - ke.metrics.width * ke.scale) / 2 : (ke.scale - 1) * Yt)), ke.imageName) {
                                const ni = Me[ke.imageName];
                                Ge = ni.sdf, Ve = ni.pixelRatio, Be = Ui / Ve;
                            }
                            const Jt = X ? [ke.x + Ot, ke.y] : [0, 0];
                            let xi = X ? [0, 0] : [ke.x + Ot + C[0], ke.y + C[1] - Oe], nr = [0, 0];
                            at && (nr = xi, xi = [0, 0]);
                            const Vi = ke.metrics.isDoubleResolution ? 2 : 1, pi = (ke.metrics.left - Be) * ke.scale - Ot + xi[0], Et = (-ke.metrics.top - Be) * ke.scale + xi[1], ri = pi + we.w / Vi * ke.scale / Ve, di = Et + we.h / Vi * ke.scale / Ve, fi = new $e(pi, Et), Ri = new $e(ri, Et), sr = new $e(pi, di), ai = new $e(ri, di);
                            if (at) {
                                const ni = new $e(-Ot, Ot - Lc), si = -Math.PI / 2, Wt = Yt / 2 - Ot, Mt = new $e(5 - Lc - Wt, -(ke.imageName ? Wt : 0)), Er = new $e(...nr);
                                fi._rotateAround(si, ni)._add(Mt)._add(Er), Ri._rotateAround(si, ni)._add(Mt)._add(Er), sr._rotateAround(si, ni)._add(Mt)._add(Er), ai._rotateAround(si, ni)._add(Mt)._add(Er);
                            }
                            if (xe) {
                                const ni = Math.sin(xe), si = Math.cos(xe), Wt = [si, -ni, ni, si];
                                fi._matMult(Wt), Ri._matMult(Wt), sr._matMult(Wt), ai._matMult(Wt);
                            }
                            const Zi = new $e(0, 0), Qt = new $e(0, 0);
                            Ae.push({ tl: fi, tr: Ri, bl: sr, br: ai, tex: we, writingMode: H.writingMode, glyphOffset: Jt, sectionIndex: ke.sectionIndex, isSDF: Ge, pixelOffsetTL: Zi, pixelOffsetBR: Qt, minFontScaleX: 0, minFontScaleY: 0 });
                        }
                        return Ae;
                    }(0, r, m, l, p, d, n, a.allowVerticalPlacement), N = a.textSizeData;
                    let G = null;
                    N.kind === "source" ? (G = [Kr * l.layout.get("text-size").evaluate(d, {})], G[0] > tn && wi(`${a.layerIds[0]}: Value for "text-size" is >= ${xl}. Reduce your "text-size".`)) : N.kind === "composite" && (G = [Kr * A.compositeTextSizes[0].evaluate(d, {}, k), Kr * A.compositeTextSizes[1].evaluate(d, {}, k)], (G[0] > tn || G[1] > tn) && wi(`${a.layerIds[0]}: Value for "text-size" is >= ${xl}. Reduce your "text-size".`)), a.addSymbols(a.text, D, G, m, p, d, v, t, _.lineStartIndex, _.lineLength, I, k);
                    for (const ie of b) S[ie] = a.text.placedSymbolArray.length - 1;
                    return 4 * D.length;
                }
                function td(a) {
                    for (const t in a) return a[t];
                    return null;
                }
                function sm(a, t, r, n) {
                    const l = a.compareText;
                    if (t in l) {
                        const p = l[t];
                        for (let d = p.length - 1; d >= 0; d--) if (n.dist(p[d]) < r) return !0;
                    } else l[t] = [];
                    return l[t].push(n), !1;
                }
                const id = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
                class lu {
                    static from(t) {
                        if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
                        const [r, n] = new Uint8Array(t, 0, 2);
                        if (r !== 219) throw new Error("Data does not appear to be in a KDBush format.");
                        const l = n >> 4;
                        if (l !== 1) throw new Error(`Got v${l} data when expected v1.`);
                        const p = id[15 & n];
                        if (!p) throw new Error("Unrecognized array type.");
                        const [d] = new Uint16Array(t, 2, 1), [m] = new Uint32Array(t, 4, 1);
                        return new lu(m, d, p, t);
                    }
                    constructor(t, r = 64, n = Float64Array, l) {
                        if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
                        this.numItems = +t, this.nodeSize = Math.min(Math.max(+r, 2), 65535), this.ArrayType = n, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
                        const p = id.indexOf(this.ArrayType), d = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, m = t * this.IndexArrayType.BYTES_PER_ELEMENT, _ = (8 - m % 8) % 8;
                        if (p < 0) throw new Error(`Unexpected typed array class: ${n}.`);
                        l && l instanceof ArrayBuffer ? (this.data = l, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + m + _, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + d + m + _), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + m + _, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + p]), new Uint16Array(this.data, 2, 1)[0] = r, new Uint32Array(this.data, 4, 1)[0] = t);
                    }
                    add(t, r) {
                        const n = this._pos >> 1;
                        return this.ids[n] = n, this.coords[this._pos++] = t, this.coords[this._pos++] = r, n;
                    }
                    finish() {
                        const t = this._pos >> 1;
                        if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
                        return cu(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
                    }
                    range(t, r, n, l) {
                        if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                        const { ids: p, coords: d, nodeSize: m } = this, _ = [0, p.length - 1, 0], v = [];
                        for (; _.length;) {
                            const b = _.pop() || 0, S = _.pop() || 0, I = _.pop() || 0;
                            if (S - I <= m) {
                                for (let N = I; N <= S; N++) {
                                    const G = d[2 * N], ie = d[2 * N + 1];
                                    G >= t && G <= n && ie >= r && ie <= l && v.push(p[N]);
                                }
                                continue;
                            }
                            const A = I + S >> 1, k = d[2 * A], D = d[2 * A + 1];
                            k >= t && k <= n && D >= r && D <= l && v.push(p[A]), (b === 0 ? t <= k : r <= D) && (_.push(I), _.push(A - 1), _.push(1 - b)), (b === 0 ? n >= k : l >= D) && (_.push(A + 1), _.push(S), _.push(1 - b));
                        }
                        return v;
                    }
                    within(t, r, n) {
                        if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                        const { ids: l, coords: p, nodeSize: d } = this, m = [0, l.length - 1, 0], _ = [], v = n * n;
                        for (; m.length;) {
                            const b = m.pop() || 0, S = m.pop() || 0, I = m.pop() || 0;
                            if (S - I <= d) {
                                for (let N = I; N <= S; N++) ad(p[2 * N], p[2 * N + 1], t, r) <= v && _.push(l[N]);
                                continue;
                            }
                            const A = I + S >> 1, k = p[2 * A], D = p[2 * A + 1];
                            ad(k, D, t, r) <= v && _.push(l[A]), (b === 0 ? t - n <= k : r - n <= D) && (m.push(I), m.push(A - 1), m.push(1 - b)), (b === 0 ? t + n >= k : r + n >= D) && (m.push(A + 1), m.push(S), m.push(1 - b));
                        }
                        return _;
                    }
                }
                function cu(a, t, r, n, l, p) {
                    if (l - n <= r) return;
                    const d = n + l >> 1;
                    rd(a, t, d, n, l, p), cu(a, t, r, n, d - 1, 1 - p), cu(a, t, r, d + 1, l, 1 - p);
                }
                function rd(a, t, r, n, l, p) {
                    for (; l > n;) {
                        if (l - n > 600) {
                            const v = l - n + 1, b = r - n + 1, S = Math.log(v), I = 0.5 * Math.exp(2 * S / 3), A = 0.5 * Math.sqrt(S * I * (v - I) / v) * (b - v / 2 < 0 ? -1 : 1);
                            rd(a, t, r, Math.max(n, Math.floor(r - b * I / v + A)), Math.min(l, Math.floor(r + (v - b) * I / v + A)), p);
                        }
                        const d = t[2 * r + p];
                        let m = n, _ = l;
                        for (Sl(a, t, n, r), t[2 * l + p] > d && Sl(a, t, n, l); m < _;) {
                            for (Sl(a, t, m, _), m++, _--; t[2 * m + p] < d;) m++;
                            for (; t[2 * _ + p] > d;) _--;
                        }
                        t[2 * n + p] === d ? Sl(a, t, n, _) : (_++, Sl(a, t, _, l)), _ <= r && (n = _ + 1), r <= _ && (l = _ - 1);
                    }
                }
                function Sl(a, t, r, n) {
                    hu(a, r, n), hu(t, 2 * r, 2 * n), hu(t, 2 * r + 1, 2 * n + 1);
                }
                function hu(a, t, r) {
                    const n = a[t];
                    a[t] = a[r], a[r] = n;
                }
                function ad(a, t, r, n) {
                    const l = a - r, p = t - n;
                    return l * l + p * p;
                }
                var uu;
                M.co = void 0, (uu = M.co || (M.co = {})).create = "create", uu.load = "load", uu.fullLoad = "fullLoad";
                let Zc = null, Tl = [];
                const pu = 1e3 / 60, du = "loadTime", fu = "fullLoadTime", om = {
                    mark(a) {
                        performance.mark(a);
                    }, frame(a) {
                        const t = a;
                        Zc != null && Tl.push(t - Zc), Zc = t;
                    }, clearMetrics() {
                        Zc = null, Tl = [], performance.clearMeasures(du), performance.clearMeasures(fu);
                        for (const a in M.co) performance.clearMarks(M.co[a]);
                    }, getPerformanceMetrics() {
                        performance.measure(du, M.co.create, M.co.load), performance.measure(fu, M.co.create, M.co.fullLoad);
                        const a = performance.getEntriesByName(du)[0].duration, t = performance.getEntriesByName(fu)[0].duration, r = Tl.length, n = 1 / (Tl.reduce((p, d) => p + d, 0) / r / 1e3), l = Tl.filter((p) => p > pu).reduce((p, d) => p + (d - pu) / pu, 0);
                        return { loadTime: a, fullLoadTime: t, fps: n, percentDroppedFrames: l / (r + l) * 100, totalFrames: r };
                    }
                };
                M.$ = bl, M.A = Rt, M.B = gr, M.C = Tt, M.D = je, M.E = re, M.F = xh, M.G = function (a) {
                    if (Or == null) {
                        const t = a.navigator ? a.navigator.userAgent : null;
                        Or = !!a.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")));
                    }
                    return Or;
                }, M.H = class {
                    constructor(a, t) {
                        this.target = a, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Yf(() => this.process()), this.subscription = ta(this.target, "message", (r) => this.receive(r), !1), this.globalScope = dr(self) ? a : window;
                    }
                    registerMessageHandler(a, t) {
                        this.messageHandlers[a] = t;
                    }
                    sendAsync(a, t) {
                        return new Promise((r, n) => {
                            const l = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), p = t ? ta(t.signal, "abort", () => {
                                p == null || p.unsubscribe(), delete this.resolveRejects[l];
                                const _ = { id: l, type: "<cancel>", origin: location.origin, targetMapId: a.targetMapId, sourceMapId: this.mapId };
                                this.target.postMessage(_);
                            }, Jf) : null;
                            this.resolveRejects[l] = {
                                resolve: (_) => {
                                    p == null || p.unsubscribe(), r(_);
                                }, reject: (_) => {
                                    p == null || p.unsubscribe(), n(_);
                                }
                            };
                            const d = [], m = Object.assign(Object.assign({}, a), { id: l, sourceMapId: this.mapId, origin: location.origin, data: Ya(a.data, d) });
                            this.target.postMessage(m, { transfer: d });
                        });
                    }
                    receive(a) {
                        const t = a.data, r = t.id;
                        if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
                            if (t.type === "<cancel>") {
                                delete this.tasks[r];
                                const n = this.abortControllers[r];
                                return delete this.abortControllers[r], void (n && n.abort());
                            }
                            if (dr(self) || t.mustQueue) return this.tasks[r] = t, this.taskQueue.push(r), void this.invoker.trigger();
                            this.processTask(r, t);
                        }
                    }
                    process() {
                        if (this.taskQueue.length === 0) return;
                        const a = this.taskQueue.shift(), t = this.tasks[a];
                        delete this.tasks[a], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(a, t);
                    }
                    processTask(a, t) {
                        return c(this, void 0, void 0, function* () {
                            if (t.type === "<response>") {
                                const l = this.resolveRejects[a];
                                return delete this.resolveRejects[a], l ? void (t.error ? l.reject($n(t.error)) : l.resolve($n(t.data))) : void 0;
                            }
                            if (!this.messageHandlers[t.type]) return void this.completeTask(a, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
                            const r = $n(t.data), n = new AbortController();
                            this.abortControllers[a] = n;
                            try {
                                const l = yield this.messageHandlers[t.type](t.sourceMapId, r, n);
                                this.completeTask(a, null, l);
                            } catch (l) {
                                this.completeTask(a, l);
                            }
                        });
                    }
                    completeTask(a, t, r) {
                        const n = [];
                        delete this.abortControllers[a];
                        const l = { id: a, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? Ya(t) : null, data: Ya(r, n) };
                        this.target.postMessage(l, { transfer: n });
                    }
                    remove() {
                        this.invoker.remove(), this.subscription.unsubscribe();
                    }
                }, M.I = Xh, M.J = Aa, M.K = function () {
                    var a = new Rt(16);
                    return Rt != Float32Array && (a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0), a[0] = 1, a[5] = 1, a[10] = 1, a[15] = 1, a;
                }, M.L = function (a, t, r) {
                    var n, l, p, d, m, _, v, b, S, I, A, k, D = r[0], N = r[1], G = r[2];
                    return t === a ? (a[12] = t[0] * D + t[4] * N + t[8] * G + t[12], a[13] = t[1] * D + t[5] * N + t[9] * G + t[13], a[14] = t[2] * D + t[6] * N + t[10] * G + t[14], a[15] = t[3] * D + t[7] * N + t[11] * G + t[15]) : (l = t[1], p = t[2], d = t[3], m = t[4], _ = t[5], v = t[6], b = t[7], S = t[8], I = t[9], A = t[10], k = t[11], a[0] = n = t[0], a[1] = l, a[2] = p, a[3] = d, a[4] = m, a[5] = _, a[6] = v, a[7] = b, a[8] = S, a[9] = I, a[10] = A, a[11] = k, a[12] = n * D + m * N + S * G + t[12], a[13] = l * D + _ * N + I * G + t[13], a[14] = p * D + v * N + A * G + t[14], a[15] = d * D + b * N + k * G + t[15]), a;
                }, M.M = function (a, t, r) {
                    var n = r[0], l = r[1], p = r[2];
                    return a[0] = t[0] * n, a[1] = t[1] * n, a[2] = t[2] * n, a[3] = t[3] * n, a[4] = t[4] * l, a[5] = t[5] * l, a[6] = t[6] * l, a[7] = t[7] * l, a[8] = t[8] * p, a[9] = t[9] * p, a[10] = t[10] * p, a[11] = t[11] * p, a[12] = t[12], a[13] = t[13], a[14] = t[14], a[15] = t[15], a;
                }, M.N = function (a, t, r) {
                    var n = t[0], l = t[1], p = t[2], d = t[3], m = t[4], _ = t[5], v = t[6], b = t[7], S = t[8], I = t[9], A = t[10], k = t[11], D = t[12], N = t[13], G = t[14], ie = t[15], H = r[0], C = r[1], F = r[2], X = r[3];
                    return a[0] = H * n + C * m + F * S + X * D, a[1] = H * l + C * _ + F * I + X * N, a[2] = H * p + C * v + F * A + X * G, a[3] = H * d + C * b + F * k + X * ie, a[4] = (H = r[4]) * n + (C = r[5]) * m + (F = r[6]) * S + (X = r[7]) * D, a[5] = H * l + C * _ + F * I + X * N, a[6] = H * p + C * v + F * A + X * G, a[7] = H * d + C * b + F * k + X * ie, a[8] = (H = r[8]) * n + (C = r[9]) * m + (F = r[10]) * S + (X = r[11]) * D, a[9] = H * l + C * _ + F * I + X * N, a[10] = H * p + C * v + F * A + X * G, a[11] = H * d + C * b + F * k + X * ie, a[12] = (H = r[12]) * n + (C = r[13]) * m + (F = r[14]) * S + (X = r[15]) * D, a[13] = H * l + C * _ + F * I + X * N, a[14] = H * p + C * v + F * A + X * G, a[15] = H * d + C * b + F * k + X * ie, a;
                }, M.O = function (a, t) {
                    const r = {};
                    for (let n = 0; n < t.length; n++) {
                        const l = t[n];
                        l in a && (r[l] = a[l]);
                    }
                    return r;
                }, M.P = $e, M.Q = rn, M.R = rr, M.S = Rp, M.T = wc, M.U = Ep, M.V = ln, M.W = bi, M.X = dn, M.Y = ar, M.Z = yt, M._ = c, M.a = Pr, M.a$ = function (a, t, r) {
                    var n = Math.sin(r), l = Math.cos(r), p = t[4], d = t[5], m = t[6], _ = t[7], v = t[8], b = t[9], S = t[10], I = t[11];
                    return t !== a && (a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[12] = t[12], a[13] = t[13], a[14] = t[14], a[15] = t[15]), a[4] = p * l + v * n, a[5] = d * l + b * n, a[6] = m * l + S * n, a[7] = _ * l + I * n, a[8] = v * l - p * n, a[9] = b * l - d * n, a[10] = S * l - m * n, a[11] = I * l - _ * n, a;
                }, M.a0 = 25, M.a1 = nu, M.a2 = (a) => {
                    const t = window.document.createElement("video");
                    return t.muted = !0, new Promise((r) => {
                        t.onloadstart = () => {
                            r(t);
                        };
                        for (const n of a) {
                            const l = window.document.createElement("source");
                            oe(n) || (t.crossOrigin = "Anonymous"), l.src = n, t.appendChild(l);
                        }
                    });
                }, M.a3 = ve, M.a4 = function () {
                    return Pa++;
                }, M.a5 = Z, M.a6 = io, M.a7 = Fn, M.a8 = Kn, M.a9 = jp, M.aA = function (a, t, r, n, l = !1) {
                    if (!r[0] && !r[1]) return [0, 0];
                    const p = l ? n === "map" ? -a.bearingInRadians : 0 : n === "viewport" ? a.bearingInRadians : 0;
                    if (p) {
                        const d = Math.sin(p), m = Math.cos(p);
                        r = [r[0] * m - r[1] * d, r[0] * d + r[1] * m];
                    }
                    return [l ? r[0] : Fr(t, r[0], a.zoom), l ? r[1] : Fr(t, r[1], a.zoom)];
                }, M.aC = Jh, M.aD = ou, M.aE = Yh, M.aF = lu, M.aG = Ct, M.aH = Ec, M.aI = ye, M.aJ = mt, M.aK = ft, M.aL = Nr, M.aM = Sr, M.aN = Lp, M.aO = function (a, t, r) {
                    return a[0] = t[0] * r, a[1] = t[1] * r, a[2] = t[2] * r, a;
                }, M.aP = function (a, t, r) {
                    return a[0] = t[0] + r[0], a[1] = t[1] + r[1], a[2] = t[2] + r[2], a;
                }, M.aQ = function (a) {
                    var t = new Rt(3);
                    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t;
                }, M.aR = function (a, t, r) {
                    return a[0] = t[0] * r[0], a[1] = t[1] * r[1], a[2] = t[2] * r[2], a[3] = t[3] * r[3], a;
                }, M.aS = function (a, t, r) {
                    return a[0] = t[0] - r[0], a[1] = t[1] - r[1], a[2] = t[2] - r[2], a;
                }, M.aT = function (a, t) {
                    var r = t[0], n = t[1], l = t[2], p = r * r + n * n + l * l;
                    return p > 0 && (p = 1 / Math.sqrt(p)), a[0] = t[0] * p, a[1] = t[1] * p, a[2] = t[2] * p, a;
                }, M.aU = function (a, t, r) {
                    var n = t[0], l = t[1], p = t[2], d = r[0], m = r[1], _ = r[2];
                    return a[0] = l * _ - p * m, a[1] = p * d - n * _, a[2] = n * m - l * d, a;
                }, M.aV = function (a, t) {
                    return a[0] * t[0] + a[1] * t[1] + a[2] * t[2];
                }, M.aW = Fp, M.aX = ro, M.aY = function (a, t, r, n, l) {
                    var p, d = 1 / Math.tan(t / 2);
                    return a[0] = d / r, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = d, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[11] = -1, a[12] = 0, a[13] = 0, a[15] = 0, l != null && l !== 1 / 0 ? (a[10] = (l + n) * (p = 1 / (n - l)), a[14] = 2 * l * n * p) : (a[10] = -1, a[14] = -2 * n), a;
                }, M.aZ = function (a) {
                    var t = new Rt(16);
                    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t[9] = a[9], t[10] = a[10], t[11] = a[11], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15], t;
                }, M.a_ = function (a, t, r) {
                    var n = Math.sin(r), l = Math.cos(r), p = t[0], d = t[1], m = t[2], _ = t[3], v = t[4], b = t[5], S = t[6], I = t[7];
                    return t !== a && (a[8] = t[8], a[9] = t[9], a[10] = t[10], a[11] = t[11], a[12] = t[12], a[13] = t[13], a[14] = t[14], a[15] = t[15]), a[0] = p * l + v * n, a[1] = d * l + b * n, a[2] = m * l + S * n, a[3] = _ * l + I * n, a[4] = v * l - p * n, a[5] = b * l - d * n, a[6] = S * l - m * n, a[7] = I * l - _ * n, a;
                }, M.aa = function (a) {
                    const t = {};
                    if (a.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (r, n, l, p) => {
                        const d = l || p;
                        return t[n] = !d || d.toLowerCase(), "";
                    }), t["max-age"]) {
                        const r = parseInt(t["max-age"], 10);
                        isNaN(r) ? delete t["max-age"] : t["max-age"] = r;
                    }
                    return t;
                }, M.ab = ia, M.ac = function (a) {
                    return Math.pow(2, a);
                }, M.ad = Dt, M.ae = li, M.af = 85.051129, M.ag = Dp, M.ah = function (a) {
                    return Math.log(a) / Math.LN2;
                }, M.ai = function (a) {
                    var t = a[0], r = a[1];
                    return t * t + r * r;
                }, M.aj = function (a, t) {
                    const r = [];
                    for (const n in a) n in t || r.push(n);
                    return r;
                }, M.ak = function (a, t) {
                    let r = 0, n = 0;
                    if (a.kind === "constant") n = a.layoutSize;
                    else if (a.kind !== "source") {
                        const { interpolationType: l, minZoom: p, maxZoom: d } = a, m = l ? li(_i.interpolationFactor(l, t, p, d), 0, 1) : 0;
                        a.kind === "camera" ? n = gr.number(a.minSize, a.maxSize, m) : r = m;
                    }
                    return { uSizeT: r, uSize: n };
                }, M.am = function (a, { uSize: t, uSizeT: r }, { lowerSize: n, upperSize: l }) {
                    return a.kind === "source" ? n / Kr : a.kind === "composite" ? gr.number(n / Kr, l / Kr, r) : t;
                }, M.an = function (a, t) {
                    var r = t[0], n = t[1], l = t[2], p = t[3], d = t[4], m = t[5], _ = t[6], v = t[7], b = t[8], S = t[9], I = t[10], A = t[11], k = t[12], D = t[13], N = t[14], G = t[15], ie = r * m - n * d, H = r * _ - l * d, C = r * v - p * d, F = n * _ - l * m, X = n * v - p * m, ue = l * v - p * _, Me = b * D - S * k, me = b * N - I * k, xe = b * G - A * k, Ae = S * N - I * D, Ie = S * G - A * D, ke = I * G - A * N, we = ie * ke - H * Ie + C * Ae + F * xe - X * me + ue * Me;
                    return we ? (a[0] = (m * ke - _ * Ie + v * Ae) * (we = 1 / we), a[1] = (l * Ie - n * ke - p * Ae) * we, a[2] = (D * ue - N * X + G * F) * we, a[3] = (I * X - S * ue - A * F) * we, a[4] = (_ * xe - d * ke - v * me) * we, a[5] = (r * ke - l * xe + p * me) * we, a[6] = (N * C - k * ue - G * H) * we, a[7] = (b * ue - I * C + A * H) * we, a[8] = (d * Ie - m * xe + v * Me) * we, a[9] = (n * xe - r * Ie - p * Me) * we, a[10] = (k * X - D * C + G * ie) * we, a[11] = (S * C - b * X - A * ie) * we, a[12] = (m * me - d * Ae - _ * Me) * we, a[13] = (r * Ae - n * me + l * Me) * we, a[14] = (D * H - k * F - N * ie) * we, a[15] = (b * F - S * H + I * ie) * we, a) : null;
                }, M.ao = Sa, M.ap = function (a) {
                    return Math.hypot(a[0], a[1]);
                }, M.aq = function (a) {
                    return a[0] = 0, a[1] = 0, a;
                }, M.ar = function (a, t, r) {
                    return a[0] = t[0] * r, a[1] = t[1] * r, a;
                }, M.as = Qh, M.at = mi, M.au = function (a, t, r, n) {
                    const l = t.y - a.y, p = t.x - a.x, d = n.y - r.y, m = n.x - r.x, _ = d * p - m * l;
                    if (_ === 0) return null;
                    const v = (m * (a.y - r.y) - d * (a.x - r.x)) / _;
                    return new $e(a.x + v * p, a.y + v * l);
                }, M.av = Zp, M.aw = Au, M.ax = function (a) {
                    let t = 1 / 0, r = 1 / 0, n = -1 / 0, l = -1 / 0;
                    for (const p of a) t = Math.min(t, p.x), r = Math.min(r, p.y), n = Math.max(n, p.x), l = Math.max(l, p.y);
                    return [t, r, n, l];
                }, M.ay = Yt, M.az = Fr, M.b = Gi, M.b$ = class extends R {
                }, M.b0 = function () {
                    const a = new Float32Array(16);
                    return Dt(a), a;
                }, M.b1 = function () {
                    const a = new Float64Array(16);
                    return Dt(a), a;
                }, M.b2 = function () {
                    return new Float64Array(16);
                }, M.b3 = function (a, t, r) {
                    const n = new Float64Array(4);
                    return function (l, p, d, m) {
                        var _ = 0.5 * Math.PI / 180;
                        p *= _, d *= _, m *= _;
                        var v = Math.sin(p), b = Math.cos(p), S = Math.sin(d), I = Math.cos(d), A = Math.sin(m), k = Math.cos(m);
                        l[0] = v * I * k - b * S * A, l[1] = b * S * k + v * I * A, l[2] = b * I * A - v * S * k, l[3] = b * I * k + v * S * A;
                    }(n, a, t - 90, r), n;
                }, M.b4 = function (a, t, r, n) {
                    var l, p, d, m, _, v = t[0], b = t[1], S = t[2], I = t[3], A = r[0], k = r[1], D = r[2], N = r[3];
                    return (p = v * A + b * k + S * D + I * N) < 0 && (p = -p, A = -A, k = -k, D = -D, N = -N), 1 - p > Zt ? (l = Math.acos(p), d = Math.sin(l), m = Math.sin((1 - n) * l) / d, _ = Math.sin(n * l) / d) : (m = 1 - n, _ = n), a[0] = m * v + _ * A, a[1] = m * b + _ * k, a[2] = m * S + _ * D, a[3] = m * I + _ * N, a;
                }, M.b5 = function (a) {
                    const t = new Float64Array(9);
                    var r, n, l, p, d, m, _, v, b, S, I, A, k, D, N, G, ie, H;
                    S = (l = (n = a)[0]) * (_ = l + l), I = (p = n[1]) * _, k = (d = n[2]) * _, D = d * (v = p + p), G = (m = n[3]) * _, ie = m * v, H = m * (b = d + d), (r = t)[0] = 1 - (A = p * v) - (N = d * b), r[3] = I - H, r[6] = k + ie, r[1] = I + H, r[4] = 1 - S - N, r[7] = D - G, r[2] = k - ie, r[5] = D + G, r[8] = 1 - S - A;
                    const C = Sr(-Math.asin(li(t[2], -1, 1)));
                    let F, X;
                    return Math.hypot(t[5], t[8]) < 1e-3 ? (F = 0, X = -Sr(Math.atan2(t[3], t[4]))) : (F = Sr(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), X = Sr(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), { roll: F, pitch: C + 90, bearing: X };
                }, M.b6 = function (a, t) {
                    return a.roll == t.roll && a.pitch == t.pitch && a.bearing == t.bearing;
                }, M.b7 = st, M.b8 = Ks, M.b9 = eo, M.bA = function (a) {
                    if (a.type === "custom") return new Kf(a);
                    switch (a.type) {
                        case "background":
                            return new Hf(a);
                        case "circle":
                            return new $d(a);
                        case "fill":
                            return new of(a);
                        case "fill-extrusion":
                            return new mf(a);
                        case "heatmap":
                            return new Vd(a);
                        case "hillshade":
                            return new Gd(a);
                        case "line":
                            return new Sf(a);
                        case "raster":
                            return new Xf(a);
                        case "symbol":
                            return new Oc(a);
                    }
                }, M.bB = Li, M.bC = function (a, t) {
                    if (!a) return [{ command: "setStyle", args: [t] }];
                    let r = [];
                    try {
                        if (!ce(a.version, t.version)) return [{ command: "setStyle", args: [t] }];
                        ce(a.center, t.center) || r.push({ command: "setCenter", args: [t.center] }), ce(a.state, t.state) || r.push({ command: "setGlobalState", args: [t.state] }), ce(a.centerAltitude, t.centerAltitude) || r.push({ command: "setCenterAltitude", args: [t.centerAltitude] }), ce(a.zoom, t.zoom) || r.push({ command: "setZoom", args: [t.zoom] }), ce(a.bearing, t.bearing) || r.push({ command: "setBearing", args: [t.bearing] }), ce(a.pitch, t.pitch) || r.push({ command: "setPitch", args: [t.pitch] }), ce(a.roll, t.roll) || r.push({ command: "setRoll", args: [t.roll] }), ce(a.sprite, t.sprite) || r.push({ command: "setSprite", args: [t.sprite] }), ce(a.glyphs, t.glyphs) || r.push({ command: "setGlyphs", args: [t.glyphs] }), ce(a.transition, t.transition) || r.push({ command: "setTransition", args: [t.transition] }), ce(a.light, t.light) || r.push({ command: "setLight", args: [t.light] }), ce(a.terrain, t.terrain) || r.push({ command: "setTerrain", args: [t.terrain] }), ce(a.sky, t.sky) || r.push({ command: "setSky", args: [t.sky] }), ce(a.projection, t.projection) || r.push({ command: "setProjection", args: [t.projection] });
                        const n = {}, l = [];
                        (function (d, m, _, v) {
                            let b;
                            for (b in m = m || {}, d = d || {}) Object.prototype.hasOwnProperty.call(d, b) && (Object.prototype.hasOwnProperty.call(m, b) || Pe(b, _, v));
                            for (b in m) Object.prototype.hasOwnProperty.call(m, b) && (Object.prototype.hasOwnProperty.call(d, b) ? ce(d[b], m[b]) || (d[b].type === "geojson" && m[b].type === "geojson" && De(d, m, b) ? fe(_, { command: "setGeoJSONSourceData", args: [b, m[b].data] }) : Re(b, m, _, v)) : le(b, m, _));
                        })(a.sources, t.sources, l, n);
                        const p = [];
                        a.layers && a.layers.forEach((d) => {
                            "source" in d && n[d.source] ? r.push({ command: "removeLayer", args: [d.id] }) : p.push(d);
                        }), r = r.concat(l), function (d, m, _) {
                            m = m || [];
                            const v = (d = d || []).map(Ye), b = m.map(Ye), S = d.reduce(Xe, {}), I = m.reduce(Xe, {}), A = v.slice(), k = /* @__PURE__ */ Object.create(null);
                            let D, N, G, ie, H;
                            for (let C = 0, F = 0; C < v.length; C++) D = v[C], Object.prototype.hasOwnProperty.call(I, D) ? F++ : (fe(_, { command: "removeLayer", args: [D] }), A.splice(A.indexOf(D, F), 1));
                            for (let C = 0, F = 0; C < b.length; C++) D = b[b.length - 1 - C], A[A.length - 1 - C] !== D && (Object.prototype.hasOwnProperty.call(S, D) ? (fe(_, { command: "removeLayer", args: [D] }), A.splice(A.lastIndexOf(D, A.length - F), 1)) : F++, ie = A[A.length - C], fe(_, { command: "addLayer", args: [I[D], ie] }), A.splice(A.length - C, 0, D), k[D] = !0);
                            for (let C = 0; C < b.length; C++) if (D = b[C], N = S[D], G = I[D], !k[D] && !ce(N, G)) if (ce(N.source, G.source) && ce(N["source-layer"], G["source-layer"]) && ce(N.type, G.type)) {
                                for (H in Ze(N.layout, G.layout, _, D, null, "setLayoutProperty"), Ze(N.paint, G.paint, _, D, null, "setPaintProperty"), ce(N.filter, G.filter) || fe(_, { command: "setFilter", args: [D, G.filter] }), ce(N.minzoom, G.minzoom) && ce(N.maxzoom, G.maxzoom) || fe(_, { command: "setLayerZoomRange", args: [D, G.minzoom, G.maxzoom] }), N) Object.prototype.hasOwnProperty.call(N, H) && H !== "layout" && H !== "paint" && H !== "filter" && H !== "metadata" && H !== "minzoom" && H !== "maxzoom" && (H.indexOf("paint.") === 0 ? Ze(N[H], G[H], _, D, H.slice(6), "setPaintProperty") : ce(N[H], G[H]) || fe(_, { command: "setLayerProperty", args: [D, H, G[H]] }));
                                for (H in G) Object.prototype.hasOwnProperty.call(G, H) && !Object.prototype.hasOwnProperty.call(N, H) && H !== "layout" && H !== "paint" && H !== "filter" && H !== "metadata" && H !== "minzoom" && H !== "maxzoom" && (H.indexOf("paint.") === 0 ? Ze(N[H], G[H], _, D, H.slice(6), "setPaintProperty") : ce(N[H], G[H]) || fe(_, { command: "setLayerProperty", args: [D, H, G[H]] }));
                            } else fe(_, { command: "removeLayer", args: [D] }), ie = A[A.lastIndexOf(D) + 1], fe(_, { command: "addLayer", args: [G, ie] });
                        }(p, t.layers, r);
                    } catch (n) {
                        console.warn("Unable to compute style diff:", n), r = [{ command: "setStyle", args: [t] }];
                    }
                    return r;
                }, M.bD = function (a) {
                    const t = [], r = a.id;
                    return r === void 0 && t.push({ message: `layers.${r}: missing required property "id"` }), a.render === void 0 && t.push({ message: `layers.${r}: missing required method "render"` }), a.renderingMode && a.renderingMode !== "2d" && a.renderingMode !== "3d" && t.push({ message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"` }), t;
                }, M.bE = function a(t, r) {
                    if (Array.isArray(t)) {
                        if (!Array.isArray(r) || t.length !== r.length) return !1;
                        for (let n = 0; n < t.length; n++) if (!a(t[n], r[n])) return !1;
                        return !0;
                    }
                    if (typeof t == "object" && t !== null && r !== null) {
                        if (typeof r != "object" || Object.keys(t).length !== Object.keys(r).length) return !1;
                        for (const n in t) if (!a(t[n], r[n])) return !1;
                        return !0;
                    }
                    return t === r;
                }, M.bF = ea, M.bG = un, M.bH = class extends Pt {
                    constructor(a, t) {
                        super(a, t), this.current = 0;
                    }
                    set(a) {
                        this.current !== a && (this.current = a, this.gl.uniform1i(this.location, a));
                    }
                }, M.bI = Ic, M.bJ = class extends Pt {
                    constructor(a, t) {
                        super(a, t), this.current = Mh;
                    }
                    set(a) {
                        if (a[12] !== this.current[12] || a[0] !== this.current[0]) return this.current = a, void this.gl.uniformMatrix4fv(this.location, !1, a);
                        for (let t = 1; t < 16; t++) if (a[t] !== this.current[t]) {
                            this.current = a, this.gl.uniformMatrix4fv(this.location, !1, a);
                            break;
                        }
                    }
                }, M.bK = Mc, M.bL = class extends Pt {
                    constructor(a, t) {
                        super(a, t), this.current = [0, 0, 0];
                    }
                    set(a) {
                        a[0] === this.current[0] && a[1] === this.current[1] && a[2] === this.current[2] || (this.current = a, this.gl.uniform3f(this.location, a[0], a[1], a[2]));
                    }
                }, M.bM = class extends Pt {
                    constructor(a, t) {
                        super(a, t), this.current = [0, 0];
                    }
                    set(a) {
                        a[0] === this.current[0] && a[1] === this.current[1] || (this.current = a, this.gl.uniform2f(this.location, a[0], a[1]));
                    }
                }, M.bN = hr, M.bO = function (a, t) {
                    var r = Math.sin(t), n = Math.cos(t);
                    return a[0] = n, a[1] = r, a[2] = 0, a[3] = -r, a[4] = n, a[5] = 0, a[6] = 0, a[7] = 0, a[8] = 1, a;
                }, M.bP = function (a, t, r) {
                    var n = t[0], l = t[1], p = t[2];
                    return a[0] = n * r[0] + l * r[3] + p * r[6], a[1] = n * r[1] + l * r[4] + p * r[7], a[2] = n * r[2] + l * r[5] + p * r[8], a;
                }, M.bQ = function (a, t, r, n, l, p, d) {
                    var m = 1 / (t - r), _ = 1 / (n - l), v = 1 / (p - d);
                    return a[0] = -2 * m, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = -2 * _, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 2 * v, a[11] = 0, a[12] = (t + r) * m, a[13] = (l + n) * _, a[14] = (d + p) * v, a[15] = 1, a;
                }, M.bR = class extends Pt {
                    constructor(a, t) {
                        super(a, t), this.current = new Array();
                    }
                    set(a) {
                        if (a != this.current) {
                            this.current = a;
                            const t = new Float32Array(4 * a.length);
                            for (let r = 0; r < a.length; r++) t[4 * r] = a[r].r, t[4 * r + 1] = a[r].g, t[4 * r + 2] = a[r].b, t[4 * r + 3] = a[r].a;
                            this.gl.uniform4fv(this.location, t);
                        }
                    }
                }, M.bS = class extends Pt {
                    constructor(a, t) {
                        super(a, t), this.current = new Array();
                    }
                    set(a) {
                        if (a != this.current) {
                            this.current = a;
                            const t = new Float32Array(a);
                            this.gl.uniform1fv(this.location, t);
                        }
                    }
                }, M.bT = class extends u {
                }, M.bU = If, M.bV = class extends g {
                }, M.bW = Rh, M.bX = function (a) {
                    return a <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));
                }, M.bY = Ou, M.bZ = function (a, t, r) {
                    var n = t[0], l = t[1], p = t[2], d = r[3] * n + r[7] * l + r[11] * p + r[15];
                    return a[0] = (r[0] * n + r[4] * l + r[8] * p + r[12]) / (d = d || 1), a[1] = (r[1] * n + r[5] * l + r[9] * p + r[13]) / d, a[2] = (r[2] * n + r[6] * l + r[10] * p + r[14]) / d, a;
                }, M.b_ = class extends ya {
                }, M.ba = dl, M.bb = Qs, M.bc = Ta, M.bd = Qi, M.be = Ei, M.bf = function (a, t, r, n, l) {
                    return Ta(n, l, li((a - t) / (r - t), 0, 1));
                }, M.bg = pr, M.bh = function () {
                    return new Float64Array(3);
                }, M.bi = function (a, t, r, n) {
                    return a[0] = t[0] + r[0] * n, a[1] = t[1] + r[1] * n, a[2] = t[2] + r[2] * n, a;
                }, M.bj = Ji, M.bk = function () {
                    return new Float64Array(4);
                }, M.bl = function (a, t, r, n) {
                    var l = [], p = [];
                    return l[0] = t[0] - r[0], l[1] = t[1] - r[1], l[2] = t[2] - r[2], p[0] = l[0] * Math.cos(n) - l[1] * Math.sin(n), p[1] = l[0] * Math.sin(n) + l[1] * Math.cos(n), p[2] = l[2], a[0] = p[0] + r[0], a[1] = p[1] + r[1], a[2] = p[2] + r[2], a;
                }, M.bm = function (a, t, r, n) {
                    var l = [], p = [];
                    return l[0] = t[0] - r[0], l[1] = t[1] - r[1], l[2] = t[2] - r[2], p[0] = l[0], p[1] = l[1] * Math.cos(n) - l[2] * Math.sin(n), p[2] = l[1] * Math.sin(n) + l[2] * Math.cos(n), a[0] = p[0] + r[0], a[1] = p[1] + r[1], a[2] = p[2] + r[2], a;
                }, M.bn = function (a, t, r, n) {
                    var l = [], p = [];
                    return l[0] = t[0] - r[0], l[1] = t[1] - r[1], l[2] = t[2] - r[2], p[0] = l[2] * Math.sin(n) + l[0] * Math.cos(n), p[1] = l[1], p[2] = l[2] * Math.cos(n) - l[0] * Math.sin(n), a[0] = p[0] + r[0], a[1] = p[1] + r[1], a[2] = p[2] + r[2], a;
                }, M.bo = hs, M.bp = function (a, t, r) {
                    var n = Math.sin(r), l = Math.cos(r), p = t[0], d = t[1], m = t[2], _ = t[3], v = t[8], b = t[9], S = t[10], I = t[11];
                    return t !== a && (a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a[12] = t[12], a[13] = t[13], a[14] = t[14], a[15] = t[15]), a[0] = p * l - v * n, a[1] = d * l - b * n, a[2] = m * l - S * n, a[3] = _ * l - I * n, a[8] = p * n + v * l, a[9] = d * n + b * l, a[10] = m * n + S * l, a[11] = _ * n + I * l, a;
                }, M.bq = function (a, t) {
                    const r = pr(a, 360), n = pr(t, 360), l = n - r, p = n > r ? l - 360 : l + 360;
                    return Math.abs(l) < Math.abs(p) ? l : p;
                }, M.br = function (a) {
                    return a[0] = 0, a[1] = 0, a[2] = 0, a;
                }, M.bs = function (a, t, r, n) {
                    const l = Math.sqrt(a * a + t * t), p = Math.sqrt(r * r + n * n);
                    a /= l, t /= l, r /= p, n /= p;
                    const d = Math.acos(a * r + t * n);
                    return -t * r + a * n > 0 ? d : -d;
                }, M.bt = function (a, t) {
                    return a[0] * t[0] + a[1] * t[1] + a[2] * t[2] + a[3];
                }, M.bu = ru, M.bv = function (a, t) {
                    const r = pr(a, 2 * Math.PI), n = pr(t, 2 * Math.PI);
                    return Math.min(Math.abs(r - n), Math.abs(r - n + 2 * Math.PI), Math.abs(r - n - 2 * Math.PI));
                }, M.bw = function () {
                    const a = {}, t = O.$version;
                    for (const r in O.$root) {
                        const n = O.$root[r];
                        if (n.required) {
                            let l = null;
                            l = r === "version" ? t : n.type === "array" ? [] : {}, l != null && (a[r] = l);
                        }
                    }
                    return a;
                }, M.bx = Xo, M.by = Ai, M.bz = function (a) {
                    a = a.slice();
                    const t = /* @__PURE__ */ Object.create(null);
                    for (let r = 0; r < a.length; r++) t[a[r].id] = a[r];
                    for (let r = 0; r < a.length; r++) "ref" in a[r] && (a[r] = ne(a[r], t[a[r].ref]));
                    return a;
                }, M.c = Tr, M.c0 = function (a, t) {
                    return a[0] === t[0] && a[1] === t[1] && a[2] === t[2] && a[3] === t[3] && a[4] === t[4] && a[5] === t[5] && a[6] === t[6] && a[7] === t[7] && a[8] === t[8] && a[9] === t[9] && a[10] === t[10] && a[11] === t[11] && a[12] === t[12] && a[13] === t[13] && a[14] === t[14] && a[15] === t[15];
                }, M.c1 = function (a, t) {
                    var r = a[0], n = a[1], l = a[2], p = a[3], d = a[4], m = a[5], _ = a[6], v = a[7], b = a[8], S = a[9], I = a[10], A = a[11], k = a[12], D = a[13], N = a[14], G = a[15], ie = t[0], H = t[1], C = t[2], F = t[3], X = t[4], ue = t[5], Me = t[6], me = t[7], xe = t[8], Ae = t[9], Ie = t[10], ke = t[11], we = t[12], Be = t[13], Ge = t[14], Ve = t[15];
                    return Math.abs(r - ie) <= Zt * Math.max(1, Math.abs(r), Math.abs(ie)) && Math.abs(n - H) <= Zt * Math.max(1, Math.abs(n), Math.abs(H)) && Math.abs(l - C) <= Zt * Math.max(1, Math.abs(l), Math.abs(C)) && Math.abs(p - F) <= Zt * Math.max(1, Math.abs(p), Math.abs(F)) && Math.abs(d - X) <= Zt * Math.max(1, Math.abs(d), Math.abs(X)) && Math.abs(m - ue) <= Zt * Math.max(1, Math.abs(m), Math.abs(ue)) && Math.abs(_ - Me) <= Zt * Math.max(1, Math.abs(_), Math.abs(Me)) && Math.abs(v - me) <= Zt * Math.max(1, Math.abs(v), Math.abs(me)) && Math.abs(b - xe) <= Zt * Math.max(1, Math.abs(b), Math.abs(xe)) && Math.abs(S - Ae) <= Zt * Math.max(1, Math.abs(S), Math.abs(Ae)) && Math.abs(I - Ie) <= Zt * Math.max(1, Math.abs(I), Math.abs(Ie)) && Math.abs(A - ke) <= Zt * Math.max(1, Math.abs(A), Math.abs(ke)) && Math.abs(k - we) <= Zt * Math.max(1, Math.abs(k), Math.abs(we)) && Math.abs(D - Be) <= Zt * Math.max(1, Math.abs(D), Math.abs(Be)) && Math.abs(N - Ge) <= Zt * Math.max(1, Math.abs(N), Math.abs(Ge)) && Math.abs(G - Ve) <= Zt * Math.max(1, Math.abs(G), Math.abs(Ve));
                }, M.c2 = function (a, t) {
                    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a[8] = t[8], a[9] = t[9], a[10] = t[10], a[11] = t[11], a[12] = t[12], a[13] = t[13], a[14] = t[14], a[15] = t[15], a;
                }, M.c3 = (a) => a.type === "symbol", M.c4 = (a) => a.type === "circle", M.c5 = (a) => a.type === "heatmap", M.c6 = (a) => a.type === "line", M.c7 = (a) => a.type === "fill", M.c8 = (a) => a.type === "fill-extrusion", M.c9 = (a) => a.type === "hillshade", M.cA = Nh, M.cB = Vh, M.cC = ml, M.cD = Hh, M.cE = class {
                    constructor(a) {
                        this._marks = { start: [a.url, "start"].join("#"), end: [a.url, "end"].join("#"), measure: a.url.toString() }, performance.mark(this._marks.start);
                    }
                    finish() {
                        performance.mark(this._marks.end);
                        let a = performance.getEntriesByName(this._marks.measure);
                        return a.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), a = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), a;
                    }
                }, M.cF = function (a, t, r, n, l) {
                    return c(this, void 0, void 0, function* () {
                        if (bi()) try {
                            return yield dn(a, t, r, n, l);
                        } catch {
                        }
                        return function (p, d, m, _, v) {
                            const b = p.width, S = p.height;
                            Fi && fr || (Fi = new OffscreenCanvas(b, S), fr = Fi.getContext("2d", { willReadFrequently: !0 })), Fi.width = b, Fi.height = S, fr.drawImage(p, 0, 0, b, S);
                            const I = fr.getImageData(d, m, _, v);
                            return fr.clearRect(0, 0, b, S), I.data;
                        }(a, t, r, n, l);
                    });
                }, M.cG = Np, M.cH = Fe, M.cI = ct, M.cJ = ip, M.cK = fp, M.cL = Ls, M.cM = Ar, M.ca = (a) => a.type === "raster", M.cb = (a) => a.type === "background", M.cc = (a) => a.type === "custom", M.cd = us, M.ce = function (a, t, r) {
                    const n = hn(t.x - r.x, t.y - r.y), l = hn(a.x - r.x, a.y - r.y);
                    var p, d;
                    return Sr(Math.atan2(n[0] * l[1] - n[1] * l[0], (p = n)[0] * (d = l)[0] + p[1] * d[1]));
                }, M.cf = er, M.cg = function (a, t) {
                    return Ia[t] && (a instanceof MouseEvent || a instanceof WheelEvent);
                }, M.ch = function (a, t) {
                    return Ma[t] && "touches" in a;
                }, M.ci = function (a) {
                    return Ma[a] || Ia[a];
                }, M.cj = function (a, t, r) {
                    var n = t[0], l = t[1];
                    return a[0] = r[0] * n + r[4] * l + r[12], a[1] = r[1] * n + r[5] * l + r[13], a;
                }, M.ck = function (a, t) {
                    const { x: r, y: n } = bl.fromLngLat(t);
                    return !(a < 0 || a > 25 || n < 0 || n >= 1 || r < 0 || r >= 1);
                }, M.cl = function (a, t) {
                    return a[0] = t[0], a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = t[1], a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = t[2], a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
                }, M.cm = class extends qn {
                }, M.cn = om, M.cp = function (a) {
                    return a.message === Ca;
                }, M.cq = qi, M.cr = function (a, t) {
                    Pr.REGISTERED_PROTOCOLS[a] = t;
                }, M.cs = function (a) {
                    delete Pr.REGISTERED_PROTOCOLS[a];
                }, M.ct = function (a, t) {
                    const r = {};
                    for (let l = 0; l < a.length; l++) {
                        const p = t && t[a[l].id] || uc(a[l]);
                        t && (t[a[l].id] = p);
                        let d = r[p];
                        d || (d = r[p] = []), d.push(a[l]);
                    }
                    const n = [];
                    for (const l in r) n.push(r[l]);
                    return n;
                }, M.cu = Le, M.cv = Op, M.cw = $p, M.cx = gp, M.cy = function (a) {
                    a.bucket.createArrays(), a.bucket.tilePixelRatio = yt / (512 * a.bucket.overscaling), a.bucket.compareText = {}, a.bucket.iconsNeedLinear = !1;
                    const t = a.bucket.layers[0], r = t.layout, n = t._unevaluatedLayout._values, l = { layoutIconSize: n["icon-size"].possiblyEvaluate(new Tt(a.bucket.zoom + 1), a.canonical), layoutTextSize: n["text-size"].possiblyEvaluate(new Tt(a.bucket.zoom + 1), a.canonical), textMaxSize: n["text-size"].possiblyEvaluate(new Tt(18)) };
                    if (a.bucket.textSizeData.kind === "composite") {
                        const { minZoom: v, maxZoom: b } = a.bucket.textSizeData;
                        l.compositeTextSizes = [n["text-size"].possiblyEvaluate(new Tt(v), a.canonical), n["text-size"].possiblyEvaluate(new Tt(b), a.canonical)];
                    }
                    if (a.bucket.iconSizeData.kind === "composite") {
                        const { minZoom: v, maxZoom: b } = a.bucket.iconSizeData;
                        l.compositeIconSizes = [n["icon-size"].possiblyEvaluate(new Tt(v), a.canonical), n["icon-size"].possiblyEvaluate(new Tt(b), a.canonical)];
                    }
                    const p = r.get("text-line-height") * Yt, d = r.get("text-rotation-alignment") !== "viewport" && r.get("symbol-placement") !== "point", m = r.get("text-keep-upright"), _ = r.get("text-size");
                    for (const v of a.bucket.features) {
                        const b = r.get("text-font").evaluate(v, {}, a.canonical).join(","), S = _.evaluate(v, {}, a.canonical), I = l.layoutTextSize.evaluate(v, {}, a.canonical), A = l.layoutIconSize.evaluate(v, {}, a.canonical), k = { horizontal: {}, vertical: void 0 }, D = v.text;
                        let N, G = [0, 0];
                        if (D) {
                            const C = D.toString(), F = r.get("text-letter-spacing").evaluate(v, {}, a.canonical) * Yt, X = bh(C) ? F : 0, ue = r.get("text-anchor").evaluate(v, {}, a.canonical), Me = Qp(t, v, a.canonical);
                            if (!Me) {
                                const Ie = r.get("text-radial-offset").evaluate(v, {}, a.canonical);
                                G = Ie ? Jp(ue, [Ie * Yt, su]) : r.get("text-offset").evaluate(v, {}, a.canonical).map((ke) => ke * Yt);
                            }
                            let me = d ? "center" : r.get("text-justify").evaluate(v, {}, a.canonical);
                            const xe = r.get("symbol-placement") === "point" ? r.get("text-max-width").evaluate(v, {}, a.canonical) * Yt : 1 / 0, Ae = () => {
                                a.bucket.allowVerticalPlacement && qs(C) && (k.vertical = Bc(D, a.glyphMap, a.glyphPositions, a.imagePositions, b, xe, p, ue, "left", X, G, M.al.vertical, !0, I, S));
                            };
                            if (!d && Me) {
                                const Ie = /* @__PURE__ */ new Set();
                                if (me === "auto") for (let we = 0; we < Me.values.length; we += 2) Ie.add(ou(Me.values[we]));
                                else Ie.add(me);
                                let ke = !1;
                                for (const we of Ie) if (!k.horizontal[we]) if (ke) k.horizontal[we] = k.horizontal[0];
                                else {
                                    const Be = Bc(D, a.glyphMap, a.glyphPositions, a.imagePositions, b, xe, p, "center", we, X, G, M.al.horizontal, !1, I, S);
                                    Be && (k.horizontal[we] = Be, ke = Be.positionedLines.length === 1);
                                }
                                Ae();
                            } else {
                                me === "auto" && (me = ou(ue));
                                const Ie = Bc(D, a.glyphMap, a.glyphPositions, a.imagePositions, b, xe, p, ue, me, X, G, M.al.horizontal, !1, I, S);
                                Ie && (k.horizontal[me] = Ie), Ae(), qs(C) && d && m && (k.vertical = Bc(D, a.glyphMap, a.glyphPositions, a.imagePositions, b, xe, p, ue, me, X, G, M.al.vertical, !1, I, S));
                            }
                        }
                        let ie = !1;
                        if (v.icon && v.icon.name) {
                            const C = a.imageMap[v.icon.name];
                            C && (N = Uf(a.imagePositions[v.icon.name], r.get("icon-offset").evaluate(v, {}, a.canonical), r.get("icon-anchor").evaluate(v, {}, a.canonical)), ie = !!C.sdf, a.bucket.sdfIcons === void 0 ? a.bucket.sdfIcons = ie : a.bucket.sdfIcons !== ie && wi("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (C.pixelRatio !== a.bucket.pixelRatio || r.get("icon-rotate").constantOr(1) !== 0) && (a.bucket.iconsNeedLinear = !0));
                        }
                        const H = td(k.horizontal) || k.vertical;
                        a.bucket.iconsInText = !!H && H.iconsInText, (H || N) && nm(a.bucket, v, k, N, a.imageMap, l, I, A, G, ie, a.canonical, a.subdivisionGranularity);
                    }
                    a.showCollisionBoxes && a.bucket.generateCollisionDebugBuffers();
                }, M.cz = Zh, M.d = oe, M.e = Di, M.f = (a) => c(void 0, void 0, void 0, function* () {
                    if (a.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
                    const t = new Blob([new Uint8Array(a)], { type: "image/png" });
                    try {
                        return createImageBitmap(t);
                    } catch (r) {
                        throw new Error(`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
                    }
                }), M.g = jr, M.h = (a) => new Promise((t, r) => {
                    const n = new Image();
                    n.onload = () => {
                        t(n), URL.revokeObjectURL(n.src), n.onload = null, window.requestAnimationFrame(() => {
                            n.src = pn;
                        });
                    }, n.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                    const l = new Blob([new Uint8Array(a)], { type: "image/png" });
                    n.src = a.byteLength ? URL.createObjectURL(l) : pn;
                }), M.i = dr, M.j = (a, t) => mr(Di(a, { type: "json" }), t), M.k = W, M.l = $, M.m = mr, M.n = (a, t) => mr(Di(a, { type: "arrayBuffer" }), t), M.o = function (a) {
                    return new Hh(a).readFields(kf, []);
                }, M.p = mp, M.q = ll, M.r = Gt, M.s = ta, M.t = Us, M.u = rt, M.v = O, M.w = wi, M.x = Wo, M.y = Xa, M.z = function ([a, t, r]) {
                    return t += 90, t *= Math.PI / 180, r *= Math.PI / 180, { x: a * Math.cos(t) * Math.sin(r), y: a * Math.sin(t) * Math.sin(r), z: a * Math.cos(r) };
                };
            }), se("worker", ["./shared"], function (M) {
                class c {
                    constructor(L) {
                        this.keyCache = {}, L && this.replace(L);
                    }
                    replace(L) {
                        this._layerConfigs = {}, this._layers = {}, this.update(L, []);
                    }
                    update(L, B) {
                        for (const W of L) {
                            this._layerConfigs[W.id] = W;
                            const re = this._layers[W.id] = M.bA(W);
                            re._featureFilter = M.a7(re.filter), this.keyCache[W.id] && delete this.keyCache[W.id];
                        }
                        for (const W of B) delete this.keyCache[W], delete this._layerConfigs[W], delete this._layers[W];
                        this.familiesBySource = {};
                        const $ = M.ct(Object.values(this._layerConfigs), this.keyCache);
                        for (const W of $) {
                            const re = W.map((le) => this._layers[le.id]), O = re[0];
                            if (O.visibility === "none") continue;
                            const pe = O.source || "";
                            let ne = this.familiesBySource[pe];
                            ne || (ne = this.familiesBySource[pe] = {});
                            const ce = O.sourceLayer || "_geojsonTileLayer";
                            let fe = ne[ce];
                            fe || (fe = ne[ce] = []), fe.push(re);
                        }
                    }
                }
                class Fe {
                    constructor(L) {
                        const B = {}, $ = [];
                        for (const pe in L) {
                            const ne = L[pe], ce = B[pe] = {};
                            for (const fe in ne) {
                                const le = ne[+fe];
                                if (!le || le.bitmap.width === 0 || le.bitmap.height === 0) continue;
                                const Pe = { x: 0, y: 0, w: le.bitmap.width + 2, h: le.bitmap.height + 2 };
                                $.push(Pe), ce[fe] = { rect: Pe, metrics: le.metrics };
                            }
                        }
                        const { w: W, h: re } = M.p($), O = new M.q({ width: W || 1, height: re || 1 });
                        for (const pe in L) {
                            const ne = L[pe];
                            for (const ce in ne) {
                                const fe = ne[+ce];
                                if (!fe || fe.bitmap.width === 0 || fe.bitmap.height === 0) continue;
                                const le = B[pe][ce].rect;
                                M.q.copy(fe.bitmap, O, { x: 0, y: 0 }, { x: le.x + 1, y: le.y + 1 }, fe.bitmap);
                            }
                        }
                        this.image = O, this.positions = B;
                    }
                }
                M.cu("GlyphAtlas", Fe);
                class ht {
                    constructor(L) {
                        this.tileID = new M.Y(L.tileID.overscaledZ, L.tileID.wrap, L.tileID.canonical.z, L.tileID.canonical.x, L.tileID.canonical.y), this.uid = L.uid, this.zoom = L.zoom, this.pixelRatio = L.pixelRatio, this.tileSize = L.tileSize, this.source = L.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = L.showCollisionBoxes, this.collectResourceTiming = !!L.collectResourceTiming, this.returnDependencies = !!L.returnDependencies, this.promoteId = L.promoteId, this.inFlightDependencies = [];
                    }
                    parse(L, B, $, W, re) {
                        return M._(this, void 0, void 0, function* () {
                            this.status = "parsing", this.data = L, this.collisionBoxArray = new M.a5();
                            const O = new M.cv(Object.keys(L.layers).sort()), pe = new M.cw(this.tileID, this.promoteId);
                            pe.bucketLayerIDs = [];
                            const ne = {}, ce = { featureIndex: pe, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: $, subdivisionGranularity: re }, fe = B.familiesBySource[this.source];
                            for (const We in fe) {
                                const Se = L.layers[We];
                                if (!Se) continue;
                                Se.version === 1 && M.w(`Vector tile source "${this.source}" layer "${We}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                                const qe = O.encode(We), Je = [];
                                for (let Lt = 0; Lt < Se.length; Lt++) {
                                    const Bt = Se.feature(Lt), ki = pe.getId(Bt, We);
                                    Je.push({ feature: Bt, id: ki, index: Lt, sourceLayerIndex: qe });
                                }
                                for (const Lt of fe[We]) {
                                    const Bt = Lt[0];
                                    Bt.source !== this.source && M.w(`layer.source = ${Bt.source} does not equal this.source = ${this.source}`), Bt.minzoom && this.zoom < Math.floor(Bt.minzoom) || Bt.maxzoom && this.zoom >= Bt.maxzoom || Bt.visibility !== "none" && (_t(Lt, this.zoom, $), (ne[Bt.id] = Bt.createBucket({ index: pe.bucketLayerIDs.length, layers: Lt, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: qe, sourceID: this.source })).populate(Je, ce, this.tileID.canonical), pe.bucketLayerIDs.push(Lt.map((ki) => ki.id)));
                                }
                            }
                            const le = M.bF(ce.glyphDependencies, (We) => Object.keys(We).map(Number));
                            this.inFlightDependencies.forEach((We) => We == null ? void 0 : We.abort()), this.inFlightDependencies = [];
                            let Pe = Promise.resolve({});
                            if (Object.keys(le).length) {
                                const We = new AbortController();
                                this.inFlightDependencies.push(We), Pe = W.sendAsync({ type: "GG", data: { stacks: le, source: this.source, tileID: this.tileID, type: "glyphs" } }, We);
                            }
                            const Re = Object.keys(ce.iconDependencies);
                            let De = Promise.resolve({});
                            if (Re.length) {
                                const We = new AbortController();
                                this.inFlightDependencies.push(We), De = W.sendAsync({ type: "GI", data: { icons: Re, source: this.source, tileID: this.tileID, type: "icons" } }, We);
                            }
                            const Ze = Object.keys(ce.patternDependencies);
                            let Ye = Promise.resolve({});
                            if (Ze.length) {
                                const We = new AbortController();
                                this.inFlightDependencies.push(We), Ye = W.sendAsync({ type: "GI", data: { icons: Ze, source: this.source, tileID: this.tileID, type: "patterns" } }, We);
                            }
                            const [Xe, ve, gt] = yield Promise.all([Pe, De, Ye]), nt = new Fe(Xe), dt = new M.cx(ve, gt);
                            for (const We in ne) {
                                const Se = ne[We];
                                Se instanceof M.a6 ? (_t(Se.layers, this.zoom, $), M.cy({ bucket: Se, glyphMap: Xe, glyphPositions: nt.positions, imageMap: ve, imagePositions: dt.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: ce.subdivisionGranularity })) : Se.hasPattern && (Se instanceof M.cz || Se instanceof M.cA || Se instanceof M.cB) && (_t(Se.layers, this.zoom, $), Se.addFeatures(ce, this.tileID.canonical, dt.patternPositions));
                            }
                            return this.status = "done", { buckets: Object.values(ne).filter((We) => !We.isEmpty()), featureIndex: pe, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: nt.image, imageAtlas: dt, glyphMap: this.returnDependencies ? Xe : null, iconMap: this.returnDependencies ? ve : null, glyphPositions: this.returnDependencies ? nt.positions : null };
                        });
                    }
                }
                function _t(oe, L, B) {
                    const $ = new M.C(L);
                    for (const W of oe) W.recalculate($, B);
                }
                class ct {
                    constructor(L, B, $) {
                        this.actor = L, this.layerIndex = B, this.availableImages = $, this.fetching = {}, this.loading = {}, this.loaded = {};
                    }
                    loadVectorTile(L, B) {
                        return M._(this, void 0, void 0, function* () {
                            const $ = yield M.n(L.request, B);
                            try {
                                return { vectorTile: new M.cC.VectorTile(new M.cD($.data)), rawData: $.data, cacheControl: $.cacheControl, expires: $.expires };
                            } catch (W) {
                                const re = new Uint8Array($.data);
                                let O = `Unable to parse the tile at ${L.request.url}, `;
                                throw O += re[0] === 31 && re[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${W.message}`, new Error(O);
                            }
                        });
                    }
                    loadTile(L) {
                        return M._(this, void 0, void 0, function* () {
                            const B = L.uid, $ = !!(L && L.request && L.request.collectResourceTiming) && new M.cE(L.request), W = new ht(L);
                            this.loading[B] = W;
                            const re = new AbortController();
                            W.abort = re;
                            try {
                                const O = yield this.loadVectorTile(L, re);
                                if (delete this.loading[B], !O) return null;
                                const pe = O.rawData, ne = {};
                                O.expires && (ne.expires = O.expires), O.cacheControl && (ne.cacheControl = O.cacheControl);
                                const ce = {};
                                if ($) {
                                    const le = $.finish();
                                    le && (ce.resourceTiming = JSON.parse(JSON.stringify(le)));
                                }
                                W.vectorTile = O.vectorTile;
                                const fe = W.parse(O.vectorTile, this.layerIndex, this.availableImages, this.actor, L.subdivisionGranularity);
                                this.loaded[B] = W, this.fetching[B] = { rawTileData: pe, cacheControl: ne, resourceTiming: ce };
                                try {
                                    const le = yield fe;
                                    return M.e({ rawTileData: pe.slice(0) }, le, ne, ce);
                                } finally {
                                    delete this.fetching[B];
                                }
                            } catch (O) {
                                throw delete this.loading[B], W.status = "done", this.loaded[B] = W, O;
                            }
                        });
                    }
                    reloadTile(L) {
                        return M._(this, void 0, void 0, function* () {
                            const B = L.uid;
                            if (!this.loaded || !this.loaded[B]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
                            const $ = this.loaded[B];
                            if ($.showCollisionBoxes = L.showCollisionBoxes, $.status === "parsing") {
                                const W = yield $.parse($.vectorTile, this.layerIndex, this.availableImages, this.actor, L.subdivisionGranularity);
                                let re;
                                if (this.fetching[B]) {
                                    const { rawTileData: O, cacheControl: pe, resourceTiming: ne } = this.fetching[B];
                                    delete this.fetching[B], re = M.e({ rawTileData: O.slice(0) }, W, pe, ne);
                                } else re = W;
                                return re;
                            }
                            if ($.status === "done" && $.vectorTile) return $.parse($.vectorTile, this.layerIndex, this.availableImages, this.actor, L.subdivisionGranularity);
                        });
                    }
                    abortTile(L) {
                        return M._(this, void 0, void 0, function* () {
                            const B = this.loading, $ = L.uid;
                            B && B[$] && B[$].abort && (B[$].abort.abort(), delete B[$]);
                        });
                    }
                    removeTile(L) {
                        return M._(this, void 0, void 0, function* () {
                            this.loaded && this.loaded[L.uid] && delete this.loaded[L.uid];
                        });
                    }
                }
                class Ue {
                    constructor() {
                        this.loaded = {};
                    }
                    loadTile(L) {
                        return M._(this, void 0, void 0, function* () {
                            const { uid: B, encoding: $, rawImageData: W, redFactor: re, greenFactor: O, blueFactor: pe, baseShift: ne } = L, ce = W.width + 2, fe = W.height + 2, le = M.b(W) ? new M.R({ width: ce, height: fe }, yield M.cF(W, -1, -1, ce, fe)) : W, Pe = new M.cG(B, le, $, re, O, pe, ne);
                            return this.loaded = this.loaded || {}, this.loaded[B] = Pe, Pe;
                        });
                    }
                    removeTile(L) {
                        const B = this.loaded, $ = L.uid;
                        B && B[$] && delete B[$];
                    }
                }
                var de, $e, lr = function () {
                    if ($e) return de;
                    function oe(B, $) {
                        if (B.length !== 0) {
                            L(B[0], $);
                            for (var W = 1; W < B.length; W++) L(B[W], !$);
                        }
                    }
                    function L(B, $) {
                        for (var W = 0, re = 0, O = 0, pe = B.length, ne = pe - 1; O < pe; ne = O++) {
                            var ce = (B[O][0] - B[ne][0]) * (B[ne][1] + B[O][1]), fe = W + ce;
                            re += Math.abs(W) >= Math.abs(ce) ? W - fe + ce : ce - fe + W, W = fe;
                        }
                        W + re >= 0 != !!$ && B.reverse();
                    }
                    return $e = 1, de = function B($, W) {
                        var re, O = $ && $.type;
                        if (O === "FeatureCollection") for (re = 0; re < $.features.length; re++) B($.features[re], W);
                        else if (O === "GeometryCollection") for (re = 0; re < $.geometries.length; re++) B($.geometries[re], W);
                        else if (O === "Feature") B($.geometry, W);
                        else if (O === "Polygon") oe($.coordinates, W);
                        else if (O === "MultiPolygon") for (re = 0; re < $.coordinates.length; re++) oe($.coordinates[re], W);
                        return $;
                    };
                }(), cr = M.cH(lr);
                const wr = M.cC.VectorTileFeature.prototype.toGeoJSON;
                class Qr {
                    constructor(L) {
                        this._feature = L, this.extent = M.Z, this.type = L.type, this.properties = L.tags, "id" in L && !isNaN(L.id) && (this.id = parseInt(L.id, 10));
                    }
                    loadGeometry() {
                        if (this._feature.type === 1) {
                            const L = [];
                            for (const B of this._feature.geometry) L.push([new M.P(B[0], B[1])]);
                            return L;
                        }
                        {
                            const L = [];
                            for (const B of this._feature.geometry) {
                                const $ = [];
                                for (const W of B) $.push(new M.P(W[0], W[1]));
                                L.push($);
                            }
                            return L;
                        }
                    }
                    toGeoJSON(L, B, $) {
                        return wr.call(this, L, B, $);
                    }
                }
                class ln {
                    constructor(L) {
                        this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = M.Z, this.length = L.length, this._features = L;
                    }
                    feature(L) {
                        return new Qr(this._features[L]);
                    }
                }
                var bi, Zt, Rt, hr = { exports: {} }, Dt = function () {
                    if (Rt) return hr.exports;
                    Rt = 1;
                    var oe = M.cK(), L = function () {
                        if (Zt) return bi;
                        Zt = 1;
                        var fe = M.cI(), le = M.cJ().VectorTileFeature;
                        function Pe(De, Ze) {
                            this.options = Ze || {}, this.features = De, this.length = De.length;
                        }
                        function Re(De, Ze) {
                            this.id = typeof De.id == "number" ? De.id : void 0, this.type = De.type, this.rawGeometry = De.type === 1 ? [De.geometry] : De.geometry, this.properties = De.tags, this.extent = Ze || 4096;
                        }
                        return bi = Pe, Pe.prototype.feature = function (De) {
                            return new Re(this.features[De], this.options.extent);
                        }, Re.prototype.loadGeometry = function () {
                            var De = this.rawGeometry;
                            this.geometry = [];
                            for (var Ze = 0; Ze < De.length; Ze++) {
                                for (var Ye = De[Ze], Xe = [], ve = 0; ve < Ye.length; ve++) Xe.push(new fe(Ye[ve][0], Ye[ve][1]));
                                this.geometry.push(Xe);
                            }
                            return this.geometry;
                        }, Re.prototype.bbox = function () {
                            this.geometry || this.loadGeometry();
                            for (var De = this.geometry, Ze = 1 / 0, Ye = -1 / 0, Xe = 1 / 0, ve = -1 / 0, gt = 0; gt < De.length; gt++) for (var nt = De[gt], dt = 0; dt < nt.length; dt++) {
                                var We = nt[dt];
                                Ze = Math.min(Ze, We.x), Ye = Math.max(Ye, We.x), Xe = Math.min(Xe, We.y), ve = Math.max(ve, We.y);
                            }
                            return [Ze, Xe, Ye, ve];
                        }, Re.prototype.toGeoJSON = le.prototype.toGeoJSON, bi;
                    }();
                    function B(fe) {
                        var le = new oe();
                        return function (Pe, Re) {
                            for (var De in Pe.layers) Re.writeMessage(3, $, Pe.layers[De]);
                        }(fe, le), le.finish();
                    }
                    function $(fe, le) {
                        var Pe;
                        le.writeVarintField(15, fe.version || 1), le.writeStringField(1, fe.name || ""), le.writeVarintField(5, fe.extent || 4096);
                        var Re = { keys: [], values: [], keycache: {}, valuecache: {} };
                        for (Pe = 0; Pe < fe.length; Pe++) Re.feature = fe.feature(Pe), le.writeMessage(2, W, Re);
                        var De = Re.keys;
                        for (Pe = 0; Pe < De.length; Pe++) le.writeStringField(3, De[Pe]);
                        var Ze = Re.values;
                        for (Pe = 0; Pe < Ze.length; Pe++) le.writeMessage(4, ce, Ze[Pe]);
                    }
                    function W(fe, le) {
                        var Pe = fe.feature;
                        Pe.id !== void 0 && le.writeVarintField(1, Pe.id), le.writeMessage(2, re, fe), le.writeVarintField(3, Pe.type), le.writeMessage(4, ne, Pe);
                    }
                    function re(fe, le) {
                        var Pe = fe.feature, Re = fe.keys, De = fe.values, Ze = fe.keycache, Ye = fe.valuecache;
                        for (var Xe in Pe.properties) {
                            var ve = Pe.properties[Xe], gt = Ze[Xe];
                            if (ve !== null) {
                                gt === void 0 && (Re.push(Xe), Ze[Xe] = gt = Re.length - 1), le.writeVarint(gt);
                                var nt = typeof ve;
                                nt !== "string" && nt !== "boolean" && nt !== "number" && (ve = JSON.stringify(ve));
                                var dt = nt + ":" + ve, We = Ye[dt];
                                We === void 0 && (De.push(ve), Ye[dt] = We = De.length - 1), le.writeVarint(We);
                            }
                        }
                    }
                    function O(fe, le) {
                        return (le << 3) + (7 & fe);
                    }
                    function pe(fe) {
                        return fe << 1 ^ fe >> 31;
                    }
                    function ne(fe, le) {
                        for (var Pe = fe.loadGeometry(), Re = fe.type, De = 0, Ze = 0, Ye = Pe.length, Xe = 0; Xe < Ye; Xe++) {
                            var ve = Pe[Xe], gt = 1;
                            Re === 1 && (gt = ve.length), le.writeVarint(O(1, gt));
                            for (var nt = Re === 3 ? ve.length - 1 : ve.length, dt = 0; dt < nt; dt++) {
                                dt === 1 && Re !== 1 && le.writeVarint(O(2, nt - 1));
                                var We = ve[dt].x - De, Se = ve[dt].y - Ze;
                                le.writeVarint(pe(We)), le.writeVarint(pe(Se)), De += We, Ze += Se;
                            }
                            Re === 3 && le.writeVarint(O(7, 1));
                        }
                    }
                    function ce(fe, le) {
                        var Pe = typeof fe;
                        Pe === "string" ? le.writeStringField(1, fe) : Pe === "boolean" ? le.writeBooleanField(7, fe) : Pe === "number" && (fe % 1 != 0 ? le.writeDoubleField(3, fe) : fe < 0 ? le.writeSVarintField(6, fe) : le.writeVarintField(5, fe));
                    }
                    return hr.exports = B, hr.exports.fromVectorTileJs = B, hr.exports.fromGeojsonVt = function (fe, le) {
                        le = le || {};
                        var Pe = {};
                        for (var Re in fe) Pe[Re] = new L(fe[Re].features, le), Pe[Re].name = Re, Pe[Re].version = le.version, Pe[Re].extent = le.extent;
                        return B({ layers: Pe });
                    }, hr.exports.GeoJSONWrapper = L, hr.exports;
                }(), cs = M.cH(Dt);
                const hs = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (oe) => oe }, Br = Math.fround || (ur = new Float32Array(1), (oe) => (ur[0] = +oe, ur[0]));
                var ur;
                const Ji = 3, mi = 5, cn = 6;
                class Sa {
                    constructor(L) {
                        this.options = Object.assign(Object.create(hs), L), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
                    }
                    load(L) {
                        const { log: B, minZoom: $, maxZoom: W } = this.options;
                        B && console.time("total time");
                        const re = `prepare ${L.length} points`;
                        B && console.time(re), this.points = L;
                        const O = [];
                        for (let ne = 0; ne < L.length; ne++) {
                            const ce = L[ne];
                            if (!ce.geometry) continue;
                            const [fe, le] = ce.geometry.coordinates, Pe = Br(Fr(fe)), Re = Br(pr(le));
                            O.push(Pe, Re, 1 / 0, ne, -1, 1), this.options.reduce && O.push(0);
                        }
                        let pe = this.trees[W + 1] = this._createTree(O);
                        B && console.timeEnd(re);
                        for (let ne = W; ne >= $; ne--) {
                            const ce = +Date.now();
                            pe = this.trees[ne] = this._createTree(this._cluster(pe, ne)), B && console.log("z%d: %d clusters in %dms", ne, pe.numItems, +Date.now() - ce);
                        }
                        return B && console.timeEnd("total time"), this;
                    }
                    getClusters(L, B) {
                        let $ = ((L[0] + 180) % 360 + 360) % 360 - 180;
                        const W = Math.max(-90, Math.min(90, L[1]));
                        let re = L[2] === 180 ? 180 : ((L[2] + 180) % 360 + 360) % 360 - 180;
                        const O = Math.max(-90, Math.min(90, L[3]));
                        if (L[2] - L[0] >= 360) $ = -180, re = 180;
                        else if ($ > re) {
                            const le = this.getClusters([$, W, 180, O], B), Pe = this.getClusters([-180, W, re, O], B);
                            return le.concat(Pe);
                        }
                        const pe = this.trees[this._limitZoom(B)], ne = pe.range(Fr($), pr(O), Fr(re), pr(W)), ce = pe.data, fe = [];
                        for (const le of ne) {
                            const Pe = this.stride * le;
                            fe.push(ce[Pe + mi] > 1 ? hn(ce, Pe, this.clusterProps) : this.points[ce[Pe + Ji]]);
                        }
                        return fe;
                    }
                    getChildren(L) {
                        const B = this._getOriginId(L), $ = this._getOriginZoom(L), W = "No cluster with the specified id.", re = this.trees[$];
                        if (!re) throw new Error(W);
                        const O = re.data;
                        if (B * this.stride >= O.length) throw new Error(W);
                        const pe = this.options.radius / (this.options.extent * Math.pow(2, $ - 1)), ne = re.within(O[B * this.stride], O[B * this.stride + 1], pe), ce = [];
                        for (const fe of ne) {
                            const le = fe * this.stride;
                            O[le + 4] === L && ce.push(O[le + mi] > 1 ? hn(O, le, this.clusterProps) : this.points[O[le + Ji]]);
                        }
                        if (ce.length === 0) throw new Error(W);
                        return ce;
                    }
                    getLeaves(L, B, $) {
                        const W = [];
                        return this._appendLeaves(W, L, B = B || 10, $ = $ || 0, 0), W;
                    }
                    getTile(L, B, $) {
                        const W = this.trees[this._limitZoom(L)], re = Math.pow(2, L), { extent: O, radius: pe } = this.options, ne = pe / O, ce = ($ - ne) / re, fe = ($ + 1 + ne) / re, le = { features: [] };
                        return this._addTileFeatures(W.range((B - ne) / re, ce, (B + 1 + ne) / re, fe), W.data, B, $, re, le), B === 0 && this._addTileFeatures(W.range(1 - ne / re, ce, 1, fe), W.data, re, $, re, le), B === re - 1 && this._addTileFeatures(W.range(0, ce, ne / re, fe), W.data, -1, $, re, le), le.features.length ? le : null;
                    }
                    getClusterExpansionZoom(L) {
                        let B = this._getOriginZoom(L) - 1;
                        for (; B <= this.options.maxZoom;) {
                            const $ = this.getChildren(L);
                            if (B++, $.length !== 1) break;
                            L = $[0].properties.cluster_id;
                        }
                        return B;
                    }
                    _appendLeaves(L, B, $, W, re) {
                        const O = this.getChildren(B);
                        for (const pe of O) {
                            const ne = pe.properties;
                            if (ne && ne.cluster ? re + ne.point_count <= W ? re += ne.point_count : re = this._appendLeaves(L, ne.cluster_id, $, W, re) : re < W ? re++ : L.push(pe), L.length === $) break;
                        }
                        return re;
                    }
                    _createTree(L) {
                        const B = new M.aF(L.length / this.stride | 0, this.options.nodeSize, Float32Array);
                        for (let $ = 0; $ < L.length; $ += this.stride) B.add(L[$], L[$ + 1]);
                        return B.finish(), B.data = L, B;
                    }
                    _addTileFeatures(L, B, $, W, re, O) {
                        for (const pe of L) {
                            const ne = pe * this.stride, ce = B[ne + mi] > 1;
                            let fe, le, Pe;
                            if (ce) fe = yt(B, ne, this.clusterProps), le = B[ne], Pe = B[ne + 1];
                            else {
                                const Ze = this.points[B[ne + Ji]];
                                fe = Ze.properties;
                                const [Ye, Xe] = Ze.geometry.coordinates;
                                le = Fr(Ye), Pe = pr(Xe);
                            }
                            const Re = { type: 1, geometry: [[Math.round(this.options.extent * (le * re - $)), Math.round(this.options.extent * (Pe * re - W))]], tags: fe };
                            let De;
                            De = ce || this.options.generateId ? B[ne + Ji] : this.points[B[ne + Ji]].id, De !== void 0 && (Re.id = De), O.features.push(Re);
                        }
                    }
                    _limitZoom(L) {
                        return Math.max(this.options.minZoom, Math.min(Math.floor(+L), this.options.maxZoom + 1));
                    }
                    _cluster(L, B) {
                        const { radius: $, extent: W, reduce: re, minPoints: O } = this.options, pe = $ / (W * Math.pow(2, B)), ne = L.data, ce = [], fe = this.stride;
                        for (let le = 0; le < ne.length; le += fe) {
                            if (ne[le + 2] <= B) continue;
                            ne[le + 2] = B;
                            const Pe = ne[le], Re = ne[le + 1], De = L.within(ne[le], ne[le + 1], pe), Ze = ne[le + mi];
                            let Ye = Ze;
                            for (const Xe of De) {
                                const ve = Xe * fe;
                                ne[ve + 2] > B && (Ye += ne[ve + mi]);
                            }
                            if (Ye > Ze && Ye >= O) {
                                let Xe, ve = Pe * Ze, gt = Re * Ze, nt = -1;
                                const dt = ((le / fe | 0) << 5) + (B + 1) + this.points.length;
                                for (const We of De) {
                                    const Se = We * fe;
                                    if (ne[Se + 2] <= B) continue;
                                    ne[Se + 2] = B;
                                    const qe = ne[Se + mi];
                                    ve += ne[Se] * qe, gt += ne[Se + 1] * qe, ne[Se + 4] = dt, re && (Xe || (Xe = this._map(ne, le, !0), nt = this.clusterProps.length, this.clusterProps.push(Xe)), re(Xe, this._map(ne, Se)));
                                }
                                ne[le + 4] = dt, ce.push(ve / Ye, gt / Ye, 1 / 0, dt, -1, Ye), re && ce.push(nt);
                            } else {
                                for (let Xe = 0; Xe < fe; Xe++) ce.push(ne[le + Xe]);
                                if (Ye > 1) for (const Xe of De) {
                                    const ve = Xe * fe;
                                    if (!(ne[ve + 2] <= B)) {
                                        ne[ve + 2] = B;
                                        for (let gt = 0; gt < fe; gt++) ce.push(ne[ve + gt]);
                                    }
                                }
                            }
                        }
                        return ce;
                    }
                    _getOriginId(L) {
                        return L - this.points.length >> 5;
                    }
                    _getOriginZoom(L) {
                        return (L - this.points.length) % 32;
                    }
                    _map(L, B, $) {
                        if (L[B + mi] > 1) {
                            const O = this.clusterProps[L[B + cn]];
                            return $ ? Object.assign({}, O) : O;
                        }
                        const W = this.points[L[B + Ji]].properties, re = this.options.map(W);
                        return $ && re === W ? Object.assign({}, re) : re;
                    }
                }
                function hn(oe, L, B) {
                    return { type: "Feature", id: oe[L + Ji], properties: yt(oe, L, B), geometry: { type: "Point", coordinates: [($ = oe[L], 360 * ($ - 0.5)), Ta(oe[L + 1])] } };
                    var $;
                }
                function yt(oe, L, B) {
                    const $ = oe[L + mi], W = $ >= 1e4 ? `${Math.round($ / 1e3)}k` : $ >= 1e3 ? Math.round($ / 100) / 10 + "k" : $, re = oe[L + cn], O = re === -1 ? {} : Object.assign({}, B[re]);
                    return Object.assign(O, { cluster: !0, cluster_id: oe[L + Ji], point_count: $, point_count_abbreviated: W });
                }
                function Fr(oe) {
                    return oe / 360 + 0.5;
                }
                function pr(oe) {
                    const L = Math.sin(oe * Math.PI / 180), B = 0.5 - 0.25 * Math.log((1 + L) / (1 - L)) / Math.PI;
                    return B < 0 ? 0 : B > 1 ? 1 : B;
                }
                function Ta(oe) {
                    const L = (180 - 360 * oe) * Math.PI / 180;
                    return 360 * Math.atan(Math.exp(L)) / Math.PI - 90;
                }
                function Qi(oe, L, B, $) {
                    let W = $;
                    const re = L + (B - L >> 1);
                    let O, pe = B - L;
                    const ne = oe[L], ce = oe[L + 1], fe = oe[B], le = oe[B + 1];
                    for (let Pe = L + 3; Pe < B; Pe += 3) {
                        const Re = us(oe[Pe], oe[Pe + 1], ne, ce, fe, le);
                        if (Re > W) O = Pe, W = Re;
                        else if (Re === W) {
                            const De = Math.abs(Pe - re);
                            De < pe && (O = Pe, pe = De);
                        }
                    }
                    W > $ && (O - L > 3 && Qi(oe, L, O, $), oe[O + 2] = W, B - O > 3 && Qi(oe, O, B, $));
                }
                function us(oe, L, B, $, W, re) {
                    let O = W - B, pe = re - $;
                    if (O !== 0 || pe !== 0) {
                        const ne = ((oe - B) * O + (L - $) * pe) / (O * O + pe * pe);
                        ne > 1 ? (B = W, $ = re) : ne > 0 && (B += O * ne, $ += pe * ne);
                    }
                    return O = oe - B, pe = L - $, O * O + pe * pe;
                }
                function er(oe, L, B, $) {
                    const W = { id: oe ?? null, type: L, geometry: B, tags: $, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
                    if (L === "Point" || L === "MultiPoint" || L === "LineString") li(W, B);
                    else if (L === "Polygon") li(W, B[0]);
                    else if (L === "MultiLineString") for (const re of B) li(W, re);
                    else if (L === "MultiPolygon") for (const re of B) li(W, re[0]);
                    return W;
                }
                function li(oe, L) {
                    for (let B = 0; B < L.length; B += 3) oe.minX = Math.min(oe.minX, L[B]), oe.minY = Math.min(oe.minY, L[B + 1]), oe.maxX = Math.max(oe.maxX, L[B]), oe.maxY = Math.max(oe.maxY, L[B + 1]);
                }
                function Nr(oe, L, B, $) {
                    if (!L.geometry) return;
                    const W = L.geometry.coordinates;
                    if (W && W.length === 0) return;
                    const re = L.geometry.type, O = Math.pow(B.tolerance / ((1 << B.maxZoom) * B.extent), 2);
                    let pe = [], ne = L.id;
                    if (B.promoteId ? ne = L.properties[B.promoteId] : B.generateId && (ne = $ || 0), re === "Point") Di(W, pe);
                    else if (re === "MultiPoint") for (const ce of W) Di(ce, pe);
                    else if (re === "LineString") Pa(W, pe, O, !1);
                    else if (re === "MultiLineString") {
                        if (B.lineMetrics) {
                            for (const ce of W) pe = [], Pa(ce, pe, O, !1), oe.push(er(ne, "LineString", pe, L.properties));
                            return;
                        }
                        ea(W, pe, O, !1);
                    } else if (re === "Polygon") ea(W, pe, O, !0);
                    else {
                        if (re !== "MultiPolygon") {
                            if (re === "GeometryCollection") {
                                for (const ce of L.geometry.geometries) Nr(oe, { id: ne, geometry: ce, properties: L.properties }, B, $);
                                return;
                            }
                            throw new Error("Input data is not a valid GeoJSON object.");
                        }
                        for (const ce of W) {
                            const fe = [];
                            ea(ce, fe, O, !0), pe.push(fe);
                        }
                    }
                    oe.push(er(ne, re, pe, L.properties));
                }
                function Di(oe, L) {
                    L.push(un(oe[0]), Li(oe[1]), 0);
                }
                function Pa(oe, L, B, $) {
                    let W, re, O = 0;
                    for (let ne = 0; ne < oe.length; ne++) {
                        const ce = un(oe[ne][0]), fe = Li(oe[ne][1]);
                        L.push(ce, fe, 0), ne > 0 && (O += $ ? (W * fe - ce * re) / 2 : Math.sqrt(Math.pow(ce - W, 2) + Math.pow(fe - re, 2))), W = ce, re = fe;
                    }
                    const pe = L.length - 3;
                    L[2] = 1, Qi(L, 0, pe, B), L[pe + 2] = 1, L.size = Math.abs(O), L.start = 0, L.end = L.size;
                }
                function ea(oe, L, B, $) {
                    for (let W = 0; W < oe.length; W++) {
                        const re = [];
                        Pa(oe[W], re, B, $), L.push(re);
                    }
                }
                function un(oe) {
                    return oe / 360 + 0.5;
                }
                function Li(oe) {
                    const L = Math.sin(oe * Math.PI / 180), B = 0.5 - 0.25 * Math.log((1 + L) / (1 - L)) / Math.PI;
                    return B < 0 ? 0 : B > 1 ? 1 : B;
                }
                function Bi(oe, L, B, $, W, re, O, pe) {
                    if ($ /= L, re >= (B /= L) && O < $) return oe;
                    if (O < B || re >= $) return null;
                    const ne = [];
                    for (const ce of oe) {
                        const fe = ce.geometry;
                        let le = ce.type;
                        const Pe = W === 0 ? ce.minX : ce.minY, Re = W === 0 ? ce.maxX : ce.maxY;
                        if (Pe >= B && Re < $) {
                            ne.push(ce);
                            continue;
                        }
                        if (Re < B || Pe >= $) continue;
                        let De = [];
                        if (le === "Point" || le === "MultiPoint") wi(fe, De, B, $, W);
                        else if (le === "LineString") bt(fe, De, B, $, W, !1, pe.lineMetrics);
                        else if (le === "MultiLineString") Or(fe, De, B, $, W, !1);
                        else if (le === "Polygon") Or(fe, De, B, $, W, !0);
                        else if (le === "MultiPolygon") for (const Ze of fe) {
                            const Ye = [];
                            Or(Ze, Ye, B, $, W, !0), Ye.length && De.push(Ye);
                        }
                        if (De.length) {
                            if (pe.lineMetrics && le === "LineString") {
                                for (const Ze of De) ne.push(er(ce.id, le, Ze, ce.tags));
                                continue;
                            }
                            le !== "LineString" && le !== "MultiLineString" || (De.length === 1 ? (le = "LineString", De = De[0]) : le = "MultiLineString"), le !== "Point" && le !== "MultiPoint" || (le = De.length === 3 ? "Point" : "MultiPoint"), ne.push(er(ce.id, le, De, ce.tags));
                        }
                    }
                    return ne.length ? ne : null;
                }
                function wi(oe, L, B, $, W) {
                    for (let re = 0; re < oe.length; re += 3) {
                        const O = oe[re + W];
                        O >= B && O <= $ && Gi(L, oe[re], oe[re + 1], oe[re + 2]);
                    }
                }
                function bt(oe, L, B, $, W, re, O) {
                    let pe = dr(oe);
                    const ne = W === 0 ? pn : dn;
                    let ce, fe, le = oe.start;
                    for (let Ye = 0; Ye < oe.length - 3; Ye += 3) {
                        const Xe = oe[Ye], ve = oe[Ye + 1], gt = oe[Ye + 2], nt = oe[Ye + 3], dt = oe[Ye + 4], We = W === 0 ? Xe : ve, Se = W === 0 ? nt : dt;
                        let qe = !1;
                        O && (ce = Math.sqrt(Math.pow(Xe - nt, 2) + Math.pow(ve - dt, 2))), We < B ? Se > B && (fe = ne(pe, Xe, ve, nt, dt, B), O && (pe.start = le + ce * fe)) : We > $ ? Se < $ && (fe = ne(pe, Xe, ve, nt, dt, $), O && (pe.start = le + ce * fe)) : Gi(pe, Xe, ve, gt), Se < B && We >= B && (fe = ne(pe, Xe, ve, nt, dt, B), qe = !0), Se > $ && We <= $ && (fe = ne(pe, Xe, ve, nt, dt, $), qe = !0), !re && qe && (O && (pe.end = le + ce * fe), L.push(pe), pe = dr(oe)), O && (le += ce);
                    }
                    let Pe = oe.length - 3;
                    const Re = oe[Pe], De = oe[Pe + 1], Ze = W === 0 ? Re : De;
                    Ze >= B && Ze <= $ && Gi(pe, Re, De, oe[Pe + 2]), Pe = pe.length - 3, re && Pe >= 3 && (pe[Pe] !== pe[0] || pe[Pe + 1] !== pe[1]) && Gi(pe, pe[0], pe[1], pe[2]), pe.length && L.push(pe);
                }
                function dr(oe) {
                    const L = [];
                    return L.size = oe.size, L.start = oe.start, L.end = oe.end, L;
                }
                function Or(oe, L, B, $, W, re) {
                    for (const O of oe) bt(O, L, B, $, W, re, !1);
                }
                function Gi(oe, L, B, $) {
                    oe.push(L, B, $);
                }
                function pn(oe, L, B, $, W, re) {
                    const O = (re - L) / ($ - L);
                    return Gi(oe, re, B + (W - B) * O, 1), O;
                }
                function dn(oe, L, B, $, W, re) {
                    const O = (re - B) / (W - B);
                    return Gi(oe, L + ($ - L) * O, re, 1), O;
                }
                function Fi(oe, L) {
                    const B = [];
                    for (let $ = 0; $ < oe.length; $++) {
                        const W = oe[$], re = W.type;
                        let O;
                        if (re === "Point" || re === "MultiPoint" || re === "LineString") O = fr(W.geometry, L);
                        else if (re === "MultiLineString" || re === "Polygon") {
                            O = [];
                            for (const pe of W.geometry) O.push(fr(pe, L));
                        } else if (re === "MultiPolygon") {
                            O = [];
                            for (const pe of W.geometry) {
                                const ne = [];
                                for (const ce of pe) ne.push(fr(ce, L));
                                O.push(ne);
                            }
                        }
                        B.push(er(W.id, re, O, W.tags));
                    }
                    return B;
                }
                function fr(oe, L) {
                    const B = [];
                    B.size = oe.size, oe.start !== void 0 && (B.start = oe.start, B.end = oe.end);
                    for (let $ = 0; $ < oe.length; $ += 3) B.push(oe[$] + L, oe[$ + 1], oe[$ + 2]);
                    return B;
                }
                function ta(oe, L) {
                    if (oe.transformed) return oe;
                    const B = 1 << oe.z, $ = oe.x, W = oe.y;
                    for (const re of oe.features) {
                        const O = re.geometry, pe = re.type;
                        if (re.geometry = [], pe === 1) for (let ne = 0; ne < O.length; ne += 2) re.geometry.push(ia(O[ne], O[ne + 1], L, B, $, W));
                        else for (let ne = 0; ne < O.length; ne++) {
                            const ce = [];
                            for (let fe = 0; fe < O[ne].length; fe += 2) ce.push(ia(O[ne][fe], O[ne][fe + 1], L, B, $, W));
                            re.geometry.push(ce);
                        }
                    }
                    return oe.transformed = !0, oe;
                }
                function ia(oe, L, B, $, W, re) {
                    return [Math.round(B * (oe * $ - W)), Math.round(B * (L * $ - re))];
                }
                function Sr(oe, L, B, $, W) {
                    const re = L === W.maxZoom ? 0 : W.tolerance / ((1 << L) * W.extent), O = { features: [], numPoints: 0, numSimplified: 0, numFeatures: oe.length, source: null, x: B, y: $, z: L, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
                    for (const pe of oe) Ma(O, pe, re, W);
                    return O;
                }
                function Ma(oe, L, B, $) {
                    const W = L.geometry, re = L.type, O = [];
                    if (oe.minX = Math.min(oe.minX, L.minX), oe.minY = Math.min(oe.minY, L.minY), oe.maxX = Math.max(oe.maxX, L.maxX), oe.maxY = Math.max(oe.maxY, L.maxY), re === "Point" || re === "MultiPoint") for (let pe = 0; pe < W.length; pe += 3) O.push(W[pe], W[pe + 1]), oe.numPoints++, oe.numSimplified++;
                    else if (re === "LineString") Ia(O, W, oe, B, !1, !1);
                    else if (re === "MultiLineString" || re === "Polygon") for (let pe = 0; pe < W.length; pe++) Ia(O, W[pe], oe, B, re === "Polygon", pe === 0);
                    else if (re === "MultiPolygon") for (let pe = 0; pe < W.length; pe++) {
                        const ne = W[pe];
                        for (let ce = 0; ce < ne.length; ce++) Ia(O, ne[ce], oe, B, !0, ce === 0);
                    }
                    if (O.length) {
                        let pe = L.tags || null;
                        if (re === "LineString" && $.lineMetrics) {
                            pe = {};
                            for (const ce in L.tags) pe[ce] = L.tags[ce];
                            pe.mapbox_clip_start = W.start / W.size, pe.mapbox_clip_end = W.end / W.size;
                        }
                        const ne = { geometry: O, type: re === "Polygon" || re === "MultiPolygon" ? 3 : re === "LineString" || re === "MultiLineString" ? 2 : 1, tags: pe };
                        L.id !== null && (ne.id = L.id), oe.features.push(ne);
                    }
                }
                function Ia(oe, L, B, $, W, re) {
                    const O = $ * $;
                    if ($ > 0 && L.size < (W ? O : $)) return void (B.numPoints += L.length / 3);
                    const pe = [];
                    for (let ne = 0; ne < L.length; ne += 3) ($ === 0 || L[ne + 2] > O) && (B.numSimplified++, pe.push(L[ne], L[ne + 1])), B.numPoints++;
                    W && function (ne, ce) {
                        let fe = 0;
                        for (let le = 0, Pe = ne.length, Re = Pe - 2; le < Pe; Re = le, le += 2) fe += (ne[le] - ne[Re]) * (ne[le + 1] + ne[Re + 1]);
                        if (fe > 0 === ce) for (let le = 0, Pe = ne.length; le < Pe / 2; le += 2) {
                            const Re = ne[le], De = ne[le + 1];
                            ne[le] = ne[Pe - 2 - le], ne[le + 1] = ne[Pe - 1 - le], ne[Pe - 2 - le] = Re, ne[Pe - 1 - le] = De;
                        }
                    }(pe, re), oe.push(pe);
                }
                const Ca = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
                class Tr {
                    constructor(L, B) {
                        const $ = (B = this.options = function (re, O) {
                            for (const pe in O) re[pe] = O[pe];
                            return re;
                        }(Object.create(Ca), B)).debug;
                        if ($ && console.time("preprocess data"), B.maxZoom < 0 || B.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
                        if (B.promoteId && B.generateId) throw new Error("promoteId and generateId cannot be used together.");
                        let W = function (re, O) {
                            const pe = [];
                            if (re.type === "FeatureCollection") for (let ne = 0; ne < re.features.length; ne++) Nr(pe, re.features[ne], O, ne);
                            else Nr(pe, re.type === "Feature" ? re : { geometry: re }, O);
                            return pe;
                        }(L, B);
                        this.tiles = {}, this.tileCoords = [], $ && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", B.indexMaxZoom, B.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), W = function (re, O) {
                            const pe = O.buffer / O.extent;
                            let ne = re;
                            const ce = Bi(re, 1, -1 - pe, pe, 0, -1, 2, O), fe = Bi(re, 1, 1 - pe, 2 + pe, 0, -1, 2, O);
                            return (ce || fe) && (ne = Bi(re, 1, -pe, 1 + pe, 0, -1, 2, O) || [], ce && (ne = Fi(ce, 1).concat(ne)), fe && (ne = ne.concat(Fi(fe, -1)))), ne;
                        }(W, B), W.length && this.splitTile(W, 0, 0, 0), $ && (W.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
                    }
                    splitTile(L, B, $, W, re, O, pe) {
                        const ne = [L, B, $, W], ce = this.options, fe = ce.debug;
                        for (; ne.length;) {
                            W = ne.pop(), $ = ne.pop(), B = ne.pop(), L = ne.pop();
                            const le = 1 << B, Pe = Pr(B, $, W);
                            let Re = this.tiles[Pe];
                            if (!Re && (fe > 1 && console.time("creation"), Re = this.tiles[Pe] = Sr(L, B, $, W, ce), this.tileCoords.push({ z: B, x: $, y: W }), fe)) {
                                fe > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", B, $, W, Re.numFeatures, Re.numPoints, Re.numSimplified), console.timeEnd("creation"));
                                const qe = `z${B}`;
                                this.stats[qe] = (this.stats[qe] || 0) + 1, this.total++;
                            }
                            if (Re.source = L, re == null) {
                                if (B === ce.indexMaxZoom || Re.numPoints <= ce.indexMaxPoints) continue;
                            } else {
                                if (B === ce.maxZoom || B === re) continue;
                                if (re != null) {
                                    const qe = re - B;
                                    if ($ !== O >> qe || W !== pe >> qe) continue;
                                }
                            }
                            if (Re.source = null, L.length === 0) continue;
                            fe > 1 && console.time("clipping");
                            const De = 0.5 * ce.buffer / ce.extent, Ze = 0.5 - De, Ye = 0.5 + De, Xe = 1 + De;
                            let ve = null, gt = null, nt = null, dt = null, We = Bi(L, le, $ - De, $ + Ye, 0, Re.minX, Re.maxX, ce), Se = Bi(L, le, $ + Ze, $ + Xe, 0, Re.minX, Re.maxX, ce);
                            L = null, We && (ve = Bi(We, le, W - De, W + Ye, 1, Re.minY, Re.maxY, ce), gt = Bi(We, le, W + Ze, W + Xe, 1, Re.minY, Re.maxY, ce), We = null), Se && (nt = Bi(Se, le, W - De, W + Ye, 1, Re.minY, Re.maxY, ce), dt = Bi(Se, le, W + Ze, W + Xe, 1, Re.minY, Re.maxY, ce), Se = null), fe > 1 && console.timeEnd("clipping"), ne.push(ve || [], B + 1, 2 * $, 2 * W), ne.push(gt || [], B + 1, 2 * $, 2 * W + 1), ne.push(nt || [], B + 1, 2 * $ + 1, 2 * W), ne.push(dt || [], B + 1, 2 * $ + 1, 2 * W + 1);
                        }
                    }
                    getTile(L, B, $) {
                        L = +L, B = +B, $ = +$;
                        const W = this.options, { extent: re, debug: O } = W;
                        if (L < 0 || L > 24) return null;
                        const pe = 1 << L, ne = Pr(L, B = B + pe & pe - 1, $);
                        if (this.tiles[ne]) return ta(this.tiles[ne], re);
                        O > 1 && console.log("drilling down to z%d-%d-%d", L, B, $);
                        let ce, fe = L, le = B, Pe = $;
                        for (; !ce && fe > 0;) fe--, le >>= 1, Pe >>= 1, ce = this.tiles[Pr(fe, le, Pe)];
                        return ce && ce.source ? (O > 1 && (console.log("found parent tile z%d-%d-%d", fe, le, Pe), console.time("drilling down")), this.splitTile(ce.source, fe, le, Pe, L, B, $), O > 1 && console.timeEnd("drilling down"), this.tiles[ne] ? ta(this.tiles[ne], re) : null) : null;
                    }
                }
                function Pr(oe, L, B) {
                    return 32 * ((1 << oe) * B + L) + oe;
                }
                function jr(oe, L) {
                    return L ? oe.properties[L] : oe.id;
                }
                function Aa(oe, L) {
                    if (oe == null) return !0;
                    if (oe.type === "Feature") return jr(oe, L) != null;
                    if (oe.type === "FeatureCollection") {
                        const B = /* @__PURE__ */ new Set();
                        for (const $ of oe.features) {
                            const W = jr($, L);
                            if (W == null || B.has(W)) return !1;
                            B.add(W);
                        }
                        return !0;
                    }
                    return !1;
                }
                function qi(oe, L) {
                    const B = /* @__PURE__ */ new Map();
                    if (oe != null) if (oe.type === "Feature") B.set(jr(oe, L), oe);
                    else for (const $ of oe.features) B.set(jr($, L), $);
                    return B;
                }
                class Ai extends ct {
                    constructor() {
                        super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
                    }
                    loadVectorTile(L, B) {
                        return M._(this, void 0, void 0, function* () {
                            const $ = L.tileID.canonical;
                            if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
                            const W = this._geoJSONIndex.getTile($.z, $.x, $.y);
                            if (!W) return null;
                            const re = new ln(W.features);
                            let O = cs(re);
                            return O.byteOffset === 0 && O.byteLength === O.buffer.byteLength || (O = new Uint8Array(O)), { vectorTile: re, rawData: O.buffer };
                        });
                    }
                    loadData(L) {
                        return M._(this, void 0, void 0, function* () {
                            var B;
                            (B = this._pendingRequest) === null || B === void 0 || B.abort();
                            const $ = !!(L && L.request && L.request.collectResourceTiming) && new M.cE(L.request);
                            this._pendingRequest = new AbortController();
                            try {
                                this._pendingData = this.loadAndProcessGeoJSON(L, this._pendingRequest), this._geoJSONIndex = L.cluster ? new Sa(function ({ superclusterOptions: O, clusterProperties: pe }) {
                                    if (!pe || !O) return O;
                                    const ne = {}, ce = {}, fe = { accumulated: null, zoom: 0 }, le = { properties: null }, Pe = Object.keys(pe);
                                    for (const Re of Pe) {
                                        const [De, Ze] = pe[Re], Ye = M.cL(Ze), Xe = M.cL(typeof De == "string" ? [De, ["accumulated"], ["get", Re]] : De);
                                        ne[Re] = Ye.value, ce[Re] = Xe.value;
                                    }
                                    return O.map = (Re) => {
                                        le.properties = Re;
                                        const De = {};
                                        for (const Ze of Pe) De[Ze] = ne[Ze].evaluate(fe, le);
                                        return De;
                                    }, O.reduce = (Re, De) => {
                                        le.properties = De;
                                        for (const Ze of Pe) fe.accumulated = Re[Ze], Re[Ze] = ce[Ze].evaluate(fe, le);
                                    }, O;
                                }(L)).load((yield this._pendingData).features) : (W = yield this._pendingData, new Tr(W, L.geojsonVtOptions)), this.loaded = {};
                                const re = {};
                                if ($) {
                                    const O = $.finish();
                                    O && (re.resourceTiming = {}, re.resourceTiming[L.source] = JSON.parse(JSON.stringify(O)));
                                }
                                return re;
                            } catch (re) {
                                if (delete this._pendingRequest, M.cp(re)) return { abandoned: !0 };
                                throw re;
                            }
                            var W;
                        });
                    }
                    getData() {
                        return M._(this, void 0, void 0, function* () {
                            return this._pendingData;
                        });
                    }
                    reloadTile(L) {
                        const B = this.loaded;
                        return B && B[L.uid] ? super.reloadTile(L) : this.loadTile(L);
                    }
                    loadAndProcessGeoJSON(L, B) {
                        return M._(this, void 0, void 0, function* () {
                            let $ = yield this.loadGeoJSON(L, B);
                            if (delete this._pendingRequest, typeof $ != "object") throw new Error(`Input data given to '${L.source}' is not a valid GeoJSON object.`);
                            if (cr($, !0), L.filter) {
                                const W = M.cL(L.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                                if (W.result === "error") throw new Error(W.value.map((O) => `${O.key}: ${O.message}`).join(", "));
                                $ = { type: "FeatureCollection", features: $.features.filter((O) => W.value.evaluate({ zoom: 0 }, O)) };
                            }
                            return $;
                        });
                    }
                    loadGeoJSON(L, B) {
                        return M._(this, void 0, void 0, function* () {
                            const { promoteId: $ } = L;
                            if (L.request) {
                                const W = yield M.j(L.request, B);
                                return this._dataUpdateable = Aa(W.data, $) ? qi(W.data, $) : void 0, W.data;
                            }
                            if (typeof L.data == "string") try {
                                const W = JSON.parse(L.data);
                                return this._dataUpdateable = Aa(W, $) ? qi(W, $) : void 0, W;
                            } catch {
                                throw new Error(`Input data given to '${L.source}' is not a valid GeoJSON object.`);
                            }
                            if (!L.dataDiff) throw new Error(`Input data given to '${L.source}' is not a valid GeoJSON object.`);
                            if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${L.source}`);
                            return function (W, re, O) {
                                var pe, ne, ce, fe;
                                if (re.removeAll && W.clear(), re.remove) for (const le of re.remove) W.delete(le);
                                if (re.add) for (const le of re.add) {
                                    const Pe = jr(le, O);
                                    Pe != null && W.set(Pe, le);
                                }
                                if (re.update) for (const le of re.update) {
                                    let Pe = W.get(le.id);
                                    if (Pe == null) continue;
                                    const Re = !le.removeAllProperties && (((pe = le.removeProperties) === null || pe === void 0 ? void 0 : pe.length) > 0 || ((ne = le.addOrUpdateProperties) === null || ne === void 0 ? void 0 : ne.length) > 0);
                                    if ((le.newGeometry || le.removeAllProperties || Re) && (Pe = Object.assign({}, Pe), W.set(le.id, Pe), Re && (Pe.properties = Object.assign({}, Pe.properties))), le.newGeometry && (Pe.geometry = le.newGeometry), le.removeAllProperties) Pe.properties = {};
                                    else if (((ce = le.removeProperties) === null || ce === void 0 ? void 0 : ce.length) > 0) for (const De of le.removeProperties) Object.prototype.hasOwnProperty.call(Pe.properties, De) && delete Pe.properties[De];
                                    if (((fe = le.addOrUpdateProperties) === null || fe === void 0 ? void 0 : fe.length) > 0) for (const { key: De, value: Ze } of le.addOrUpdateProperties) Pe.properties[De] = Ze;
                                }
                            }(this._dataUpdateable, L.dataDiff, $), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
                        });
                    }
                    removeSource(L) {
                        return M._(this, void 0, void 0, function* () {
                            this._pendingRequest && this._pendingRequest.abort();
                        });
                    }
                    getClusterExpansionZoom(L) {
                        return this._geoJSONIndex.getClusterExpansionZoom(L.clusterId);
                    }
                    getClusterChildren(L) {
                        return this._geoJSONIndex.getChildren(L.clusterId);
                    }
                    getClusterLeaves(L) {
                        return this._geoJSONIndex.getLeaves(L.clusterId, L.limit, L.offset);
                    }
                }
                class mr {
                    constructor(L) {
                        this.self = L, this.actor = new M.H(L), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (B, $) => {
                            if (this.externalWorkerSourceTypes[B]) throw new Error(`Worker source with name "${B}" already registered.`);
                            this.externalWorkerSourceTypes[B] = $;
                        }, this.self.addProtocol = M.cr, this.self.removeProtocol = M.cs, this.self.registerRTLTextPlugin = (B) => {
                            M.cM.setMethods(B);
                        }, this.actor.registerMessageHandler("LDT", (B, $) => this._getDEMWorkerSource(B, $.source).loadTile($)), this.actor.registerMessageHandler("RDT", (B, $) => M._(this, void 0, void 0, function* () {
                            this._getDEMWorkerSource(B, $.source).removeTile($);
                        })), this.actor.registerMessageHandler("GCEZ", (B, $) => M._(this, void 0, void 0, function* () {
                            return this._getWorkerSource(B, $.type, $.source).getClusterExpansionZoom($);
                        })), this.actor.registerMessageHandler("GCC", (B, $) => M._(this, void 0, void 0, function* () {
                            return this._getWorkerSource(B, $.type, $.source).getClusterChildren($);
                        })), this.actor.registerMessageHandler("GCL", (B, $) => M._(this, void 0, void 0, function* () {
                            return this._getWorkerSource(B, $.type, $.source).getClusterLeaves($);
                        })), this.actor.registerMessageHandler("LD", (B, $) => this._getWorkerSource(B, $.type, $.source).loadData($)), this.actor.registerMessageHandler("GD", (B, $) => this._getWorkerSource(B, $.type, $.source).getData()), this.actor.registerMessageHandler("LT", (B, $) => this._getWorkerSource(B, $.type, $.source).loadTile($)), this.actor.registerMessageHandler("RT", (B, $) => this._getWorkerSource(B, $.type, $.source).reloadTile($)), this.actor.registerMessageHandler("AT", (B, $) => this._getWorkerSource(B, $.type, $.source).abortTile($)), this.actor.registerMessageHandler("RMT", (B, $) => this._getWorkerSource(B, $.type, $.source).removeTile($)), this.actor.registerMessageHandler("RS", (B, $) => M._(this, void 0, void 0, function* () {
                            if (!this.workerSources[B] || !this.workerSources[B][$.type] || !this.workerSources[B][$.type][$.source]) return;
                            const W = this.workerSources[B][$.type][$.source];
                            delete this.workerSources[B][$.type][$.source], W.removeSource !== void 0 && W.removeSource($);
                        })), this.actor.registerMessageHandler("RM", (B) => M._(this, void 0, void 0, function* () {
                            delete this.layerIndexes[B], delete this.availableImages[B], delete this.workerSources[B], delete this.demWorkerSources[B];
                        })), this.actor.registerMessageHandler("SR", (B, $) => M._(this, void 0, void 0, function* () {
                            this.referrer = $;
                        })), this.actor.registerMessageHandler("SRPS", (B, $) => this._syncRTLPluginState(B, $)), this.actor.registerMessageHandler("IS", (B, $) => M._(this, void 0, void 0, function* () {
                            this.self.importScripts($);
                        })), this.actor.registerMessageHandler("SI", (B, $) => this._setImages(B, $)), this.actor.registerMessageHandler("UL", (B, $) => M._(this, void 0, void 0, function* () {
                            this._getLayerIndex(B).update($.layers, $.removedIds);
                        })), this.actor.registerMessageHandler("SL", (B, $) => M._(this, void 0, void 0, function* () {
                            this._getLayerIndex(B).replace($);
                        }));
                    }
                    _setImages(L, B) {
                        return M._(this, void 0, void 0, function* () {
                            this.availableImages[L] = B;
                            for (const $ in this.workerSources[L]) {
                                const W = this.workerSources[L][$];
                                for (const re in W) W[re].availableImages = B;
                            }
                        });
                    }
                    _syncRTLPluginState(L, B) {
                        return M._(this, void 0, void 0, function* () {
                            return yield M.cM.syncState(B, this.self.importScripts);
                        });
                    }
                    _getAvailableImages(L) {
                        let B = this.availableImages[L];
                        return B || (B = []), B;
                    }
                    _getLayerIndex(L) {
                        let B = this.layerIndexes[L];
                        return B || (B = this.layerIndexes[L] = new c()), B;
                    }
                    _getWorkerSource(L, B, $) {
                        if (this.workerSources[L] || (this.workerSources[L] = {}), this.workerSources[L][B] || (this.workerSources[L][B] = {}), !this.workerSources[L][B][$]) {
                            const W = { sendAsync: (re, O) => (re.targetMapId = L, this.actor.sendAsync(re, O)) };
                            switch (B) {
                                case "vector":
                                    this.workerSources[L][B][$] = new ct(W, this._getLayerIndex(L), this._getAvailableImages(L));
                                    break;
                                case "geojson":
                                    this.workerSources[L][B][$] = new Ai(W, this._getLayerIndex(L), this._getAvailableImages(L));
                                    break;
                                default:
                                    this.workerSources[L][B][$] = new this.externalWorkerSourceTypes[B](W, this._getLayerIndex(L), this._getAvailableImages(L));
                            }
                        }
                        return this.workerSources[L][B][$];
                    }
                    _getDEMWorkerSource(L, B) {
                        return this.demWorkerSources[L] || (this.demWorkerSources[L] = {}), this.demWorkerSources[L][B] || (this.demWorkerSources[L][B] = new Ue()), this.demWorkerSources[L][B];
                    }
                }
                return M.i(self) && (self.worker = new mr(self)), mr;
            }), se("index", ["exports", "./shared"], function (M, c) {
                var Fe = "5.5.0";
                function ht() {
                    var h = new c.A(4);
                    return c.A != Float32Array && (h[1] = 0, h[2] = 0), h[0] = 1, h[3] = 1, h;
                }
                let _t, ct;
                const Ue = {
                    now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(h, e, i) {
                        const s = requestAnimationFrame((u) => {
                            o(), e(u);
                        }), { unsubscribe: o } = c.s(h.signal, "abort", () => {
                            o(), cancelAnimationFrame(s), i(c.c());
                        }, !1);
                    }, frameAsync(h) {
                        return new Promise((e, i) => {
                            this.frame(h, e, i);
                        });
                    }, getImageData(h, e = 0) {
                        return this.getImageCanvasContext(h).getImageData(-e, -e, h.width + 2 * e, h.height + 2 * e);
                    }, getImageCanvasContext(h) {
                        const e = window.document.createElement("canvas"), i = e.getContext("2d", { willReadFrequently: !0 });
                        if (!i) throw new Error("failed to create canvas 2d context");
                        return e.width = h.width, e.height = h.height, i.drawImage(h, 0, 0, h.width, h.height), i;
                    }, resolveURL: (h) => (_t || (_t = document.createElement("a")), _t.href = h, _t.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
                        return !!matchMedia && (ct == null && (ct = matchMedia("(prefers-reduced-motion: reduce)")), ct.matches);
                    }
                };
                class de {
                    static testProp(e) {
                        if (!de.docStyle) return e[0];
                        for (let i = 0; i < e.length; i++) if (e[i] in de.docStyle) return e[i];
                        return e[0];
                    }
                    static create(e, i, s) {
                        const o = window.document.createElement(e);
                        return i !== void 0 && (o.className = i), s && s.appendChild(o), o;
                    }
                    static createNS(e, i) {
                        return window.document.createElementNS(e, i);
                    }
                    static disableDrag() {
                        de.docStyle && de.selectProp && (de.userSelect = de.docStyle[de.selectProp], de.docStyle[de.selectProp] = "none");
                    }
                    static enableDrag() {
                        de.docStyle && de.selectProp && (de.docStyle[de.selectProp] = de.userSelect);
                    }
                    static setTransform(e, i) {
                        e.style[de.transformProp] = i;
                    }
                    static addEventListener(e, i, s, o = {}) {
                        e.addEventListener(i, s, "passive" in o ? o : o.capture);
                    }
                    static removeEventListener(e, i, s, o = {}) {
                        e.removeEventListener(i, s, "passive" in o ? o : o.capture);
                    }
                    static suppressClickInternal(e) {
                        e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", de.suppressClickInternal, !0);
                    }
                    static suppressClick() {
                        window.addEventListener("click", de.suppressClickInternal, !0), window.setTimeout(() => {
                            window.removeEventListener("click", de.suppressClickInternal, !0);
                        }, 0);
                    }
                    static getScale(e) {
                        const i = e.getBoundingClientRect();
                        return { x: i.width / e.offsetWidth || 1, y: i.height / e.offsetHeight || 1, boundingClientRect: i };
                    }
                    static getPoint(e, i, s) {
                        const o = i.boundingClientRect;
                        return new c.P((s.clientX - o.left) / i.x - e.clientLeft, (s.clientY - o.top) / i.y - e.clientTop);
                    }
                    static mousePos(e, i) {
                        const s = de.getScale(e);
                        return de.getPoint(e, s, i);
                    }
                    static touchPos(e, i) {
                        const s = [], o = de.getScale(e);
                        for (let u = 0; u < i.length; u++) s.push(de.getPoint(e, o, i[u]));
                        return s;
                    }
                    static mouseButton(e) {
                        return e.button;
                    }
                    static remove(e) {
                        e.parentNode && e.parentNode.removeChild(e);
                    }
                    static sanitize(e) {
                        const i = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"), s = i.querySelectorAll("script");
                        for (const o of s) o.remove();
                        return de.clean(i), i.innerHTML;
                    }
                    static isPossiblyDangerous(e, i) {
                        const s = i.replace(/\s+/g, "").toLowerCase();
                        return !(!["src", "href", "xlink:href"].includes(e) || !s.includes("javascript:") && !s.includes("data:")) || !!e.startsWith("on") || void 0;
                    }
                    static clean(e) {
                        const i = e.children;
                        for (const s of i) de.removeAttributes(s), de.clean(s);
                    }
                    static removeAttributes(e) {
                        for (const { name: i, value: s } of e.attributes) de.isPossiblyDangerous(i, s) && e.removeAttribute(i);
                    }
                }
                de.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, de.selectProp = de.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), de.transformProp = de.testProp(["transform", "WebkitTransform"]);
                const $e = {
                    supported: !1, testSupport: function (h) {
                        !wr && cr && (Qr ? ln(h) : lr = h);
                    }
                };
                let lr, cr, wr = !1, Qr = !1;
                function ln(h) {
                    const e = h.createTexture();
                    h.bindTexture(h.TEXTURE_2D, e);
                    try {
                        if (h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, cr), h.isContextLost()) return;
                        $e.supported = !0;
                    } catch {
                    }
                    h.deleteTexture(e), wr = !0;
                }
                var bi;
                typeof document < "u" && (cr = document.createElement("img"), cr.onload = () => {
                    lr && ln(lr), lr = null, Qr = !0;
                }, cr.onerror = () => {
                    wr = !0, lr = null;
                }, cr.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function (h) {
                    let e, i, s, o;
                    h.resetRequestQueue = () => {
                        e = [], i = 0, s = 0, o = {};
                    }, h.addThrottleControl = (y) => {
                        const x = s++;
                        return o[x] = y, x;
                    }, h.removeThrottleControl = (y) => {
                        delete o[y], f();
                    }, h.getImage = (y, x, w = !0) => new Promise((P, T) => {
                        $e.supported && (y.headers || (y.headers = {}), y.headers.accept = "image/webp,*/*"), c.e(y, { type: "image" }), e.push({
                            abortController: x, requestParameters: y, supportImageRefresh: w, state: "queued", onError: (z) => {
                                T(z);
                            }, onSuccess: (z) => {
                                P(z);
                            }
                        }), f();
                    });
                    const u = (y) => c._(this, void 0, void 0, function* () {
                        y.state = "running";
                        const { requestParameters: x, supportImageRefresh: w, onError: P, onSuccess: T, abortController: z } = y, R = w === !1 && !c.i(self) && !c.g(x.url) && (!x.headers || Object.keys(x.headers).reduce((Z, q) => Z && q === "accept", !0));
                        i++;
                        const V = R ? g(x, z) : c.m(x, z);
                        try {
                            const Z = yield V;
                            delete y.abortController, y.state = "completed", Z.data instanceof HTMLImageElement || c.b(Z.data) ? T(Z) : Z.data && T({ data: yield (U = Z.data, typeof createImageBitmap == "function" ? c.f(U) : c.h(U)), cacheControl: Z.cacheControl, expires: Z.expires });
                        } catch (Z) {
                            delete y.abortController, P(Z);
                        } finally {
                            i--, f();
                        }
                        var U;
                    }), f = () => {
                        const y = (() => {
                            for (const x of Object.keys(o)) if (o[x]()) return !0;
                            return !1;
                        })() ? c.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : c.a.MAX_PARALLEL_IMAGE_REQUESTS;
                        for (let x = i; x < y && e.length > 0; x++) {
                            const w = e.shift();
                            w.abortController.signal.aborted ? x-- : u(w);
                        }
                    }, g = (y, x) => new Promise((w, P) => {
                        const T = new Image(), z = y.url, R = y.credentials;
                        R && R === "include" ? T.crossOrigin = "use-credentials" : (R && R === "same-origin" || !c.d(z)) && (T.crossOrigin = "anonymous"), x.signal.addEventListener("abort", () => {
                            T.src = "", P(c.c());
                        }), T.fetchPriority = "high", T.onload = () => {
                            T.onerror = T.onload = null, w({ data: T });
                        }, T.onerror = () => {
                            T.onerror = T.onload = null, x.signal.aborted || P(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                        }, T.src = z;
                    });
                }(bi || (bi = {})), bi.resetRequestQueue();
                class Zt {
                    constructor(e) {
                        this._transformRequestFn = e;
                    }
                    transformRequest(e, i) {
                        return this._transformRequestFn && this._transformRequestFn(e, i) || { url: e };
                    }
                    setTransformRequest(e) {
                        this._transformRequestFn = e;
                    }
                }
                function Rt(h) {
                    const e = [];
                    if (typeof h == "string") e.push({ id: "default", url: h });
                    else if (h && h.length > 0) {
                        const i = [];
                        for (const { id: s, url: o } of h) {
                            const u = `${s}${o}`;
                            i.indexOf(u) === -1 && (i.push(u), e.push({ id: s, url: o }));
                        }
                    }
                    return e;
                }
                function hr(h, e, i) {
                    try {
                        const s = new URL(h);
                        return s.pathname += `${e}${i}`, s.toString();
                    } catch {
                        throw new Error(`Invalid sprite URL "${h}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
                    }
                }
                class Dt {
                    constructor(e, i, s, o) {
                        this.context = e, this.format = s, this.texture = e.gl.createTexture(), this.update(i, o);
                    }
                    update(e, i, s) {
                        const { width: o, height: u } = e, f = !(this.size && this.size[0] === o && this.size[1] === u || s), { context: g } = this, { gl: y } = g;
                        if (this.useMipmap = !!(i && i.useMipmap), y.bindTexture(y.TEXTURE_2D, this.texture), g.pixelStoreUnpackFlipY.set(!1), g.pixelStoreUnpack.set(1), g.pixelStoreUnpackPremultiplyAlpha.set(this.format === y.RGBA && (!i || i.premultiply !== !1)), f) this.size = [o, u], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || c.b(e) ? y.texImage2D(y.TEXTURE_2D, 0, this.format, this.format, y.UNSIGNED_BYTE, e) : y.texImage2D(y.TEXTURE_2D, 0, this.format, o, u, 0, this.format, y.UNSIGNED_BYTE, e.data);
                        else {
                            const { x, y: w } = s || { x: 0, y: 0 };
                            e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || c.b(e) ? y.texSubImage2D(y.TEXTURE_2D, 0, x, w, y.RGBA, y.UNSIGNED_BYTE, e) : y.texSubImage2D(y.TEXTURE_2D, 0, x, w, o, u, y.RGBA, y.UNSIGNED_BYTE, e.data);
                        }
                        this.useMipmap && this.isSizePowerOfTwo() && y.generateMipmap(y.TEXTURE_2D), g.pixelStoreUnpackFlipY.setDefault(), g.pixelStoreUnpack.setDefault(), g.pixelStoreUnpackPremultiplyAlpha.setDefault();
                    }
                    bind(e, i, s) {
                        const { context: o } = this, { gl: u } = o;
                        u.bindTexture(u.TEXTURE_2D, this.texture), s !== u.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (s = u.LINEAR), e !== this.filter && (u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, e), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, s || e), this.filter = e), i !== this.wrap && (u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, i), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, i), this.wrap = i);
                    }
                    isSizePowerOfTwo() {
                        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
                    }
                    destroy() {
                        const { gl: e } = this.context;
                        e.deleteTexture(this.texture), this.texture = null;
                    }
                }
                function cs(h) {
                    const { userImage: e } = h;
                    return !!(e && e.render && e.render()) && (h.data.replace(new Uint8Array(e.data.buffer)), !0);
                }
                class hs extends c.E {
                    constructor() {
                        super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new c.R({ width: 1, height: 1 }), this.dirty = !0;
                    }
                    isLoaded() {
                        return this.loaded;
                    }
                    setLoaded(e) {
                        if (this.loaded !== e && (this.loaded = e, e)) {
                            for (const { ids: i, promiseResolve: s } of this.requestors) s(this._getImagesForIds(i));
                            this.requestors = [];
                        }
                    }
                    getImage(e) {
                        const i = this.images[e];
                        if (i && !i.data && i.spriteData) {
                            const s = i.spriteData;
                            i.data = new c.R({ width: s.width, height: s.height }, s.context.getImageData(s.x, s.y, s.width, s.height).data), i.spriteData = null;
                        }
                        return i;
                    }
                    addImage(e, i) {
                        if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
                        this._validate(e, i) && (this.images[e] = i);
                    }
                    _validate(e, i) {
                        let s = !0;
                        const o = i.data || i.spriteData;
                        return this._validateStretch(i.stretchX, o && o.width) || (this.fire(new c.k(new Error(`Image "${e}" has invalid "stretchX" value`))), s = !1), this._validateStretch(i.stretchY, o && o.height) || (this.fire(new c.k(new Error(`Image "${e}" has invalid "stretchY" value`))), s = !1), this._validateContent(i.content, i) || (this.fire(new c.k(new Error(`Image "${e}" has invalid "content" value`))), s = !1), s;
                    }
                    _validateStretch(e, i) {
                        if (!e) return !0;
                        let s = 0;
                        for (const o of e) {
                            if (o[0] < s || o[1] < o[0] || i < o[1]) return !1;
                            s = o[1];
                        }
                        return !0;
                    }
                    _validateContent(e, i) {
                        if (!e) return !0;
                        if (e.length !== 4) return !1;
                        const s = i.spriteData, o = s && s.width || i.data.width, u = s && s.height || i.data.height;
                        return !(e[0] < 0 || o < e[0] || e[1] < 0 || u < e[1] || e[2] < 0 || o < e[2] || e[3] < 0 || u < e[3] || e[2] < e[0] || e[3] < e[1]);
                    }
                    updateImage(e, i, s = !0) {
                        const o = this.getImage(e);
                        if (s && (o.data.width !== i.data.width || o.data.height !== i.data.height)) throw new Error(`size mismatch between old image (${o.data.width}x${o.data.height}) and new image (${i.data.width}x${i.data.height}).`);
                        i.version = o.version + 1, this.images[e] = i, this.updatedImages[e] = !0;
                    }
                    removeImage(e) {
                        const i = this.images[e];
                        delete this.images[e], delete this.patterns[e], i.userImage && i.userImage.onRemove && i.userImage.onRemove();
                    }
                    listImages() {
                        return Object.keys(this.images);
                    }
                    getImages(e) {
                        return new Promise((i, s) => {
                            let o = !0;
                            if (!this.isLoaded()) for (const u of e) this.images[u] || (o = !1);
                            this.isLoaded() || o ? i(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: i });
                        });
                    }
                    _getImagesForIds(e) {
                        const i = {};
                        for (const s of e) {
                            let o = this.getImage(s);
                            o || (this.fire(new c.l("styleimagemissing", { id: s })), o = this.getImage(s)), o ? i[s] = { data: o.data.clone(), pixelRatio: o.pixelRatio, sdf: o.sdf, version: o.version, stretchX: o.stretchX, stretchY: o.stretchY, content: o.content, textFitWidth: o.textFitWidth, textFitHeight: o.textFitHeight, hasRenderCallback: !!(o.userImage && o.userImage.render) } : c.w(`Image "${s}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                        }
                        return i;
                    }
                    getPixelSize() {
                        const { width: e, height: i } = this.atlasImage;
                        return { width: e, height: i };
                    }
                    getPattern(e) {
                        const i = this.patterns[e], s = this.getImage(e);
                        if (!s) return null;
                        if (i && i.position.version === s.version) return i.position;
                        if (i) i.position.version = s.version;
                        else {
                            const o = { w: s.data.width + 2, h: s.data.height + 2, x: 0, y: 0 }, u = new c.I(o, s);
                            this.patterns[e] = { bin: o, position: u };
                        }
                        return this._updatePatternAtlas(), this.patterns[e].position;
                    }
                    bind(e) {
                        const i = e.gl;
                        this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new Dt(e, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
                    }
                    _updatePatternAtlas() {
                        const e = [];
                        for (const u in this.patterns) e.push(this.patterns[u].bin);
                        const { w: i, h: s } = c.p(e), o = this.atlasImage;
                        o.resize({ width: i || 1, height: s || 1 });
                        for (const u in this.patterns) {
                            const { bin: f } = this.patterns[u], g = f.x + 1, y = f.y + 1, x = this.getImage(u).data, w = x.width, P = x.height;
                            c.R.copy(x, o, { x: 0, y: 0 }, { x: g, y }, { width: w, height: P }), c.R.copy(x, o, { x: 0, y: P - 1 }, { x: g, y: y - 1 }, { width: w, height: 1 }), c.R.copy(x, o, { x: 0, y: 0 }, { x: g, y: y + P }, { width: w, height: 1 }), c.R.copy(x, o, { x: w - 1, y: 0 }, { x: g - 1, y }, { width: 1, height: P }), c.R.copy(x, o, { x: 0, y: 0 }, { x: g + w, y }, { width: 1, height: P });
                        }
                        this.dirty = !0;
                    }
                    beginFrame() {
                        this.callbackDispatchedThisFrame = {};
                    }
                    dispatchRenderCallbacks(e) {
                        for (const i of e) {
                            if (this.callbackDispatchedThisFrame[i]) continue;
                            this.callbackDispatchedThisFrame[i] = !0;
                            const s = this.getImage(i);
                            s || c.w(`Image with ID: "${i}" was not found`), cs(s) && this.updateImage(i, s);
                        }
                    }
                }
                const Br = 1e20;
                function ur(h, e, i, s, o, u, f, g, y) {
                    for (let x = e; x < e + s; x++) Ji(h, i * u + x, u, o, f, g, y);
                    for (let x = i; x < i + o; x++) Ji(h, x * u + e, 1, s, f, g, y);
                }
                function Ji(h, e, i, s, o, u, f) {
                    u[0] = 0, f[0] = -1e20, f[1] = Br, o[0] = h[e];
                    for (let g = 1, y = 0, x = 0; g < s; g++) {
                        o[g] = h[e + g * i];
                        const w = g * g;
                        do {
                            const P = u[y];
                            x = (o[g] - o[P] + w - P * P) / (g - P) / 2;
                        } while (x <= f[y] && --y > -1);
                        y++, u[y] = g, f[y] = x, f[y + 1] = Br;
                    }
                    for (let g = 0, y = 0; g < s; g++) {
                        for (; f[y + 1] < g;) y++;
                        const x = u[y], w = g - x;
                        h[e + g * i] = o[x] + w * w;
                    }
                }
                class mi {
                    constructor(e, i) {
                        this.requestManager = e, this.localIdeographFontFamily = i, this.entries = {};
                    }
                    setURL(e) {
                        this.url = e;
                    }
                    getGlyphs(e) {
                        return c._(this, void 0, void 0, function* () {
                            const i = [];
                            for (const u in e) for (const f of e[u]) i.push(this._getAndCacheGlyphsPromise(u, f));
                            const s = yield Promise.all(i), o = {};
                            for (const { stack: u, id: f, glyph: g } of s) o[u] || (o[u] = {}), o[u][f] = g && { id: g.id, bitmap: g.bitmap.clone(), metrics: g.metrics };
                            return o;
                        });
                    }
                    _getAndCacheGlyphsPromise(e, i) {
                        return c._(this, void 0, void 0, function* () {
                            let s = this.entries[e];
                            s || (s = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
                            let o = s.glyphs[i];
                            if (o !== void 0) return { stack: e, id: i, glyph: o };
                            if (o = this._tinySDF(s, e, i), o) return s.glyphs[i] = o, { stack: e, id: i, glyph: o };
                            const u = Math.floor(i / 256);
                            if (256 * u > 65535) throw new Error("glyphs > 65535 not supported");
                            if (s.ranges[u]) return { stack: e, id: i, glyph: o };
                            if (!this.url) throw new Error("glyphsUrl is not set");
                            if (!s.requests[u]) {
                                const g = mi.loadGlyphRange(e, u, this.url, this.requestManager);
                                s.requests[u] = g;
                            }
                            const f = yield s.requests[u];
                            for (const g in f) this._doesCharSupportLocalGlyph(+g) || (s.glyphs[+g] = f[+g]);
                            return s.ranges[u] = !0, { stack: e, id: i, glyph: f[i] || null };
                        });
                    }
                    _doesCharSupportLocalGlyph(e) {
                        return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || c.u["CJK Unified Ideographs"](e) || c.u["Hangul Syllables"](e) || c.u.Hiragana(e) || c.u.Katakana(e) || c.u["CJK Symbols and Punctuation"](e) || c.u["Halfwidth and Fullwidth Forms"](e));
                    }
                    _tinySDF(e, i, s) {
                        const o = this.localIdeographFontFamily;
                        if (!o || !this._doesCharSupportLocalGlyph(s)) return;
                        let u = e.tinySDF;
                        if (!u) {
                            let g = "400";
                            /bold/i.test(i) ? g = "900" : /medium/i.test(i) ? g = "500" : /light/i.test(i) && (g = "200"), u = e.tinySDF = new mi.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: o, fontWeight: g });
                        }
                        const f = u.draw(String.fromCharCode(s));
                        return { id: s, bitmap: new c.q({ width: f.width || 60, height: f.height || 60 }, f.data), metrics: { width: f.glyphWidth / 2 || 24, height: f.glyphHeight / 2 || 24, left: f.glyphLeft / 2 + 0.5 || 0, top: f.glyphTop / 2 - 27.5 || -8, advance: f.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
                    }
                }
                mi.loadGlyphRange = function (h, e, i, s) {
                    return c._(this, void 0, void 0, function* () {
                        const o = 256 * e, u = o + 255, f = s.transformRequest(i.replace("{fontstack}", h).replace("{range}", `${o}-${u}`), "Glyphs"), g = yield c.n(f, new AbortController());
                        if (!g || !g.data) throw new Error(`Could not load glyph range. range: ${e}, ${o}-${u}`);
                        const y = {};
                        for (const x of c.o(g.data)) y[x.id] = x;
                        return y;
                    });
                }, mi.TinySDF = class {
                    constructor({ fontSize: h = 24, buffer: e = 3, radius: i = 8, cutoff: s = 0.25, fontFamily: o = "sans-serif", fontWeight: u = "normal", fontStyle: f = "normal" } = {}) {
                        this.buffer = e, this.cutoff = s, this.radius = i;
                        const g = this.size = h + 4 * e, y = this._createCanvas(g), x = this.ctx = y.getContext("2d", { willReadFrequently: !0 });
                        x.font = `${f} ${u} ${h}px ${o}`, x.textBaseline = "alphabetic", x.textAlign = "left", x.fillStyle = "black", this.gridOuter = new Float64Array(g * g), this.gridInner = new Float64Array(g * g), this.f = new Float64Array(g), this.z = new Float64Array(g + 1), this.v = new Uint16Array(g);
                    }
                    _createCanvas(h) {
                        const e = document.createElement("canvas");
                        return e.width = e.height = h, e;
                    }
                    draw(h) {
                        const { width: e, actualBoundingBoxAscent: i, actualBoundingBoxDescent: s, actualBoundingBoxLeft: o, actualBoundingBoxRight: u } = this.ctx.measureText(h), f = Math.ceil(i), g = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(u - o))), y = Math.min(this.size - this.buffer, f + Math.ceil(s)), x = g + 2 * this.buffer, w = y + 2 * this.buffer, P = Math.max(x * w, 0), T = new Uint8ClampedArray(P), z = { data: T, width: x, height: w, glyphWidth: g, glyphHeight: y, glyphTop: f, glyphLeft: 0, glyphAdvance: e };
                        if (g === 0 || y === 0) return z;
                        const { ctx: R, buffer: V, gridInner: U, gridOuter: Z } = this;
                        R.clearRect(V, V, g, y), R.fillText(h, V, V + f);
                        const q = R.getImageData(V, V, g, y);
                        Z.fill(Br, 0, P), U.fill(0, 0, P);
                        for (let J = 0; J < y; J++) for (let Y = 0; Y < g; Y++) {
                            const ee = q.data[4 * (J * g + Y) + 3] / 255;
                            if (ee === 0) continue;
                            const ae = (J + V) * x + Y + V;
                            if (ee === 1) Z[ae] = 0, U[ae] = Br;
                            else {
                                const te = 0.5 - ee;
                                Z[ae] = te > 0 ? te * te : 0, U[ae] = te < 0 ? te * te : 0;
                            }
                        }
                        ur(Z, 0, 0, x, w, x, this.f, this.v, this.z), ur(U, V, V, g, y, x, this.f, this.v, this.z);
                        for (let J = 0; J < P; J++) {
                            const Y = Math.sqrt(Z[J]) - Math.sqrt(U[J]);
                            T[J] = Math.round(255 - 255 * (Y / this.radius + this.cutoff));
                        }
                        return z;
                    }
                };
                class cn {
                    constructor() {
                        this.specification = c.v.light.position;
                    }
                    possiblyEvaluate(e, i) {
                        return c.z(e.expression.evaluate(i));
                    }
                    interpolate(e, i, s) {
                        return { x: c.B.number(e.x, i.x, s), y: c.B.number(e.y, i.y, s), z: c.B.number(e.z, i.z, s) };
                    }
                }
                let Sa;
                class hn extends c.E {
                    constructor(e) {
                        super(), Sa = Sa || new c.r({ anchor: new c.D(c.v.light.anchor), position: new cn(), color: new c.D(c.v.light.color), intensity: new c.D(c.v.light.intensity) }), this._transitionable = new c.T(Sa), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
                    }
                    getLight() {
                        return this._transitionable.serialize();
                    }
                    setLight(e, i = {}) {
                        if (!this._validate(c.t, e, i)) for (const s in e) {
                            const o = e[s];
                            s.endsWith("-transition") ? this._transitionable.setTransition(s.slice(0, -11), o) : this._transitionable.setValue(s, o);
                        }
                    }
                    updateTransitions(e) {
                        this._transitioning = this._transitionable.transitioned(e, this._transitioning);
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition();
                    }
                    recalculate(e) {
                        this.properties = this._transitioning.possiblyEvaluate(e);
                    }
                    _validate(e, i, s) {
                        return (!s || s.validate !== !1) && c.x(this, e.call(c.y, { value: i, style: { glyphs: !0, sprite: !0 }, styleSpec: c.v }));
                    }
                }
                const yt = new c.r({ "sky-color": new c.D(c.v.sky["sky-color"]), "horizon-color": new c.D(c.v.sky["horizon-color"]), "fog-color": new c.D(c.v.sky["fog-color"]), "fog-ground-blend": new c.D(c.v.sky["fog-ground-blend"]), "horizon-fog-blend": new c.D(c.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new c.D(c.v.sky["sky-horizon-blend"]), "atmosphere-blend": new c.D(c.v.sky["atmosphere-blend"]) });
                class Fr extends c.E {
                    constructor(e) {
                        super(), this._transitionable = new c.T(yt), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new c.C(0));
                    }
                    setSky(e, i = {}) {
                        if (!this._validate(c.F, e, i)) {
                            e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
                            for (const s in e) {
                                const o = e[s];
                                s.endsWith("-transition") ? this._transitionable.setTransition(s.slice(0, -11), o) : this._transitionable.setValue(s, o);
                            }
                        }
                    }
                    getSky() {
                        return this._transitionable.serialize();
                    }
                    updateTransitions(e) {
                        this._transitioning = this._transitionable.transitioned(e, this._transitioning);
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition();
                    }
                    recalculate(e) {
                        this.properties = this._transitioning.possiblyEvaluate(e);
                    }
                    _validate(e, i, s = {}) {
                        return (s == null ? void 0 : s.validate) !== !1 && c.x(this, e.call(c.y, c.e({ value: i, style: { glyphs: !0, sprite: !0 }, styleSpec: c.v })));
                    }
                    calculateFogBlendOpacity(e) {
                        return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
                    }
                }
                class pr {
                    constructor(e, i) {
                        this.width = e, this.height = i, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
                    }
                    getDash(e, i) {
                        const s = e.join(",") + String(i);
                        return this.dashEntry[s] || (this.dashEntry[s] = this.addDash(e, i)), this.dashEntry[s];
                    }
                    getDashRanges(e, i, s) {
                        const o = [];
                        let u = e.length % 2 == 1 ? -e[e.length - 1] * s : 0, f = e[0] * s, g = !0;
                        o.push({ left: u, right: f, isDash: g, zeroLength: e[0] === 0 });
                        let y = e[0];
                        for (let x = 1; x < e.length; x++) {
                            g = !g;
                            const w = e[x];
                            u = y * s, y += w, f = y * s, o.push({ left: u, right: f, isDash: g, zeroLength: w === 0 });
                        }
                        return o;
                    }
                    addRoundDash(e, i, s) {
                        const o = i / 2;
                        for (let u = -s; u <= s; u++) {
                            const f = this.width * (this.nextRow + s + u);
                            let g = 0, y = e[g];
                            for (let x = 0; x < this.width; x++) {
                                x / y.right > 1 && (y = e[++g]);
                                const w = Math.abs(x - y.left), P = Math.abs(x - y.right), T = Math.min(w, P);
                                let z;
                                const R = u / s * (o + 1);
                                if (y.isDash) {
                                    const V = o - Math.abs(R);
                                    z = Math.sqrt(T * T + V * V);
                                } else z = o - Math.sqrt(T * T + R * R);
                                this.data[f + x] = Math.max(0, Math.min(255, z + 128));
                            }
                        }
                    }
                    addRegularDash(e) {
                        for (let g = e.length - 1; g >= 0; --g) {
                            const y = e[g], x = e[g + 1];
                            y.zeroLength ? e.splice(g, 1) : x && x.isDash === y.isDash && (x.left = y.left, e.splice(g, 1));
                        }
                        const i = e[0], s = e[e.length - 1];
                        i.isDash === s.isDash && (i.left = s.left - this.width, s.right = i.right + this.width);
                        const o = this.width * this.nextRow;
                        let u = 0, f = e[u];
                        for (let g = 0; g < this.width; g++) {
                            g / f.right > 1 && (f = e[++u]);
                            const y = Math.abs(g - f.left), x = Math.abs(g - f.right), w = Math.min(y, x);
                            this.data[o + g] = Math.max(0, Math.min(255, (f.isDash ? w : -w) + 128));
                        }
                    }
                    addDash(e, i) {
                        const s = i ? 7 : 0, o = 2 * s + 1;
                        if (this.nextRow + o > this.height) return c.w("LineAtlas out of space"), null;
                        let u = 0;
                        for (let g = 0; g < e.length; g++) u += e[g];
                        if (u !== 0) {
                            const g = this.width / u, y = this.getDashRanges(e, this.width, g);
                            i ? this.addRoundDash(y, g, s) : this.addRegularDash(y);
                        }
                        const f = { y: (this.nextRow + s + 0.5) / this.height, height: 2 * s / this.height, width: u };
                        return this.nextRow += o, this.dirty = !0, f;
                    }
                    bind(e) {
                        const i = e.gl;
                        this.texture ? (i.bindTexture(i.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, this.width, this.height, i.ALPHA, i.UNSIGNED_BYTE, this.data))) : (this.texture = i.createTexture(), i.bindTexture(i.TEXTURE_2D, this.texture), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), i.texImage2D(i.TEXTURE_2D, 0, i.ALPHA, this.width, this.height, 0, i.ALPHA, i.UNSIGNED_BYTE, this.data));
                    }
                }
                const Ta = "maplibre_preloaded_worker_pool";
                class Qi {
                    constructor() {
                        this.active = {};
                    }
                    acquire(e) {
                        if (!this.workers) for (this.workers = []; this.workers.length < Qi.workerCount;) this.workers.push(new Worker(c.a.WORKER_URL));
                        return this.active[e] = !0, this.workers.slice();
                    }
                    release(e) {
                        delete this.active[e], this.numActive() === 0 && (this.workers.forEach((i) => {
                            i.terminate();
                        }), this.workers = null);
                    }
                    isPreloaded() {
                        return !!this.active[Ta];
                    }
                    numActive() {
                        return Object.keys(this.active).length;
                    }
                }
                const us = Math.floor(Ue.hardwareConcurrency / 2);
                let er, li;
                function Nr() {
                    return er || (er = new Qi()), er;
                }
                Qi.workerCount = c.G(globalThis) ? Math.max(Math.min(us, 3), 1) : 1;
                class Di {
                    constructor(e, i) {
                        this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = i;
                        const s = this.workerPool.acquire(i);
                        for (let o = 0; o < s.length; o++) {
                            const u = new c.H(s[o], i);
                            u.name = `Worker ${o}`, this.actors.push(u);
                        }
                        if (!this.actors.length) throw new Error("No actors found");
                    }
                    broadcast(e, i) {
                        const s = [];
                        for (const o of this.actors) s.push(o.sendAsync({ type: e, data: i }));
                        return Promise.all(s);
                    }
                    getActor() {
                        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
                    }
                    remove(e = !0) {
                        this.actors.forEach((i) => {
                            i.remove();
                        }), this.actors = [], e && this.workerPool.release(this.id);
                    }
                    registerMessageHandler(e, i) {
                        for (const s of this.actors) s.registerMessageHandler(e, i);
                    }
                }
                function Pa() {
                    return li || (li = new Di(Nr(), c.J), li.registerMessageHandler("GR", (h, e, i) => c.m(e, i))), li;
                }
                function ea(h, e) {
                    const i = c.K();
                    return c.L(i, i, [1, 1, 0]), c.M(i, i, [0.5 * h.width, 0.5 * h.height, 1]), h.calculatePosMatrix ? c.N(i, i, h.calculatePosMatrix(e.toUnwrapped())) : i;
                }
                function un(h, e, i, s, o, u, f) {
                    var g;
                    const y = function (T, z, R) {
                        if (T) for (const V of T) {
                            const U = z[V];
                            if (U && U.source === R && U.type === "fill-extrusion") return !0;
                        }
                        else for (const V in z) {
                            const U = z[V];
                            if (U.source === R && U.type === "fill-extrusion") return !0;
                        }
                        return !1;
                    }((g = o == null ? void 0 : o.layers) !== null && g !== void 0 ? g : null, e, h.id), x = u.maxPitchScaleFactor(), w = h.tilesIn(s, x, y);
                    w.sort(Li);
                    const P = [];
                    for (const T of w) P.push({ wrappedTileID: T.tileID.wrapped().key, queryResults: T.tile.queryRenderedFeatures(e, i, h._state, T.queryGeometry, T.cameraQueryGeometry, T.scale, o, u, x, ea(h.transform, T.tileID), f ? (z, R) => f(T.tileID, z, R) : void 0) });
                    return function (T, z) {
                        for (const R in T) for (const V of T[R]) Bi(V, z);
                        return T;
                    }(function (T) {
                        const z = {}, R = {};
                        for (const V of T) {
                            const U = V.queryResults, Z = V.wrappedTileID, q = R[Z] = R[Z] || {};
                            for (const J in U) {
                                const Y = U[J], ee = q[J] = q[J] || {}, ae = z[J] = z[J] || [];
                                for (const te of Y) ee[te.featureIndex] || (ee[te.featureIndex] = !0, ae.push(te));
                            }
                        }
                        return z;
                    }(P), h);
                }
                function Li(h, e) {
                    const i = h.tileID, s = e.tileID;
                    return i.overscaledZ - s.overscaledZ || i.canonical.y - s.canonical.y || i.wrap - s.wrap || i.canonical.x - s.canonical.x;
                }
                function Bi(h, e) {
                    const i = h.feature, s = e.getFeatureState(i.layer["source-layer"], i.id);
                    i.source = i.layer.source, i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]), i.state = s;
                }
                function wi(h, e, i) {
                    return c._(this, void 0, void 0, function* () {
                        let s = h;
                        if (h.url ? s = (yield c.j(e.transformRequest(h.url, "Source"), i)).data : yield Ue.frameAsync(i), !s) return null;
                        const o = c.O(c.e(s, h), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
                        return "vector_layers" in s && s.vector_layers && (o.vectorLayerIds = s.vector_layers.map((u) => u.id)), o;
                    });
                }
                class bt {
                    constructor(e, i) {
                        e && (i ? this.setSouthWest(e).setNorthEast(i) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
                    }
                    setNorthEast(e) {
                        return this._ne = e instanceof c.Q ? new c.Q(e.lng, e.lat) : c.Q.convert(e), this;
                    }
                    setSouthWest(e) {
                        return this._sw = e instanceof c.Q ? new c.Q(e.lng, e.lat) : c.Q.convert(e), this;
                    }
                    extend(e) {
                        const i = this._sw, s = this._ne;
                        let o, u;
                        if (e instanceof c.Q) o = e, u = e;
                        else {
                            if (!(e instanceof bt)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(bt.convert(e)) : this.extend(c.Q.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(c.Q.convert(e)) : this;
                            if (o = e._sw, u = e._ne, !o || !u) return this;
                        }
                        return i || s ? (i.lng = Math.min(o.lng, i.lng), i.lat = Math.min(o.lat, i.lat), s.lng = Math.max(u.lng, s.lng), s.lat = Math.max(u.lat, s.lat)) : (this._sw = new c.Q(o.lng, o.lat), this._ne = new c.Q(u.lng, u.lat)), this;
                    }
                    getCenter() {
                        return new c.Q((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
                    }
                    getSouthWest() {
                        return this._sw;
                    }
                    getNorthEast() {
                        return this._ne;
                    }
                    getNorthWest() {
                        return new c.Q(this.getWest(), this.getNorth());
                    }
                    getSouthEast() {
                        return new c.Q(this.getEast(), this.getSouth());
                    }
                    getWest() {
                        return this._sw.lng;
                    }
                    getSouth() {
                        return this._sw.lat;
                    }
                    getEast() {
                        return this._ne.lng;
                    }
                    getNorth() {
                        return this._ne.lat;
                    }
                    toArray() {
                        return [this._sw.toArray(), this._ne.toArray()];
                    }
                    toString() {
                        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
                    }
                    isEmpty() {
                        return !(this._sw && this._ne);
                    }
                    contains(e) {
                        const { lng: i, lat: s } = c.Q.convert(e);
                        let o = this._sw.lng <= i && i <= this._ne.lng;
                        return this._sw.lng > this._ne.lng && (o = this._sw.lng >= i && i >= this._ne.lng), this._sw.lat <= s && s <= this._ne.lat && o;
                    }
                    static convert(e) {
                        return e instanceof bt ? e : e && new bt(e);
                    }
                    static fromLngLat(e, i = 0) {
                        const s = 360 * i / 40075017, o = s / Math.cos(Math.PI / 180 * e.lat);
                        return new bt(new c.Q(e.lng - o, e.lat - s), new c.Q(e.lng + o, e.lat + s));
                    }
                    adjustAntiMeridian() {
                        const e = new c.Q(this._sw.lng, this._sw.lat), i = new c.Q(this._ne.lng, this._ne.lat);
                        return new bt(e, e.lng > i.lng ? new c.Q(i.lng + 360, i.lat) : i);
                    }
                }
                class dr {
                    constructor(e, i, s) {
                        this.bounds = bt.convert(this.validateBounds(e)), this.minzoom = i || 0, this.maxzoom = s || 24;
                    }
                    validateBounds(e) {
                        return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
                    }
                    contains(e) {
                        const i = Math.pow(2, e.z), s = Math.floor(c.U(this.bounds.getWest()) * i), o = Math.floor(c.S(this.bounds.getNorth()) * i), u = Math.ceil(c.U(this.bounds.getEast()) * i), f = Math.ceil(c.S(this.bounds.getSouth()) * i);
                        return e.x >= s && e.x < u && e.y >= o && e.y < f;
                    }
                }
                class Or extends c.E {
                    constructor(e, i, s, o) {
                        if (super(), this.id = e, this.dispatcher = s, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, c.e(this, c.O(i, ["url", "scheme", "tileSize", "promoteId"])), this._options = c.e({ type: "vector" }, i), this._collectResourceTiming = i.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
                        this.setEventedParent(o);
                    }
                    load() {
                        return c._(this, void 0, void 0, function* () {
                            this._loaded = !1, this.fire(new c.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
                            try {
                                const e = yield wi(this._options, this.map._requestManager, this._tileJSONRequest);
                                this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e && (c.e(this, e), e.bounds && (this.tileBounds = new dr(e.bounds, this.minzoom, this.maxzoom)), this.fire(new c.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new c.l("data", { dataType: "source", sourceDataType: "content" })));
                            } catch (e) {
                                this._tileJSONRequest = null, this.fire(new c.k(e));
                            }
                        });
                    }
                    loaded() {
                        return this._loaded;
                    }
                    hasTile(e) {
                        return !this.tileBounds || this.tileBounds.contains(e.canonical);
                    }
                    onAdd(e) {
                        this.map = e, this.load();
                    }
                    setSourceProperty(e) {
                        this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
                    }
                    setTiles(e) {
                        return this.setSourceProperty(() => {
                            this._options.tiles = e;
                        }), this;
                    }
                    setUrl(e) {
                        return this.setSourceProperty(() => {
                            this.url = e, this._options.url = e;
                        }), this;
                    }
                    onRemove() {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
                    }
                    serialize() {
                        return c.e({}, this._options);
                    }
                    loadTile(e) {
                        return c._(this, void 0, void 0, function* () {
                            const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), s = { request: this.map._requestManager.transformRequest(i, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
                            s.request.collectResourceTiming = this._collectResourceTiming;
                            let o = "RT";
                            if (e.actor && e.state !== "expired") {
                                if (e.state === "loading") return new Promise((u, f) => {
                                    e.reloadPromise = { resolve: u, reject: f };
                                });
                            } else e.actor = this.dispatcher.getActor(), o = "LT";
                            e.abortController = new AbortController();
                            try {
                                const u = yield e.actor.sendAsync({ type: o, data: s }, e.abortController);
                                if (delete e.abortController, e.aborted) return;
                                this._afterTileLoadWorkerResponse(e, u);
                            } catch (u) {
                                if (delete e.abortController, e.aborted) return;
                                if (u && u.status !== 404) throw u;
                                this._afterTileLoadWorkerResponse(e, null);
                            }
                        });
                    }
                    _afterTileLoadWorkerResponse(e, i) {
                        if (i && i.resourceTiming && (e.resourceTiming = i.resourceTiming), i && this.map._refreshExpiredTiles && e.setExpiryData(i), e.loadVectorData(i, this.map.painter), e.reloadPromise) {
                            const s = e.reloadPromise;
                            e.reloadPromise = null, this.loadTile(e).then(s.resolve).catch(s.reject);
                        }
                    }
                    abortTile(e) {
                        return c._(this, void 0, void 0, function* () {
                            e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } }));
                        });
                    }
                    unloadTile(e) {
                        return c._(this, void 0, void 0, function* () {
                            e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }));
                        });
                    }
                    hasTransition() {
                        return !1;
                    }
                }
                class Gi extends c.E {
                    constructor(e, i, s, o) {
                        super(), this.id = e, this.dispatcher = s, this.setEventedParent(o), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = c.e({ type: "raster" }, i), c.e(this, c.O(i, ["url", "scheme", "tileSize"]));
                    }
                    load() {
                        return c._(this, arguments, void 0, function* (e = !1) {
                            this._loaded = !1, this.fire(new c.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
                            try {
                                const i = yield wi(this._options, this.map._requestManager, this._tileJSONRequest);
                                this._tileJSONRequest = null, this._loaded = !0, i && (c.e(this, i), i.bounds && (this.tileBounds = new dr(i.bounds, this.minzoom, this.maxzoom)), this.fire(new c.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new c.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e })));
                            } catch (i) {
                                this._tileJSONRequest = null, this.fire(new c.k(i));
                            }
                        });
                    }
                    loaded() {
                        return this._loaded;
                    }
                    onAdd(e) {
                        this.map = e, this.load();
                    }
                    onRemove() {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
                    }
                    setSourceProperty(e) {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0);
                    }
                    setTiles(e) {
                        return this.setSourceProperty(() => {
                            this._options.tiles = e;
                        }), this;
                    }
                    setUrl(e) {
                        return this.setSourceProperty(() => {
                            this.url = e, this._options.url = e;
                        }), this;
                    }
                    serialize() {
                        return c.e({}, this._options);
                    }
                    hasTile(e) {
                        return !this.tileBounds || this.tileBounds.contains(e.canonical);
                    }
                    loadTile(e) {
                        return c._(this, void 0, void 0, function* () {
                            const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
                            e.abortController = new AbortController();
                            try {
                                const s = yield bi.getImage(this.map._requestManager.transformRequest(i, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                                if (s && s.data) {
                                    this.map._refreshExpiredTiles && (s.cacheControl || s.expires) && e.setExpiryData({ cacheControl: s.cacheControl, expires: s.expires });
                                    const o = this.map.painter.context, u = o.gl, f = s.data;
                                    e.texture = this.map.painter.getTileTexture(f.width), e.texture ? e.texture.update(f, { useMipmap: !0 }) : (e.texture = new Dt(o, f, u.RGBA, { useMipmap: !0 }), e.texture.bind(u.LINEAR, u.CLAMP_TO_EDGE, u.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
                                }
                            } catch (s) {
                                if (delete e.abortController, e.aborted) e.state = "unloaded";
                                else if (s) throw e.state = "errored", s;
                            }
                        });
                    }
                    abortTile(e) {
                        return c._(this, void 0, void 0, function* () {
                            e.abortController && (e.abortController.abort(), delete e.abortController);
                        });
                    }
                    unloadTile(e) {
                        return c._(this, void 0, void 0, function* () {
                            e.texture && this.map.painter.saveTileTexture(e.texture);
                        });
                    }
                    hasTransition() {
                        return !1;
                    }
                }
                class pn extends Gi {
                    constructor(e, i, s, o) {
                        super(e, i, s, o), this.type = "raster-dem", this.maxzoom = 22, this._options = c.e({ type: "raster-dem" }, i), this.encoding = i.encoding || "mapbox", this.redFactor = i.redFactor, this.greenFactor = i.greenFactor, this.blueFactor = i.blueFactor, this.baseShift = i.baseShift;
                    }
                    loadTile(e) {
                        return c._(this, void 0, void 0, function* () {
                            const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), s = this.map._requestManager.transformRequest(i, "Tile");
                            e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
                            try {
                                const o = yield bi.getImage(s, e.abortController, this.map._refreshExpiredTiles);
                                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                                if (o && o.data) {
                                    const u = o.data;
                                    this.map._refreshExpiredTiles && (o.cacheControl || o.expires) && e.setExpiryData({ cacheControl: o.cacheControl, expires: o.expires });
                                    const f = c.b(u) && c.V() ? u : yield this.readImageNow(u), g = { type: this.type, uid: e.uid, source: this.id, rawImageData: f, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                                    if (!e.actor || e.state === "expired") {
                                        e.actor = this.dispatcher.getActor();
                                        const y = yield e.actor.sendAsync({ type: "LDT", data: g });
                                        e.dem = y, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded";
                                    }
                                }
                            } catch (o) {
                                if (delete e.abortController, e.aborted) e.state = "unloaded";
                                else if (o) throw e.state = "errored", o;
                            }
                        });
                    }
                    readImageNow(e) {
                        return c._(this, void 0, void 0, function* () {
                            if (typeof VideoFrame < "u" && c.W()) {
                                const i = e.width + 2, s = e.height + 2;
                                try {
                                    return new c.R({ width: i, height: s }, yield c.X(e, -1, -1, i, s));
                                } catch {
                                }
                            }
                            return Ue.getImageData(e, 1);
                        });
                    }
                    _getNeighboringTiles(e) {
                        const i = e.canonical, s = Math.pow(2, i.z), o = (i.x - 1 + s) % s, u = i.x === 0 ? e.wrap - 1 : e.wrap, f = (i.x + 1 + s) % s, g = i.x + 1 === s ? e.wrap + 1 : e.wrap, y = {};
                        return y[new c.Y(e.overscaledZ, u, i.z, o, i.y).key] = { backfilled: !1 }, y[new c.Y(e.overscaledZ, g, i.z, f, i.y).key] = { backfilled: !1 }, i.y > 0 && (y[new c.Y(e.overscaledZ, u, i.z, o, i.y - 1).key] = { backfilled: !1 }, y[new c.Y(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key] = { backfilled: !1 }, y[new c.Y(e.overscaledZ, g, i.z, f, i.y - 1).key] = { backfilled: !1 }), i.y + 1 < s && (y[new c.Y(e.overscaledZ, u, i.z, o, i.y + 1).key] = { backfilled: !1 }, y[new c.Y(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key] = { backfilled: !1 }, y[new c.Y(e.overscaledZ, g, i.z, f, i.y + 1).key] = { backfilled: !1 }), y;
                    }
                    unloadTile(e) {
                        return c._(this, void 0, void 0, function* () {
                            e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } }));
                        });
                    }
                }
                class dn extends c.E {
                    constructor(e, i, s, o) {
                        super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = s.getActor(), this.setEventedParent(o), this._data = i.data, this._options = c.e({}, i), this._collectResourceTiming = i.collectResourceTiming, i.maxzoom !== void 0 && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId, i.clusterMaxZoom !== void 0 && this.maxzoom <= i.clusterMaxZoom && c.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i.clusterMaxZoom}".`), this.workerOptions = c.e({ source: this.id, cluster: i.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(i.buffer !== void 0 ? i.buffer : 128), tolerance: this._pixelsToTileUnits(i.tolerance !== void 0 ? i.tolerance : 0.375), extent: c.Z, maxZoom: this.maxzoom, lineMetrics: i.lineMetrics || !1, generateId: i.generateId || !1 }, superclusterOptions: { maxZoom: i.clusterMaxZoom !== void 0 ? i.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i.clusterMinPoints || 2), extent: c.Z, radius: this._pixelsToTileUnits(i.clusterRadius || 50), log: !1, generateId: i.generateId || !1 }, clusterProperties: i.clusterProperties, filter: i.filter }, i.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
                    }
                    _pixelsToTileUnits(e) {
                        return e * (c.Z / this.tileSize);
                    }
                    load() {
                        return c._(this, void 0, void 0, function* () {
                            yield this._updateWorkerData();
                        });
                    }
                    onAdd(e) {
                        this.map = e, this.load();
                    }
                    setData(e) {
                        return this._data = e, this._updateWorkerData(), this;
                    }
                    updateData(e) {
                        return this._updateWorkerData(e), this;
                    }
                    getData() {
                        return c._(this, void 0, void 0, function* () {
                            const e = c.e({ type: this.type }, this.workerOptions);
                            return this.actor.sendAsync({ type: "GD", data: e });
                        });
                    }
                    getCoordinatesFromGeometry(e) {
                        return e.type === "GeometryCollection" ? e.geometries.map((i) => i.coordinates).flat(1 / 0) : e.coordinates.flat(1 / 0);
                    }
                    getBounds() {
                        return c._(this, void 0, void 0, function* () {
                            const e = new bt(), i = yield this.getData();
                            let s;
                            switch (i.type) {
                                case "FeatureCollection":
                                    s = i.features.map((o) => this.getCoordinatesFromGeometry(o.geometry)).flat(1 / 0);
                                    break;
                                case "Feature":
                                    s = this.getCoordinatesFromGeometry(i.geometry);
                                    break;
                                default:
                                    s = this.getCoordinatesFromGeometry(i);
                            }
                            if (s.length == 0) return e;
                            for (let o = 0; o < s.length - 1; o += 2) e.extend([s[o], s[o + 1]]);
                            return e;
                        });
                    }
                    setClusterOptions(e) {
                        return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = e.clusterMaxZoom)), this._updateWorkerData(), this;
                    }
                    getClusterExpansionZoom(e) {
                        return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
                    }
                    getClusterChildren(e) {
                        return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
                    }
                    getClusterLeaves(e, i, s) {
                        return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: i, offset: s } });
                    }
                    _updateWorkerData(e) {
                        return c._(this, void 0, void 0, function* () {
                            const i = c.e({ type: this.type }, this.workerOptions);
                            e ? i.dataDiff = e : typeof this._data == "string" ? (i.request = this.map._requestManager.transformRequest(Ue.resolveURL(this._data), "Source"), i.request.collectResourceTiming = this._collectResourceTiming) : i.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new c.l("dataloading", { dataType: "source" }));
                            try {
                                const s = yield this.actor.sendAsync({ type: "LD", data: i });
                                if (this._pendingLoads--, this._removed || s.abandoned) return void this.fire(new c.l("dataabort", { dataType: "source" }));
                                let o = null;
                                s.resourceTiming && s.resourceTiming[this.id] && (o = s.resourceTiming[this.id].slice(0));
                                const u = { dataType: "source" };
                                this._collectResourceTiming && o && o.length > 0 && c.e(u, { resourceTiming: o }), this.fire(new c.l("data", Object.assign(Object.assign({}, u), { sourceDataType: "metadata" }))), this.fire(new c.l("data", Object.assign(Object.assign({}, u), { sourceDataType: "content" })));
                            } catch (s) {
                                if (this._pendingLoads--, this._removed) return void this.fire(new c.l("dataabort", { dataType: "source" }));
                                this.fire(new c.k(s));
                            }
                        });
                    }
                    loaded() {
                        return this._pendingLoads === 0;
                    }
                    loadTile(e) {
                        return c._(this, void 0, void 0, function* () {
                            const i = e.actor ? "RT" : "LT";
                            e.actor = this.actor;
                            const s = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
                            e.abortController = new AbortController();
                            const o = yield this.actor.sendAsync({ type: i, data: s }, e.abortController);
                            delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(o, this.map.painter, i === "RT");
                        });
                    }
                    abortTile(e) {
                        return c._(this, void 0, void 0, function* () {
                            e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0;
                        });
                    }
                    unloadTile(e) {
                        return c._(this, void 0, void 0, function* () {
                            e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
                        });
                    }
                    onRemove() {
                        this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
                    }
                    serialize() {
                        return c.e({}, this._options, { type: this.type, data: this._data });
                    }
                    hasTransition() {
                        return !1;
                    }
                }
                class Fi extends c.E {
                    constructor(e, i, s, o) {
                        super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = s, this.coordinates = i.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(o), this.options = i;
                    }
                    load(e) {
                        return c._(this, void 0, void 0, function* () {
                            this._loaded = !1, this.fire(new c.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
                            try {
                                const i = yield bi.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                                this._request = null, this._loaded = !0, i && i.data && (this.image = i.data, e && (this.coordinates = e), this._finishLoading());
                            } catch (i) {
                                this._request = null, this._loaded = !0, this.fire(new c.k(i));
                            }
                        });
                    }
                    loaded() {
                        return this._loaded;
                    }
                    updateImage(e) {
                        return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally(() => {
                            this.texture = null;
                        }), this) : this;
                    }
                    _finishLoading() {
                        this.map && (this.setCoordinates(this.coordinates), this.fire(new c.l("data", { dataType: "source", sourceDataType: "metadata" })));
                    }
                    onAdd(e) {
                        this.map = e, this.load();
                    }
                    onRemove() {
                        this._request && (this._request.abort(), this._request = null);
                    }
                    setCoordinates(e) {
                        this.coordinates = e;
                        const i = e.map(c.$.fromLngLat);
                        var s;
                        return this.tileID = function (o) {
                            let u = 1 / 0, f = 1 / 0, g = -1 / 0, y = -1 / 0;
                            for (const T of o) u = Math.min(u, T.x), f = Math.min(f, T.y), g = Math.max(g, T.x), y = Math.max(y, T.y);
                            const x = Math.max(g - u, y - f), w = Math.max(0, Math.floor(-Math.log(x) / Math.LN2)), P = Math.pow(2, w);
                            return new c.a1(w, Math.floor((u + g) / 2 * P), Math.floor((f + y) / 2 * P));
                        }(i), this.terrainTileRanges = this._getOverlappingTileRanges(i), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i.map((o) => this.tileID.getTilePoint(o)._round()), this.flippedWindingOrder = ((s = this.tileCoords)[1].x - s[0].x) * (s[2].y - s[0].y) - (s[1].y - s[0].y) * (s[2].x - s[0].x) < 0, this.fire(new c.l("data", { dataType: "source", sourceDataType: "content" })), this;
                    }
                    prepare() {
                        if (Object.keys(this.tiles).length === 0 || !this.image) return;
                        const e = this.map.painter.context, i = e.gl;
                        this.texture || (this.texture = new Dt(e, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
                        let s = !1;
                        for (const o in this.tiles) {
                            const u = this.tiles[o];
                            u.state !== "loaded" && (u.state = "loaded", u.texture = this.texture, s = !0);
                        }
                        s && this.fire(new c.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
                    }
                    loadTile(e) {
                        return c._(this, void 0, void 0, function* () {
                            this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
                        });
                    }
                    serialize() {
                        return { type: "image", url: this.options.url, coordinates: this.coordinates };
                    }
                    hasTransition() {
                        return !1;
                    }
                    _getOverlappingTileRanges(e) {
                        let i = 1 / 0, s = 1 / 0, o = -1 / 0, u = -1 / 0;
                        for (const g of e) i = Math.min(i, g.x), s = Math.min(s, g.y), o = Math.max(o, g.x), u = Math.max(u, g.y);
                        const f = {};
                        for (let g = 0; g <= c.a0; g++) {
                            const y = Math.pow(2, g), x = Math.floor(i * y), w = Math.floor(s * y), P = Math.floor(o * y), T = Math.floor(u * y);
                            f[g] = { minTileX: x, minTileY: w, maxTileX: P, maxTileY: T };
                        }
                        return f;
                    }
                }
                class fr extends Fi {
                    constructor(e, i, s, o) {
                        super(e, i, s, o), this.roundZoom = !0, this.type = "video", this.options = i;
                    }
                    load() {
                        return c._(this, void 0, void 0, function* () {
                            this._loaded = !1;
                            const e = this.options;
                            this.urls = [];
                            for (const i of e.urls) this.urls.push(this.map._requestManager.transformRequest(i, "Source").url);
                            try {
                                const i = yield c.a2(this.urls);
                                if (this._loaded = !0, !i) return;
                                this.video = i, this.video.loop = !0, this.video.addEventListener("playing", () => {
                                    this.map.triggerRepaint();
                                }), this.map && this.video.play(), this._finishLoading();
                            } catch (i) {
                                this.fire(new c.k(i));
                            }
                        });
                    }
                    pause() {
                        this.video && this.video.pause();
                    }
                    play() {
                        this.video && this.video.play();
                    }
                    seek(e) {
                        if (this.video) {
                            const i = this.video.seekable;
                            e < i.start(0) || e > i.end(0) ? this.fire(new c.k(new c.a3(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = e;
                        }
                    }
                    getVideo() {
                        return this.video;
                    }
                    onAdd(e) {
                        this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
                    }
                    prepare() {
                        if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
                        const e = this.map.painter.context, i = e.gl;
                        this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new Dt(e, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
                        let s = !1;
                        for (const o in this.tiles) {
                            const u = this.tiles[o];
                            u.state !== "loaded" && (u.state = "loaded", u.texture = this.texture, s = !0);
                        }
                        s && this.fire(new c.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
                    }
                    serialize() {
                        return { type: "video", urls: this.urls, coordinates: this.coordinates };
                    }
                    hasTransition() {
                        return this.video && !this.video.paused;
                    }
                }
                class ta extends Fi {
                    constructor(e, i, s, o) {
                        super(e, i, s, o), i.coordinates ? Array.isArray(i.coordinates) && i.coordinates.length === 4 && !i.coordinates.some((u) => !Array.isArray(u) || u.length !== 2 || u.some((f) => typeof f != "number")) || this.fire(new c.k(new c.a3(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new c.k(new c.a3(`sources.${e}`, null, 'missing required property "coordinates"'))), i.animate && typeof i.animate != "boolean" && this.fire(new c.k(new c.a3(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? typeof i.canvas == "string" || i.canvas instanceof HTMLCanvasElement || this.fire(new c.k(new c.a3(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new c.k(new c.a3(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = i.animate === void 0 || i.animate;
                    }
                    load() {
                        return c._(this, void 0, void 0, function* () {
                            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new c.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () {
                                this._playing = !0, this.map.triggerRepaint();
                            }, this.pause = function () {
                                this._playing && (this.prepare(), this._playing = !1);
                            }, this._finishLoading());
                        });
                    }
                    getCanvas() {
                        return this.canvas;
                    }
                    onAdd(e) {
                        this.map = e, this.load(), this.canvas && this.animate && this.play();
                    }
                    onRemove() {
                        this.pause();
                    }
                    prepare() {
                        let e = !1;
                        if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
                        const i = this.map.painter.context, s = i.gl;
                        this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new Dt(i, this.canvas, s.RGBA, { premultiply: !0 });
                        let o = !1;
                        for (const u in this.tiles) {
                            const f = this.tiles[u];
                            f.state !== "loaded" && (f.state = "loaded", f.texture = this.texture, o = !0);
                        }
                        o && this.fire(new c.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
                    }
                    serialize() {
                        return { type: "canvas", coordinates: this.coordinates };
                    }
                    hasTransition() {
                        return this._playing;
                    }
                    _hasInvalidDimensions() {
                        for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;
                        return !1;
                    }
                }
                const ia = {}, Sr = (h) => {
                    switch (h) {
                        case "geojson":
                            return dn;
                        case "image":
                            return Fi;
                        case "raster":
                            return Gi;
                        case "raster-dem":
                            return pn;
                        case "vector":
                            return Or;
                        case "video":
                            return fr;
                        case "canvas":
                            return ta;
                    }
                    return ia[h];
                }, Ma = "RTLPluginLoaded";
                class Ia extends c.E {
                    constructor() {
                        super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Pa();
                    }
                    _syncState(e) {
                        return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch((i) => {
                            throw this.status = "error", i;
                        });
                    }
                    getRTLTextPluginStatus() {
                        return this.status;
                    }
                    clearRTLTextPlugin() {
                        this.status = "unavailable", this.url = null;
                    }
                    setRTLTextPlugin(e) {
                        return c._(this, arguments, void 0, function* (i, s = !1) {
                            if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
                            if (this.url = Ue.resolveURL(i), !this.url) throw new Error(`requested url ${i} is invalid`);
                            if (this.status === "unavailable") {
                                if (!s) return this._requestImport();
                                this.status = "deferred", this._syncState(this.status);
                            } else if (this.status === "requested") return this._requestImport();
                        });
                    }
                    _requestImport() {
                        return c._(this, void 0, void 0, function* () {
                            yield this._syncState("loading"), this.status = "loaded", this.fire(new c.l(Ma));
                        });
                    }
                    lazyLoad() {
                        this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
                    }
                }
                let Ca = null;
                function Tr() {
                    return Ca || (Ca = new Ia()), Ca;
                }
                class Pr {
                    constructor(e, i) {
                        this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = c.a4(), this.uses = 0, this.tileSize = i, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
                    }
                    registerFadeDuration(e) {
                        const i = e + this.timeAdded;
                        i < this.fadeEndTime || (this.fadeEndTime = i);
                    }
                    wasRequested() {
                        return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
                    }
                    clearTextures(e) {
                        this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
                    }
                    loadVectorData(e, i, s) {
                        if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
                            e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = function (o, u) {
                                const f = {};
                                if (!u) return f;
                                for (const g of o) {
                                    const y = g.layerIds.map((x) => u.getLayer(x)).filter(Boolean);
                                    if (y.length !== 0) {
                                        g.layers = y, g.stateDependentLayerIds && (g.stateDependentLayers = g.stateDependentLayerIds.map((x) => y.filter((w) => w.id === x)[0]));
                                        for (const x of y) f[x.id] = g;
                                    }
                                }
                                return f;
                            }(e.buckets, i == null ? void 0 : i.style), this.hasSymbolBuckets = !1;
                            for (const o in this.buckets) {
                                const u = this.buckets[o];
                                if (u instanceof c.a6) {
                                    if (this.hasSymbolBuckets = !0, !s) break;
                                    u.justReloaded = !0;
                                }
                            }
                            if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const o in this.buckets) {
                                const u = this.buckets[o];
                                if (u instanceof c.a6 && u.hasRTLText) {
                                    this.hasRTLText = !0, Tr().lazyLoad();
                                    break;
                                }
                            }
                            this.queryPadding = 0;
                            for (const o in this.buckets) {
                                const u = this.buckets[o];
                                this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(o).queryRadius(u));
                            }
                            e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
                        } else this.collisionBoxArray = new c.a5();
                    }
                    unloadVectorData() {
                        for (const e in this.buckets) this.buckets[e].destroy();
                        this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
                    }
                    getBucket(e) {
                        return this.buckets[e.id];
                    }
                    upload(e) {
                        for (const s in this.buckets) {
                            const o = this.buckets[s];
                            o.uploadPending() && o.upload(e);
                        }
                        const i = e.gl;
                        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Dt(e, this.imageAtlas.image, i.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new Dt(e, this.glyphAtlasImage, i.ALPHA), this.glyphAtlasImage = null);
                    }
                    prepare(e) {
                        this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
                    }
                    queryRenderedFeatures(e, i, s, o, u, f, g, y, x, w, P) {
                        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: o, cameraQueryGeometry: u, scale: f, tileSize: this.tileSize, pixelPosMatrix: w, transform: y, params: g, queryPadding: this.queryPadding * x, getElevation: P }, e, i, s) : {};
                    }
                    querySourceFeatures(e, i) {
                        const s = this.latestFeatureIndex;
                        if (!s || !s.rawTileData) return;
                        const o = s.loadVTLayers(), u = i && i.sourceLayer ? i.sourceLayer : "", f = o._geojsonTileLayer || o[u];
                        if (!f) return;
                        const g = c.a7(i && i.filter), { z: y, x, y: w } = this.tileID.canonical, P = { z: y, x, y: w };
                        for (let T = 0; T < f.length; T++) {
                            const z = f.feature(T);
                            if (g.needGeometry) {
                                const U = c.a8(z, !0);
                                if (!g.filter(new c.C(this.tileID.overscaledZ), U, this.tileID.canonical)) continue;
                            } else if (!g.filter(new c.C(this.tileID.overscaledZ), z)) continue;
                            const R = s.getId(z, u), V = new c.a9(z, y, x, w, R);
                            V.tile = P, e.push(V);
                        }
                    }
                    hasData() {
                        return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
                    }
                    patternsLoaded() {
                        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
                    }
                    setExpiryData(e) {
                        const i = this.expirationTime;
                        if (e.cacheControl) {
                            const s = c.aa(e.cacheControl);
                            s["max-age"] && (this.expirationTime = Date.now() + 1e3 * s["max-age"]);
                        } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
                        if (this.expirationTime) {
                            const s = Date.now();
                            let o = !1;
                            if (this.expirationTime > s) o = !1;
                            else if (i) if (this.expirationTime < i) o = !0;
                            else {
                                const u = this.expirationTime - i;
                                u ? this.expirationTime = s + Math.max(u, 3e4) : o = !0;
                            }
                            else o = !0;
                            o ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
                        }
                    }
                    getExpiryTimeout() {
                        if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
                    }
                    setFeatureState(e, i) {
                        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
                        const s = this.latestFeatureIndex.loadVTLayers();
                        for (const o in this.buckets) {
                            if (!i.style.hasLayer(o)) continue;
                            const u = this.buckets[o], f = u.layers[0].sourceLayer || "_geojsonTileLayer", g = s[f], y = e[f];
                            if (!g || !y || Object.keys(y).length === 0) continue;
                            u.update(y, g, this.imageAtlas && this.imageAtlas.patternPositions || {});
                            const x = i && i.style && i.style.getLayer(o);
                            x && (this.queryPadding = Math.max(this.queryPadding, x.queryRadius(u)));
                        }
                    }
                    holdingForFade() {
                        return this.symbolFadeHoldUntil !== void 0;
                    }
                    symbolFadeFinished() {
                        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Ue.now();
                    }
                    clearFadeHold() {
                        this.symbolFadeHoldUntil = void 0;
                    }
                    setHoldDuration(e) {
                        this.symbolFadeHoldUntil = Ue.now() + e;
                    }
                    setDependencies(e, i) {
                        const s = {};
                        for (const o of i) s[o] = !0;
                        this.dependencies[e] = s;
                    }
                    hasDependency(e, i) {
                        for (const s of e) {
                            const o = this.dependencies[s];
                            if (o) {
                                for (const u of i) if (o[u]) return !0;
                            }
                        }
                        return !1;
                    }
                }
                class jr {
                    constructor(e, i) {
                        this.max = e, this.onRemove = i, this.reset();
                    }
                    reset() {
                        for (const e in this.data) for (const i of this.data[e]) i.timeout && clearTimeout(i.timeout), this.onRemove(i.value);
                        return this.data = {}, this.order = [], this;
                    }
                    add(e, i, s) {
                        const o = e.wrapped().key;
                        this.data[o] === void 0 && (this.data[o] = []);
                        const u = { value: i, timeout: void 0 };
                        if (s !== void 0 && (u.timeout = setTimeout(() => {
                            this.remove(e, u);
                        }, s)), this.data[o].push(u), this.order.push(o), this.order.length > this.max) {
                            const f = this._getAndRemoveByKey(this.order[0]);
                            f && this.onRemove(f);
                        }
                        return this;
                    }
                    has(e) {
                        return e.wrapped().key in this.data;
                    }
                    getAndRemove(e) {
                        return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
                    }
                    _getAndRemoveByKey(e) {
                        const i = this.data[e].shift();
                        return i.timeout && clearTimeout(i.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), i.value;
                    }
                    getByKey(e) {
                        const i = this.data[e];
                        return i ? i[0].value : null;
                    }
                    get(e) {
                        return this.has(e) ? this.data[e.wrapped().key][0].value : null;
                    }
                    remove(e, i) {
                        if (!this.has(e)) return this;
                        const s = e.wrapped().key, o = i === void 0 ? 0 : this.data[s].indexOf(i), u = this.data[s][o];
                        return this.data[s].splice(o, 1), u.timeout && clearTimeout(u.timeout), this.data[s].length === 0 && delete this.data[s], this.onRemove(u.value), this.order.splice(this.order.indexOf(s), 1), this;
                    }
                    setMaxSize(e) {
                        for (this.max = e; this.order.length > this.max;) {
                            const i = this._getAndRemoveByKey(this.order[0]);
                            i && this.onRemove(i);
                        }
                        return this;
                    }
                    filter(e) {
                        const i = [];
                        for (const s in this.data) for (const o of this.data[s]) e(o.value) || i.push(o);
                        for (const s of i) this.remove(s.value.tileID, s);
                    }
                }
                class Aa {
                    constructor() {
                        this.state = {}, this.stateChanges = {}, this.deletedStates = {};
                    }
                    updateState(e, i, s) {
                        const o = String(i);
                        if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][o] = this.stateChanges[e][o] || {}, c.e(this.stateChanges[e][o], s), this.deletedStates[e] === null) {
                            this.deletedStates[e] = {};
                            for (const u in this.state[e]) u !== o && (this.deletedStates[e][u] = null);
                        } else if (this.deletedStates[e] && this.deletedStates[e][o] === null) {
                            this.deletedStates[e][o] = {};
                            for (const u in this.state[e][o]) s[u] || (this.deletedStates[e][o][u] = null);
                        } else for (const u in s) this.deletedStates[e] && this.deletedStates[e][o] && this.deletedStates[e][o][u] === null && delete this.deletedStates[e][o][u];
                    }
                    removeFeatureState(e, i, s) {
                        if (this.deletedStates[e] === null) return;
                        const o = String(i);
                        if (this.deletedStates[e] = this.deletedStates[e] || {}, s && i !== void 0) this.deletedStates[e][o] !== null && (this.deletedStates[e][o] = this.deletedStates[e][o] || {}, this.deletedStates[e][o][s] = null);
                        else if (i !== void 0) if (this.stateChanges[e] && this.stateChanges[e][o]) for (s in this.deletedStates[e][o] = {}, this.stateChanges[e][o]) this.deletedStates[e][o][s] = null;
                        else this.deletedStates[e][o] = null;
                        else this.deletedStates[e] = null;
                    }
                    getState(e, i) {
                        const s = String(i), o = c.e({}, (this.state[e] || {})[s], (this.stateChanges[e] || {})[s]);
                        if (this.deletedStates[e] === null) return {};
                        if (this.deletedStates[e]) {
                            const u = this.deletedStates[e][i];
                            if (u === null) return {};
                            for (const f in u) delete o[f];
                        }
                        return o;
                    }
                    initializeTileState(e, i) {
                        e.setFeatureState(this.state, i);
                    }
                    coalesceChanges(e, i) {
                        const s = {};
                        for (const o in this.stateChanges) {
                            this.state[o] = this.state[o] || {};
                            const u = {};
                            for (const f in this.stateChanges[o]) this.state[o][f] || (this.state[o][f] = {}), c.e(this.state[o][f], this.stateChanges[o][f]), u[f] = this.state[o][f];
                            s[o] = u;
                        }
                        for (const o in this.deletedStates) {
                            this.state[o] = this.state[o] || {};
                            const u = {};
                            if (this.deletedStates[o] === null) for (const f in this.state[o]) u[f] = {}, this.state[o][f] = {};
                            else for (const f in this.deletedStates[o]) {
                                if (this.deletedStates[o][f] === null) this.state[o][f] = {};
                                else for (const g of Object.keys(this.deletedStates[o][f])) delete this.state[o][f][g];
                                u[f] = this.state[o][f];
                            }
                            s[o] = s[o] || {}, c.e(s[o], u);
                        }
                        if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(s).length !== 0) for (const o in e) e[o].setFeatureState(s, i);
                    }
                }
                const qi = 89.25;
                function Ai(h, e) {
                    const i = c.ae(e.lat, -85.051129, c.af);
                    return new c.P(c.U(e.lng) * h, c.S(i) * h);
                }
                function mr(h, e) {
                    return new c.$(e.x / h, e.y / h).toLngLat();
                }
                function oe(h) {
                    return h.cameraToCenterDistance * Math.min(0.85 * Math.tan(c.ab(90 - h.pitch)), Math.tan(c.ab(qi - h.pitch)));
                }
                function L(h, e) {
                    const i = h.canonical, s = e / c.ac(i.z), o = i.x + Math.pow(2, i.z) * h.wrap, u = c.ad(new Float64Array(16));
                    return c.L(u, u, [o * s, i.y * s, 0]), c.M(u, u, [s / c.Z, s / c.Z, 1]), u;
                }
                function B(h, e, i, s, o) {
                    const u = c.$.fromLngLat(h, e), f = o * c.ag(1, h.lat), g = f * Math.cos(c.ab(i)), y = Math.sqrt(f * f - g * g), x = y * Math.sin(c.ab(-s)), w = y * Math.cos(c.ab(-s));
                    return new c.$(u.x + x, u.y + w, u.z + g);
                }
                function $(h, e, i) {
                    const s = e.intersectsFrustum(h);
                    if (!i) return s;
                    const o = e.intersectsPlane(i);
                    return s === 0 || o === 0 ? 0 : s === 2 && o === 2 ? 2 : 1;
                }
                function W(h, e, i) {
                    let s = 0;
                    const o = (i - e) / 10;
                    for (let u = 0; u < 10; u++) s += o * Math.pow(Math.cos(e + (u + 0.5) / 10 * (i - e)), h);
                    return s;
                }
                function re(h, e) {
                    return function (i, s, o, u, f) {
                        const g = 2 * ((h - 1) / c.ah(Math.cos(c.ab(qi - f)) / Math.cos(c.ab(qi))) - 1), y = Math.acos(o / u), x = 2 * W(g - 1, 0, c.ab(f / 2)), w = Math.min(c.ab(qi), y + c.ab(f / 2)), P = W(g - 1, Math.min(w, y - c.ab(f / 2)), w), T = Math.atan(s / o), z = Math.hypot(s, o);
                        let R = i;
                        return R += c.ah(u / z / Math.max(0.5, Math.cos(c.ab(f / 2)))), R += g * c.ah(Math.cos(T)) / 2, R -= c.ah(Math.max(1, P / x / e)) / 2, R;
                    };
                }
                const O = re(9.314, 3);
                function pe(h, e) {
                    const i = (e.roundZoom ? Math.round : Math.floor)(h.zoom + c.ah(h.tileSize / e.tileSize));
                    return Math.max(0, i);
                }
                function ne(h, e) {
                    const i = h.getCameraFrustum(), s = h.getClippingPlane(), o = h.screenPointToMercatorCoordinate(h.getCameraPoint()), u = c.$.fromLngLat(h.center, h.elevation);
                    o.z = u.z + Math.cos(h.pitchInRadians) * h.cameraToCenterDistance / h.worldSize;
                    const f = h.getCoveringTilesDetailsProvider(), g = f.allowVariableZoom(h, e), y = pe(h, e), x = e.minzoom || 0, w = e.maxzoom !== void 0 ? e.maxzoom : h.maxZoom, P = Math.min(Math.max(0, y), w), T = Math.pow(2, P), z = [T * o.x, T * o.y, 0], R = [T * u.x, T * u.y, 0], V = Math.hypot(u.x - o.x, u.y - o.y), U = Math.abs(u.z - o.z), Z = Math.hypot(V, U), q = (ee) => ({ zoom: 0, x: 0, y: 0, wrap: ee, fullyVisible: !1 }), J = [], Y = [];
                    if (h.renderWorldCopies && f.allowWorldCopies()) for (let ee = 1; ee <= 3; ee++) J.push(q(-ee)), J.push(q(ee));
                    for (J.push(q(0)); J.length > 0;) {
                        const ee = J.pop(), ae = ee.x, te = ee.y;
                        let he = ee.fullyVisible;
                        const be = { x: ae, y: te, z: ee.zoom }, ge = f.getTileAABB(be, ee.wrap, h.elevation, e);
                        if (!he) {
                            const ze = $(i, ge, s);
                            if (ze === 0) continue;
                            he = ze === 2;
                        }
                        const _e = f.distanceToTile2d(o.x, o.y, be, ge);
                        let ye = y;
                        g && (ye = (e.calculateTileZoom || O)(h.zoom + c.ah(h.tileSize / e.tileSize), _e, U, Z, h.fov)), ye = (e.roundZoom ? Math.round : Math.floor)(ye), ye = Math.max(0, ye);
                        const Ee = Math.min(ye, w);
                        if (ee.wrap = f.getWrap(u, be, ee.wrap), ee.zoom >= Ee) {
                            if (ee.zoom < x) continue;
                            const ze = P - ee.zoom, Ce = z[0] - 0.5 - (ae << ze), Ne = z[1] - 0.5 - (te << ze), tt = e.reparseOverscaled ? Math.max(ee.zoom, ye) : ee.zoom;
                            Y.push({ tileID: new c.Y(ee.zoom === w ? tt : ee.zoom, ee.wrap, ee.zoom, ae, te), distanceSq: c.ai([R[0] - 0.5 - ae, R[1] - 0.5 - te]), tileDistanceToCamera: Math.sqrt(Ce * Ce + Ne * Ne) });
                        } else for (let ze = 0; ze < 4; ze++) J.push({ zoom: ee.zoom + 1, x: (ae << 1) + ze % 2, y: (te << 1) + (ze >> 1), wrap: ee.wrap, fullyVisible: he });
                    }
                    return Y.sort((ee, ae) => ee.distanceSq - ae.distanceSq).map((ee) => ee.tileID);
                }
                class ce extends c.E {
                    constructor(e, i, s) {
                        super(), this.id = e, this.dispatcher = s, this.on("data", (o) => this._dataHandler(o)), this.on("dataloading", () => {
                            this._sourceErrored = !1;
                        }), this.on("error", () => {
                            this._sourceErrored = this._source.loaded();
                        }), this._source = ((o, u, f, g) => {
                            const y = new (Sr(u.type))(o, u, f, g);
                            if (y.id !== o) throw new Error(`Expected Source id to be ${o} instead of ${y.id}`);
                            return y;
                        })(e, i, s, this), this._tiles = {}, this._cache = new jr(0, (o) => this._unloadTile(o)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Aa(), this._didEmitContent = !1, this._updated = !1;
                    }
                    onAdd(e) {
                        this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
                    }
                    onRemove(e) {
                        this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
                    }
                    loaded() {
                        if (this._sourceErrored) return !0;
                        if (!this._sourceLoaded || !this._source.loaded()) return !1;
                        if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
                        if (!this._updated) return !1;
                        for (const e in this._tiles) {
                            const i = this._tiles[e];
                            if (i.state !== "loaded" && i.state !== "errored") return !1;
                        }
                        return !0;
                    }
                    getSource() {
                        return this._source;
                    }
                    pause() {
                        this._paused = !0;
                    }
                    resume() {
                        if (!this._paused) return;
                        const e = this._shouldReloadOnResume;
                        this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
                    }
                    _loadTile(e, i, s) {
                        return c._(this, void 0, void 0, function* () {
                            try {
                                yield this._source.loadTile(e), this._tileLoaded(e, i, s);
                            } catch (o) {
                                e.state = "errored", o.status !== 404 ? this._source.fire(new c.k(o, { tile: e })) : this.update(this.transform, this.terrain);
                            }
                        });
                    }
                    _unloadTile(e) {
                        this._source.unloadTile && this._source.unloadTile(e);
                    }
                    _abortTile(e) {
                        this._source.abortTile && this._source.abortTile(e), this._source.fire(new c.l("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
                    }
                    serialize() {
                        return this._source.serialize();
                    }
                    prepare(e) {
                        this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                        for (const i in this._tiles) {
                            const s = this._tiles[i];
                            s.upload(e), s.prepare(this.map.style.imageManager);
                        }
                    }
                    getIds() {
                        return Object.values(this._tiles).map((e) => e.tileID).sort(fe).map((e) => e.key);
                    }
                    getRenderableIds(e) {
                        const i = [];
                        for (const s in this._tiles) this._isIdRenderable(s, e) && i.push(this._tiles[s]);
                        return e ? i.sort((s, o) => {
                            const u = s.tileID, f = o.tileID, g = new c.P(u.canonical.x, u.canonical.y)._rotate(-this.transform.bearingInRadians), y = new c.P(f.canonical.x, f.canonical.y)._rotate(-this.transform.bearingInRadians);
                            return u.overscaledZ - f.overscaledZ || y.y - g.y || y.x - g.x;
                        }).map((s) => s.tileID.key) : i.map((s) => s.tileID).sort(fe).map((s) => s.key);
                    }
                    hasRenderableParent(e) {
                        const i = this.findLoadedParent(e, 0);
                        return !!i && this._isIdRenderable(i.tileID.key);
                    }
                    _isIdRenderable(e, i) {
                        return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (i || !this._tiles[e].holdingForFade());
                    }
                    reload(e) {
                        if (this._paused) this._shouldReloadOnResume = !0;
                        else {
                            this._cache.reset();
                            for (const i in this._tiles) (e || this._tiles[i].state !== "errored") && this._reloadTile(i, "reloading");
                        }
                    }
                    _reloadTile(e, i) {
                        return c._(this, void 0, void 0, function* () {
                            const s = this._tiles[e];
                            s && (s.state !== "loading" && (s.state = i), yield this._loadTile(s, e, i));
                        });
                    }
                    _tileLoaded(e, i, s) {
                        e.timeAdded = Ue.now(), s === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new c.l("data", { dataType: "source", tile: e, coord: e.tileID }));
                    }
                    _backfillDEM(e) {
                        const i = this.getRenderableIds();
                        for (let o = 0; o < i.length; o++) {
                            const u = i[o];
                            if (e.neighboringTiles && e.neighboringTiles[u]) {
                                const f = this.getTileByID(u);
                                s(e, f), s(f, e);
                            }
                        }
                        function s(o, u) {
                            o.needsHillshadePrepare = !0, o.needsTerrainPrepare = !0;
                            let f = u.tileID.canonical.x - o.tileID.canonical.x;
                            const g = u.tileID.canonical.y - o.tileID.canonical.y, y = Math.pow(2, o.tileID.canonical.z), x = u.tileID.key;
                            f === 0 && g === 0 || Math.abs(g) > 1 || (Math.abs(f) > 1 && (Math.abs(f + y) === 1 ? f += y : Math.abs(f - y) === 1 && (f -= y)), u.dem && o.dem && (o.dem.backfillBorder(u.dem, f, g), o.neighboringTiles && o.neighboringTiles[x] && (o.neighboringTiles[x].backfilled = !0)));
                        }
                    }
                    getTile(e) {
                        return this.getTileByID(e.key);
                    }
                    getTileByID(e) {
                        return this._tiles[e];
                    }
                    _retainLoadedChildren(e, i, s, o) {
                        for (const u in this._tiles) {
                            let f = this._tiles[u];
                            if (o[u] || !f.hasData() || f.tileID.overscaledZ <= i || f.tileID.overscaledZ > s) continue;
                            let g = f.tileID;
                            for (; f && f.tileID.overscaledZ > i + 1;) {
                                const x = f.tileID.scaledTo(f.tileID.overscaledZ - 1);
                                f = this._tiles[x.key], f && f.hasData() && (g = x);
                            }
                            let y = g;
                            for (; y.overscaledZ > i;) if (y = y.scaledTo(y.overscaledZ - 1), e[y.key] || e[y.canonical.key]) {
                                o[g.key] = g;
                                break;
                            }
                        }
                    }
                    findLoadedParent(e, i) {
                        if (e.key in this._loadedParentTiles) {
                            const s = this._loadedParentTiles[e.key];
                            return s && s.tileID.overscaledZ >= i ? s : null;
                        }
                        for (let s = e.overscaledZ - 1; s >= i; s--) {
                            const o = e.scaledTo(s), u = this._getLoadedTile(o);
                            if (u) return u;
                        }
                    }
                    findLoadedSibling(e) {
                        return this._getLoadedTile(e);
                    }
                    _getLoadedTile(e) {
                        const i = this._tiles[e.key];
                        return i && i.hasData() ? i : this._cache.getByKey(e.wrapped().key);
                    }
                    updateCacheSize(e) {
                        const i = Math.ceil(e.width / this._source.tileSize) + 1, s = Math.ceil(e.height / this._source.tileSize) + 1, o = Math.floor(i * s * (this._maxTileCacheZoomLevels === null ? c.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), u = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, o) : o;
                        this._cache.setMaxSize(u);
                    }
                    handleWrapJump(e) {
                        const i = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
                        if (this._prevLng = e, i) {
                            const s = {};
                            for (const o in this._tiles) {
                                const u = this._tiles[o];
                                u.tileID = u.tileID.unwrapTo(u.tileID.wrap + i), s[u.tileID.key] = u;
                            }
                            this._tiles = s;
                            for (const o in this._timers) clearTimeout(this._timers[o]), delete this._timers[o];
                            for (const o in this._tiles) this._setTileReloadTimer(o, this._tiles[o]);
                        }
                    }
                    _updateCoveredAndRetainedTiles(e, i, s, o, u, f) {
                        const g = {}, y = {}, x = Object.keys(e), w = Ue.now();
                        for (const P of x) {
                            const T = e[P], z = this._tiles[P];
                            if (!z || z.fadeEndTime !== 0 && z.fadeEndTime <= w) continue;
                            const R = this.findLoadedParent(T, i), V = this.findLoadedSibling(T), U = R || V || null;
                            U && (this._addTile(U.tileID), g[U.tileID.key] = U.tileID), y[P] = T;
                        }
                        this._retainLoadedChildren(y, o, s, e);
                        for (const P in g) e[P] || (this._coveredTiles[P] = !0, e[P] = g[P]);
                        if (f) {
                            const P = {}, T = {};
                            for (const z of u) this._tiles[z.key].hasData() ? P[z.key] = z : T[z.key] = z;
                            for (const z in T) {
                                const R = T[z].children(this._source.maxzoom);
                                this._tiles[R[0].key] && this._tiles[R[1].key] && this._tiles[R[2].key] && this._tiles[R[3].key] && (P[R[0].key] = e[R[0].key] = R[0], P[R[1].key] = e[R[1].key] = R[1], P[R[2].key] = e[R[2].key] = R[2], P[R[3].key] = e[R[3].key] = R[3], delete T[z]);
                            }
                            for (const z in T) {
                                const R = T[z], V = this.findLoadedParent(R, this._source.minzoom), U = this.findLoadedSibling(R), Z = V || U || null;
                                if (Z) {
                                    P[Z.tileID.key] = e[Z.tileID.key] = Z.tileID;
                                    for (const q in P) P[q].isChildOf(Z.tileID) && delete P[q];
                                }
                            }
                            for (const z in this._tiles) P[z] || (this._coveredTiles[z] = !0);
                        }
                    }
                    update(e, i) {
                        if (!this._sourceLoaded || this._paused) return;
                        let s;
                        this.transform = e, this.terrain = i, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? s = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((w) => new c.Y(w.canonical.z, w.wrap, w.canonical.z, w.canonical.x, w.canonical.y)) : (s = ne(e, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (s = s.filter((w) => this._source.hasTile(w)))) : s = [];
                        const o = pe(e, this._source), u = Math.max(o - ce.maxOverzooming, this._source.minzoom), f = Math.max(o + ce.maxUnderzooming, this._source.minzoom);
                        if (this.usedForTerrain) {
                            const w = {};
                            for (const P of s) if (P.canonical.z > this._source.minzoom) {
                                const T = P.scaledTo(P.canonical.z - 1);
                                w[T.key] = T;
                                const z = P.scaledTo(Math.max(this._source.minzoom, Math.min(P.canonical.z, 5)));
                                w[z.key] = z;
                            }
                            s = s.concat(Object.values(w));
                        }
                        const g = s.length === 0 && !this._updated && this._didEmitContent;
                        this._updated = !0, g && this.fire(new c.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
                        const y = this._updateRetainedTiles(s, o);
                        le(this._source.type) && this._updateCoveredAndRetainedTiles(y, u, f, o, s, i);
                        for (const w in y) this._tiles[w].clearFadeHold();
                        const x = c.aj(this._tiles, y);
                        for (const w of x) {
                            const P = this._tiles[w];
                            P.hasSymbolBuckets && !P.holdingForFade() ? P.setHoldDuration(this.map._fadeDuration) : P.hasSymbolBuckets && !P.symbolFadeFinished() || this._removeTile(w);
                        }
                        this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
                    }
                    releaseSymbolFadeTiles() {
                        for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
                    }
                    _updateRetainedTiles(e, i) {
                        var s;
                        const o = {}, u = {}, f = Math.max(i - ce.maxOverzooming, this._source.minzoom), g = Math.max(i + ce.maxUnderzooming, this._source.minzoom), y = {};
                        for (const x of e) {
                            const w = this._addTile(x);
                            o[x.key] = x, w.hasData() || i < this._source.maxzoom && (y[x.key] = x);
                        }
                        this._retainLoadedChildren(y, i, g, o);
                        for (const x of e) {
                            let w = this._tiles[x.key];
                            if (w.hasData()) continue;
                            if (i + 1 > this._source.maxzoom) {
                                const T = x.children(this._source.maxzoom)[0], z = this.getTile(T);
                                if (z && z.hasData()) {
                                    o[T.key] = T;
                                    continue;
                                }
                            } else {
                                const T = x.children(this._source.maxzoom);
                                if (o[T[0].key] && o[T[1].key] && o[T[2].key] && o[T[3].key]) continue;
                            }
                            let P = w.wasRequested();
                            for (let T = x.overscaledZ - 1; T >= f; --T) {
                                const z = x.scaledTo(T);
                                if (u[z.key]) break;
                                if (u[z.key] = !0, w = this.getTile(z), !w && P && (w = this._addTile(z)), w) {
                                    const R = w.hasData();
                                    if ((R || !(!((s = this.map) === null || s === void 0) && s.cancelPendingTileRequestsWhileZooming) || P) && (o[z.key] = z), P = w.wasRequested(), R) break;
                                }
                            }
                        }
                        return o;
                    }
                    _updateLoadedParentTileCache() {
                        this._loadedParentTiles = {};
                        for (const e in this._tiles) {
                            const i = [];
                            let s, o = this._tiles[e].tileID;
                            for (; o.overscaledZ > 0;) {
                                if (o.key in this._loadedParentTiles) {
                                    s = this._loadedParentTiles[o.key];
                                    break;
                                }
                                i.push(o.key);
                                const u = o.scaledTo(o.overscaledZ - 1);
                                if (s = this._getLoadedTile(u), s) break;
                                o = u;
                            }
                            for (const u of i) this._loadedParentTiles[u] = s;
                        }
                    }
                    _updateLoadedSiblingTileCache() {
                        this._loadedSiblingTiles = {};
                        for (const e in this._tiles) {
                            const i = this._tiles[e].tileID, s = this._getLoadedTile(i);
                            this._loadedSiblingTiles[i.key] = s;
                        }
                    }
                    _addTile(e) {
                        let i = this._tiles[e.key];
                        if (i) return i;
                        i = this._cache.getAndRemove(e), i && (this._setTileReloadTimer(e.key, i), i.tileID = e, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, i)));
                        const s = i;
                        return i || (i = new Pr(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(i, e.key, i.state)), i.uses++, this._tiles[e.key] = i, s || this._source.fire(new c.l("dataloading", { tile: i, coord: i.tileID, dataType: "source" })), i;
                    }
                    _setTileReloadTimer(e, i) {
                        e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
                        const s = i.getExpiryTimeout();
                        s && (this._timers[e] = setTimeout(() => {
                            this._reloadTile(e, "expired"), delete this._timers[e];
                        }, s));
                    }
                    refreshTiles(e) {
                        for (const i in this._tiles) this._isIdRenderable(i) && e.some((s) => s.equals(this._tiles[i].tileID.canonical)) && this._reloadTile(i, "expired");
                    }
                    _removeTile(e) {
                        const i = this._tiles[e];
                        i && (i.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), i.uses > 0 || (i.hasData() && i.state !== "reloading" ? this._cache.add(i.tileID, i, i.getExpiryTimeout()) : (i.aborted = !0, this._abortTile(i), this._unloadTile(i))));
                    }
                    _dataHandler(e) {
                        const i = e.sourceDataType;
                        e.dataType === "source" && i === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && e.dataType === "source" && i === "content" && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
                    }
                    clearTiles() {
                        this._shouldReloadOnResume = !1, this._paused = !1;
                        for (const e in this._tiles) this._removeTile(e);
                        this._cache.reset();
                    }
                    tilesIn(e, i, s) {
                        const o = [], u = this.transform;
                        if (!u) return o;
                        const f = s ? u.getCameraQueryGeometry(e) : e, g = e.map((R) => u.screenPointToMercatorCoordinate(R, this.terrain)), y = f.map((R) => u.screenPointToMercatorCoordinate(R, this.terrain)), x = this.getIds();
                        let w = 1 / 0, P = 1 / 0, T = -1 / 0, z = -1 / 0;
                        for (const R of y) w = Math.min(w, R.x), P = Math.min(P, R.y), T = Math.max(T, R.x), z = Math.max(z, R.y);
                        for (let R = 0; R < x.length; R++) {
                            const V = this._tiles[x[R]];
                            if (V.holdingForFade()) continue;
                            const U = u.getCoveringTilesDetailsProvider().allowWorldCopies() ? V.tileID : V.tileID.unwrapTo(0), Z = Math.pow(2, u.zoom - V.tileID.overscaledZ), q = i * V.queryPadding * c.Z / V.tileSize / Z, J = [U.getTilePoint(new c.$(w, P)), U.getTilePoint(new c.$(T, z))];
                            if (J[0].x - q < c.Z && J[0].y - q < c.Z && J[1].x + q >= 0 && J[1].y + q >= 0) {
                                const Y = g.map((ae) => U.getTilePoint(ae)), ee = y.map((ae) => U.getTilePoint(ae));
                                o.push({ tile: V, tileID: U, queryGeometry: Y, cameraQueryGeometry: ee, scale: Z });
                            }
                        }
                        return o;
                    }
                    getVisibleCoordinates(e) {
                        const i = this.getRenderableIds(e).map((s) => this._tiles[s].tileID);
                        return this.transform && this.transform.populateCache(i), i;
                    }
                    hasTransition() {
                        if (this._source.hasTransition()) return !0;
                        if (le(this._source.type)) {
                            const e = Ue.now();
                            for (const i in this._tiles) if (this._tiles[i].fadeEndTime >= e) return !0;
                        }
                        return !1;
                    }
                    setFeatureState(e, i, s) {
                        this._state.updateState(e = e || "_geojsonTileLayer", i, s);
                    }
                    removeFeatureState(e, i, s) {
                        this._state.removeFeatureState(e = e || "_geojsonTileLayer", i, s);
                    }
                    getFeatureState(e, i) {
                        return this._state.getState(e = e || "_geojsonTileLayer", i);
                    }
                    setDependencies(e, i, s) {
                        const o = this._tiles[e];
                        o && o.setDependencies(i, s);
                    }
                    reloadTilesForDependencies(e, i) {
                        for (const s in this._tiles) this._tiles[s].hasDependency(e, i) && this._reloadTile(s, "reloading");
                        this._cache.filter((s) => !s.hasDependency(e, i));
                    }
                }
                function fe(h, e) {
                    const i = Math.abs(2 * h.wrap) - +(h.wrap < 0), s = Math.abs(2 * e.wrap) - +(e.wrap < 0);
                    return h.overscaledZ - e.overscaledZ || s - i || e.canonical.y - h.canonical.y || e.canonical.x - h.canonical.x;
                }
                function le(h) {
                    return h === "raster" || h === "image" || h === "video";
                }
                ce.maxOverzooming = 10, ce.maxUnderzooming = 3;
                class Pe {
                    constructor(e, i) {
                        this.reset(e, i);
                    }
                    reset(e, i) {
                        this.points = e || [], this._distances = [0];
                        for (let s = 1; s < this.points.length; s++) this._distances[s] = this._distances[s - 1] + this.points[s].dist(this.points[s - 1]);
                        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(i || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
                    }
                    lerp(e) {
                        if (this.points.length === 1) return this.points[0];
                        e = c.ae(e, 0, 1);
                        let i = 1, s = this._distances[i];
                        const o = e * this.paddedLength + this.padding;
                        for (; s < o && i < this._distances.length;) s = this._distances[++i];
                        const u = i - 1, f = this._distances[u], g = s - f, y = g > 0 ? (o - f) / g : 0;
                        return this.points[u].mult(1 - y).add(this.points[i].mult(y));
                    }
                }
                function Re(h, e) {
                    let i = !0;
                    return h === "always" || h !== "never" && e !== "never" || (i = !1), i;
                }
                class De {
                    constructor(e, i, s) {
                        const o = this.boxCells = [], u = this.circleCells = [];
                        this.xCellCount = Math.ceil(e / s), this.yCellCount = Math.ceil(i / s);
                        for (let f = 0; f < this.xCellCount * this.yCellCount; f++) o.push([]), u.push([]);
                        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = i, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / i, this.boxUid = 0, this.circleUid = 0;
                    }
                    keysLength() {
                        return this.boxKeys.length + this.circleKeys.length;
                    }
                    insert(e, i, s, o, u) {
                        this._forEachCell(i, s, o, u, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(i), this.bboxes.push(s), this.bboxes.push(o), this.bboxes.push(u);
                    }
                    insertCircle(e, i, s, o) {
                        this._forEachCell(i - o, s - o, i + o, s + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(i), this.circles.push(s), this.circles.push(o);
                    }
                    _insertBoxCell(e, i, s, o, u, f) {
                        this.boxCells[u].push(f);
                    }
                    _insertCircleCell(e, i, s, o, u, f) {
                        this.circleCells[u].push(f);
                    }
                    _query(e, i, s, o, u, f, g) {
                        if (s < 0 || e > this.width || o < 0 || i > this.height) return [];
                        const y = [];
                        if (e <= 0 && i <= 0 && this.width <= s && this.height <= o) {
                            if (u) return [{ key: null, x1: e, y1: i, x2: s, y2: o }];
                            for (let x = 0; x < this.boxKeys.length; x++) y.push({ key: this.boxKeys[x], x1: this.bboxes[4 * x], y1: this.bboxes[4 * x + 1], x2: this.bboxes[4 * x + 2], y2: this.bboxes[4 * x + 3] });
                            for (let x = 0; x < this.circleKeys.length; x++) {
                                const w = this.circles[3 * x], P = this.circles[3 * x + 1], T = this.circles[3 * x + 2];
                                y.push({ key: this.circleKeys[x], x1: w - T, y1: P - T, x2: w + T, y2: P + T });
                            }
                        } else this._forEachCell(e, i, s, o, this._queryCell, y, { hitTest: u, overlapMode: f, seenUids: { box: {}, circle: {} } }, g);
                        return y;
                    }
                    query(e, i, s, o) {
                        return this._query(e, i, s, o, !1, null);
                    }
                    hitTest(e, i, s, o, u, f) {
                        return this._query(e, i, s, o, !0, u, f).length > 0;
                    }
                    hitTestCircle(e, i, s, o, u) {
                        const f = e - s, g = e + s, y = i - s, x = i + s;
                        if (g < 0 || f > this.width || x < 0 || y > this.height) return !1;
                        const w = [];
                        return this._forEachCell(f, y, g, x, this._queryCellCircle, w, { hitTest: !0, overlapMode: o, circle: { x: e, y: i, radius: s }, seenUids: { box: {}, circle: {} } }, u), w.length > 0;
                    }
                    _queryCell(e, i, s, o, u, f, g, y) {
                        const { seenUids: x, hitTest: w, overlapMode: P } = g, T = this.boxCells[u];
                        if (T !== null) {
                            const R = this.bboxes;
                            for (const V of T) if (!x.box[V]) {
                                x.box[V] = !0;
                                const U = 4 * V, Z = this.boxKeys[V];
                                if (e <= R[U + 2] && i <= R[U + 3] && s >= R[U + 0] && o >= R[U + 1] && (!y || y(Z)) && (!w || !Re(P, Z.overlapMode)) && (f.push({ key: Z, x1: R[U], y1: R[U + 1], x2: R[U + 2], y2: R[U + 3] }), w)) return !0;
                            }
                        }
                        const z = this.circleCells[u];
                        if (z !== null) {
                            const R = this.circles;
                            for (const V of z) if (!x.circle[V]) {
                                x.circle[V] = !0;
                                const U = 3 * V, Z = this.circleKeys[V];
                                if (this._circleAndRectCollide(R[U], R[U + 1], R[U + 2], e, i, s, o) && (!y || y(Z)) && (!w || !Re(P, Z.overlapMode))) {
                                    const q = R[U], J = R[U + 1], Y = R[U + 2];
                                    if (f.push({ key: Z, x1: q - Y, y1: J - Y, x2: q + Y, y2: J + Y }), w) return !0;
                                }
                            }
                        }
                        return !1;
                    }
                    _queryCellCircle(e, i, s, o, u, f, g, y) {
                        const { circle: x, seenUids: w, overlapMode: P } = g, T = this.boxCells[u];
                        if (T !== null) {
                            const R = this.bboxes;
                            for (const V of T) if (!w.box[V]) {
                                w.box[V] = !0;
                                const U = 4 * V, Z = this.boxKeys[V];
                                if (this._circleAndRectCollide(x.x, x.y, x.radius, R[U + 0], R[U + 1], R[U + 2], R[U + 3]) && (!y || y(Z)) && !Re(P, Z.overlapMode)) return f.push(!0), !0;
                            }
                        }
                        const z = this.circleCells[u];
                        if (z !== null) {
                            const R = this.circles;
                            for (const V of z) if (!w.circle[V]) {
                                w.circle[V] = !0;
                                const U = 3 * V, Z = this.circleKeys[V];
                                if (this._circlesCollide(R[U], R[U + 1], R[U + 2], x.x, x.y, x.radius) && (!y || y(Z)) && !Re(P, Z.overlapMode)) return f.push(!0), !0;
                            }
                        }
                    }
                    _forEachCell(e, i, s, o, u, f, g, y) {
                        const x = this._convertToXCellCoord(e), w = this._convertToYCellCoord(i), P = this._convertToXCellCoord(s), T = this._convertToYCellCoord(o);
                        for (let z = x; z <= P; z++) for (let R = w; R <= T; R++) if (u.call(this, e, i, s, o, this.xCellCount * R + z, f, g, y)) return;
                    }
                    _convertToXCellCoord(e) {
                        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
                    }
                    _convertToYCellCoord(e) {
                        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
                    }
                    _circlesCollide(e, i, s, o, u, f) {
                        const g = o - e, y = u - i, x = s + f;
                        return x * x > g * g + y * y;
                    }
                    _circleAndRectCollide(e, i, s, o, u, f, g) {
                        const y = (f - o) / 2, x = Math.abs(e - (o + y));
                        if (x > y + s) return !1;
                        const w = (g - u) / 2, P = Math.abs(i - (u + w));
                        if (P > w + s) return !1;
                        if (x <= y || P <= w) return !0;
                        const T = x - y, z = P - w;
                        return T * T + z * z <= s * s;
                    }
                }
                function Ze(h, e, i) {
                    const s = c.K();
                    if (!h) {
                        const { vecSouth: P, vecEast: T } = Xe(e), z = ht();
                        z[0] = T[0], z[1] = T[1], z[2] = P[0], z[3] = P[1], o = z, (w = (f = (u = z)[0]) * (x = u[3]) - (y = u[2]) * (g = u[1])) && (o[0] = x * (w = 1 / w), o[1] = -g * w, o[2] = -y * w, o[3] = f * w), s[0] = z[0], s[1] = z[1], s[4] = z[2], s[5] = z[3];
                    }
                    var o, u, f, g, y, x, w;
                    return c.M(s, s, [1 / i, 1 / i, 1]), s;
                }
                function Ye(h, e, i, s) {
                    if (h) {
                        const o = c.K();
                        if (!e) {
                            const { vecSouth: u, vecEast: f } = Xe(i);
                            o[0] = f[0], o[1] = f[1], o[4] = u[0], o[5] = u[1];
                        }
                        return c.M(o, o, [s, s, 1]), o;
                    }
                    return i.pixelsToClipSpaceMatrix;
                }
                function Xe(h) {
                    const e = Math.cos(h.rollInRadians), i = Math.sin(h.rollInRadians), s = Math.cos(h.pitchInRadians), o = Math.cos(h.bearingInRadians), u = Math.sin(h.bearingInRadians), f = c.ao();
                    f[0] = -o * s * i - u * e, f[1] = -u * s * i + o * e;
                    const g = c.ap(f);
                    g < 1e-9 ? c.aq(f) : c.ar(f, f, 1 / g);
                    const y = c.ao();
                    y[0] = o * s * e - u * i, y[1] = u * s * e + o * i;
                    const x = c.ap(y);
                    return x < 1e-9 ? c.aq(y) : c.ar(y, y, 1 / x), { vecEast: y, vecSouth: f };
                }
                function ve(h, e, i, s) {
                    let o;
                    s ? (o = [h, e, s(h, e), 1], c.at(o, o, i)) : (o = [h, e, 0, 1], aa(o, o, i));
                    const u = o[3];
                    return { point: new c.P(o[0] / u, o[1] / u), signedDistanceFromCamera: u, isOccluded: !1 };
                }
                function gt(h, e) {
                    return 0.5 + h / e * 0.5;
                }
                function nt(h, e) {
                    return h.x >= -e[0] && h.x <= e[0] && h.y >= -e[1] && h.y <= e[1];
                }
                function dt(h, e, i, s, o, u, f, g, y, x, w, P, T) {
                    const z = i ? h.textSizeData : h.iconSizeData, R = c.ak(z, e.transform.zoom), V = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1], U = i ? h.text.dynamicLayoutVertexArray : h.icon.dynamicLayoutVertexArray;
                    U.clear();
                    const Z = h.lineVertexArray, q = i ? h.text.placedSymbolArray : h.icon.placedSymbolArray, J = e.transform.width / e.transform.height;
                    let Y = !1;
                    for (let ee = 0; ee < q.length; ee++) {
                        const ae = q.get(ee);
                        if (ae.hidden || ae.writingMode === c.al.vertical && !Y) {
                            Mr(ae.numGlyphs, U);
                            continue;
                        }
                        Y = !1;
                        const te = new c.P(ae.anchorX, ae.anchorY), he = { getElevation: T, pitchedLabelPlaneMatrix: s, lineVertexArray: Z, pitchWithMap: u, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: e.transform, tileAnchorPoint: te, unwrappedTileID: y, width: x, height: w, translation: P }, be = Qe(ae.anchorX, ae.anchorY, he);
                        if (!nt(be.point, V)) {
                            Mr(ae.numGlyphs, U);
                            continue;
                        }
                        const ge = gt(e.transform.cameraToCenterDistance, be.signedDistanceFromCamera), _e = c.am(z, R, ae), ye = u ? _e * e.transform.getPitchedTextCorrection(ae.anchorX, ae.anchorY, y) / ge : _e * ge, Ee = qe({ projectionContext: he, pitchedLabelPlaneMatrixInverse: o, symbol: ae, fontSize: ye, flip: !1, keepUpright: f, glyphOffsetArray: h.glyphOffsetArray, dynamicLayoutVertexArray: U, aspectRatio: J, rotateToLine: g });
                        Y = Ee.useVertical, (Ee.notEnoughRoom || Y || Ee.needsFlipping && qe({ projectionContext: he, pitchedLabelPlaneMatrixInverse: o, symbol: ae, fontSize: ye, flip: !0, keepUpright: f, glyphOffsetArray: h.glyphOffsetArray, dynamicLayoutVertexArray: U, aspectRatio: J, rotateToLine: g }).notEnoughRoom) && Mr(ae.numGlyphs, U);
                    }
                    i ? h.text.dynamicLayoutVertexBuffer.updateData(U) : h.icon.dynamicLayoutVertexBuffer.updateData(U);
                }
                function We(h, e, i, s, o, u, f, g) {
                    const y = u.glyphStartIndex + u.numGlyphs, x = u.lineStartIndex, w = u.lineStartIndex + u.lineLength, P = e.getoffsetX(u.glyphStartIndex), T = e.getoffsetX(y - 1), z = ra(h * P, i, s, o, u.segment, x, w, g, f);
                    if (!z) return null;
                    const R = ra(h * T, i, s, o, u.segment, x, w, g, f);
                    return R ? g.projectionCache.anyProjectionOccluded ? null : { first: z, last: R } : null;
                }
                function Se(h, e, i, s) {
                    return h === c.al.horizontal && Math.abs(i.y - e.y) > Math.abs(i.x - e.x) * s ? { useVertical: !0 } : (h === c.al.vertical ? e.y < i.y : e.x > i.x) ? { needsFlipping: !0 } : null;
                }
                function qe(h) {
                    const { projectionContext: e, pitchedLabelPlaneMatrixInverse: i, symbol: s, fontSize: o, flip: u, keepUpright: f, glyphOffsetArray: g, dynamicLayoutVertexArray: y, aspectRatio: x, rotateToLine: w } = h, P = o / 24, T = s.lineOffsetX * P, z = s.lineOffsetY * P;
                    let R;
                    if (s.numGlyphs > 1) {
                        const V = s.glyphStartIndex + s.numGlyphs, U = s.lineStartIndex, Z = s.lineStartIndex + s.lineLength, q = We(P, g, T, z, u, s, w, e);
                        if (!q) return { notEnoughRoom: !0 };
                        const J = ki(q.first.point.x, q.first.point.y, e, i), Y = ki(q.last.point.x, q.last.point.y, e, i);
                        if (f && !u) {
                            const ee = Se(s.writingMode, J, Y, x);
                            if (ee) return ee;
                        }
                        R = [q.first];
                        for (let ee = s.glyphStartIndex + 1; ee < V - 1; ee++) R.push(ra(P * g.getoffsetX(ee), T, z, u, s.segment, U, Z, e, w));
                        R.push(q.last);
                    } else {
                        if (f && !u) {
                            const U = Bt(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point, Z = s.lineStartIndex + s.segment + 1, q = new c.P(e.lineVertexArray.getx(Z), e.lineVertexArray.gety(Z)), J = Bt(q.x, q.y, e), Y = J.signedDistanceFromCamera > 0 ? J.point : Je(e.tileAnchorPoint, q, U, 1, e), ee = ki(U.x, U.y, e, i), ae = ki(Y.x, Y.y, e, i), te = Se(s.writingMode, ee, ae, x);
                            if (te) return te;
                        }
                        const V = ra(P * g.getoffsetX(s.glyphStartIndex), T, z, u, s.segment, s.lineStartIndex, s.lineStartIndex + s.lineLength, e, w);
                        if (!V || e.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
                        R = [V];
                    }
                    for (const V of R) c.as(y, V.point, V.angle);
                    return {};
                }
                function Je(h, e, i, s, o) {
                    const u = h.add(h.sub(e)._unit()), f = Bt(u.x, u.y, o).point, g = i.sub(f);
                    return i.add(g._mult(s / g.mag()));
                }
                function Lt(h, e, i) {
                    const s = e.projectionCache;
                    if (s.projections[h]) return s.projections[h];
                    const o = new c.P(e.lineVertexArray.getx(h), e.lineVertexArray.gety(h)), u = Bt(o.x, o.y, e);
                    if (u.signedDistanceFromCamera > 0) return s.projections[h] = u.point, s.anyProjectionOccluded = s.anyProjectionOccluded || u.isOccluded, u.point;
                    const f = h - i.direction;
                    return Je(i.distanceFromAnchor === 0 ? e.tileAnchorPoint : new c.P(e.lineVertexArray.getx(f), e.lineVertexArray.gety(f)), o, i.previousVertex, i.absOffsetX - i.distanceFromAnchor + 1, e);
                }
                function Bt(h, e, i) {
                    const s = h + i.translation[0], o = e + i.translation[1];
                    let u;
                    return i.pitchWithMap ? (u = ve(s, o, i.pitchedLabelPlaneMatrix, i.getElevation), u.isOccluded = !1) : (u = i.transform.projectTileCoordinates(s, o, i.unwrappedTileID, i.getElevation), u.point.x = (0.5 * u.point.x + 0.5) * i.width, u.point.y = (0.5 * -u.point.y + 0.5) * i.height), u;
                }
                function ki(h, e, i, s) {
                    if (i.pitchWithMap) {
                        const o = [h, e, 0, 1];
                        return c.at(o, o, s), i.transform.projectTileCoordinates(o[0] / o[3], o[1] / o[3], i.unwrappedTileID, i.getElevation).point;
                    }
                    return { x: h / i.width * 2 - 1, y: e / i.height * 2 - 1 };
                }
                function Qe(h, e, i) {
                    return i.transform.projectTileCoordinates(h, e, i.unwrappedTileID, i.getElevation);
                }
                function ka(h, e, i) {
                    return h._unit()._perp()._mult(e * i);
                }
                function fn(h, e, i, s, o, u, f, g, y) {
                    if (g.projectionCache.offsets[h]) return g.projectionCache.offsets[h];
                    const x = i.add(e);
                    if (h + y.direction < s || h + y.direction >= o) return g.projectionCache.offsets[h] = x, x;
                    const w = Lt(h + y.direction, g, y), P = ka(w.sub(i), f, y.direction), T = i.add(P), z = w.add(P);
                    return g.projectionCache.offsets[h] = c.au(u, x, T, z) || x, g.projectionCache.offsets[h];
                }
                function ra(h, e, i, s, o, u, f, g, y) {
                    const x = s ? h - e : h + e;
                    let w = x > 0 ? 1 : -1, P = 0;
                    s && (w *= -1, P = Math.PI), w < 0 && (P += Math.PI);
                    let T, z = w > 0 ? u + o : u + o + 1;
                    g.projectionCache.cachedAnchorPoint ? T = g.projectionCache.cachedAnchorPoint : (T = Bt(g.tileAnchorPoint.x, g.tileAnchorPoint.y, g).point, g.projectionCache.cachedAnchorPoint = T);
                    let R, V, U = T, Z = T, q = 0, J = 0;
                    const Y = Math.abs(x), ee = [];
                    let ae;
                    for (; q + J <= Y;) {
                        if (z += w, z < u || z >= f) return null;
                        q += J, Z = U, V = R;
                        const be = { absOffsetX: Y, direction: w, distanceFromAnchor: q, previousVertex: Z };
                        if (U = Lt(z, g, be), i === 0) ee.push(Z), ae = U.sub(Z);
                        else {
                            let ge;
                            const _e = U.sub(Z);
                            ge = _e.mag() === 0 ? ka(Lt(z + w, g, be).sub(U), i, w) : ka(_e, i, w), V || (V = Z.add(ge)), R = fn(z, ge, U, u, f, V, i, g, be), ee.push(V), ae = R.sub(V);
                        }
                        J = ae.mag();
                    }
                    const te = ae._mult((Y - q) / J)._add(V || Z), he = P + Math.atan2(U.y - Z.y, U.x - Z.x);
                    return ee.push(te), { point: te, angle: y ? he : 0, path: ee };
                }
                const mn = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
                function Mr(h, e) {
                    for (let i = 0; i < h; i++) {
                        const s = e.length;
                        e.resize(s + 4), e.float32.set(mn, 3 * s);
                    }
                }
                function aa(h, e, i) {
                    const s = e[0], o = e[1];
                    return h[0] = i[0] * s + i[4] * o + i[12], h[1] = i[1] * s + i[5] * o + i[13], h[3] = i[3] * s + i[7] * o + i[15], h;
                }
                const $t = 100;
                class Ni {
                    constructor(e, i = new De(e.width + 200, e.height + 200, 25), s = new De(e.width + 200, e.height + 200, 25)) {
                        this.transform = e, this.grid = i, this.ignoredGrid = s, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + $t, this.screenBottomBoundary = e.height + $t, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = 0.6;
                    }
                    placeCollisionBox(e, i, s, o, u, f, g, y, x, w, P, T) {
                        const z = this.projectAndGetPerspectiveRatio(e.anchorPointX + y[0], e.anchorPointY + y[1], u, w, T), R = s * z.perspectiveRatio;
                        let V;
                        if (f || g) V = this._projectCollisionBox(e, R, o, u, f, g, y, z, w, P, T);
                        else {
                            const ae = z.x + (P ? P.x * R : 0), te = z.y + (P ? P.y * R : 0);
                            V = { allPointsOccluded: !1, box: [ae + e.x1 * R, te + e.y1 * R, ae + e.x2 * R, te + e.y2 * R] };
                        }
                        const [U, Z, q, J] = V.box, Y = f ? V.allPointsOccluded : z.isOccluded;
                        let ee = Y;
                        return ee || (ee = z.perspectiveRatio < this.perspectiveRatioCutoff), ee || (ee = !this.isInsideGrid(U, Z, q, J)), ee || i !== "always" && this.grid.hitTest(U, Z, q, J, i, x) ? { box: [U, Z, q, J], placeable: !1, offscreen: !1, occluded: Y } : { box: [U, Z, q, J], placeable: !0, offscreen: this.isOffscreen(U, Z, q, J), occluded: Y };
                    }
                    placeCollisionCircles(e, i, s, o, u, f, g, y, x, w, P, T, z, R) {
                        const V = [], U = new c.P(i.anchorX, i.anchorY), Z = this.getPerspectiveRatio(U.x, U.y, f, R), q = (x ? u * this.transform.getPitchedTextCorrection(i.anchorX, i.anchorY, f) / Z : u * Z) / c.ay, J = { getElevation: R, pitchedLabelPlaneMatrix: g, lineVertexArray: s, pitchWithMap: x, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: U, unwrappedTileID: f, width: this.transform.width, height: this.transform.height, translation: z }, Y = We(q, o, i.lineOffsetX * q, i.lineOffsetY * q, !1, i, !1, J);
                        let ee = !1, ae = !1, te = !0;
                        if (Y) {
                            const he = 0.5 * P * Z + T, be = new c.P(-100, -100), ge = new c.P(this.screenRightBoundary, this.screenBottomBoundary), _e = new Pe(), ye = Y.first, Ee = Y.last;
                            let ze = [];
                            for (let tt = ye.path.length - 1; tt >= 1; tt--) ze.push(ye.path[tt]);
                            for (let tt = 1; tt < Ee.path.length; tt++) ze.push(Ee.path[tt]);
                            const Ce = 2.5 * he;
                            if (x) {
                                const tt = this.projectPathToScreenSpace(ze, J);
                                ze = tt.some((lt) => lt.signedDistanceFromCamera <= 0) ? [] : tt.map((lt) => lt.point);
                            }
                            let Ne = [];
                            if (ze.length > 0) {
                                const tt = ze[0].clone(), lt = ze[0].clone();
                                for (let At = 1; At < ze.length; At++) tt.x = Math.min(tt.x, ze[At].x), tt.y = Math.min(tt.y, ze[At].y), lt.x = Math.max(lt.x, ze[At].x), lt.y = Math.max(lt.y, ze[At].y);
                                Ne = tt.x >= be.x && lt.x <= ge.x && tt.y >= be.y && lt.y <= ge.y ? [ze] : lt.x < be.x || tt.x > ge.x || lt.y < be.y || tt.y > ge.y ? [] : c.av([ze], be.x, be.y, ge.x, ge.y);
                            }
                            for (const tt of Ne) {
                                _e.reset(tt, 0.25 * he);
                                let lt = 0;
                                lt = _e.length <= 0.5 * he ? 1 : Math.ceil(_e.paddedLength / Ce) + 1;
                                for (let At = 0; At < lt; At++) {
                                    const xt = At / Math.max(lt - 1, 1), kt = _e.lerp(xt), zt = kt.x + $t, wt = kt.y + $t;
                                    V.push(zt, wt, he, 0);
                                    const ft = zt - he, Kt = wt - he, ii = zt + he, ui = wt + he;
                                    if (te = te && this.isOffscreen(ft, Kt, ii, ui), ae = ae || this.isInsideGrid(ft, Kt, ii, ui), e !== "always" && this.grid.hitTestCircle(zt, wt, he, e, w) && (ee = !0, !y)) return { circles: [], offscreen: !1, collisionDetected: ee };
                                }
                            }
                        }
                        return { circles: !y && ee || !ae || Z < this.perspectiveRatioCutoff ? [] : V, offscreen: te, collisionDetected: ee };
                    }
                    projectPathToScreenSpace(e, i) {
                        const s = function (o, u) {
                            const f = c.K();
                            return c.an(f, u.pitchedLabelPlaneMatrix), o.map((g) => {
                                const y = ve(g.x, g.y, f, u.getElevation), x = u.transform.projectTileCoordinates(y.point.x, y.point.y, u.unwrappedTileID, u.getElevation);
                                return x.point.x = (0.5 * x.point.x + 0.5) * u.width, x.point.y = (0.5 * -x.point.y + 0.5) * u.height, x;
                            });
                        }(e, i);
                        return function (o) {
                            let u = 0, f = 0, g = 0, y = 0;
                            for (let x = 0; x < o.length; x++) o[x].isOccluded ? (g = x + 1, y = 0) : (y++, y > f && (f = y, u = g));
                            return o.slice(u, u + f);
                        }(s);
                    }
                    queryRenderedSymbols(e) {
                        if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
                        const i = [];
                        let s = 1 / 0, o = 1 / 0, u = -1 / 0, f = -1 / 0;
                        for (const w of e) {
                            const P = new c.P(w.x + $t, w.y + $t);
                            s = Math.min(s, P.x), o = Math.min(o, P.y), u = Math.max(u, P.x), f = Math.max(f, P.y), i.push(P);
                        }
                        const g = this.grid.query(s, o, u, f).concat(this.ignoredGrid.query(s, o, u, f)), y = {}, x = {};
                        for (const w of g) {
                            const P = w.key;
                            if (y[P.bucketInstanceId] === void 0 && (y[P.bucketInstanceId] = {}), y[P.bucketInstanceId][P.featureIndex]) continue;
                            const T = [new c.P(w.x1, w.y1), new c.P(w.x2, w.y1), new c.P(w.x2, w.y2), new c.P(w.x1, w.y2)];
                            c.aw(i, T) && (y[P.bucketInstanceId][P.featureIndex] = !0, x[P.bucketInstanceId] === void 0 && (x[P.bucketInstanceId] = []), x[P.bucketInstanceId].push(P.featureIndex));
                        }
                        return x;
                    }
                    insertCollisionBox(e, i, s, o, u, f) {
                        (s ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: o, featureIndex: u, collisionGroupID: f, overlapMode: i }, e[0], e[1], e[2], e[3]);
                    }
                    insertCollisionCircles(e, i, s, o, u, f) {
                        const g = s ? this.ignoredGrid : this.grid, y = { bucketInstanceId: o, featureIndex: u, collisionGroupID: f, overlapMode: i };
                        for (let x = 0; x < e.length; x += 4) g.insertCircle(y, e[x], e[x + 1], e[x + 2]);
                    }
                    projectAndGetPerspectiveRatio(e, i, s, o, u) {
                        if (u) {
                            let f;
                            o ? (f = [e, i, o(e, i), 1], c.at(f, f, u)) : (f = [e, i, 0, 1], aa(f, f, u));
                            const g = f[3];
                            return { x: (f[0] / g + 1) / 2 * this.transform.width + $t, y: (-f[1] / g + 1) / 2 * this.transform.height + $t, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / g * 0.5, isOccluded: !1, signedDistanceFromCamera: g };
                        }
                        {
                            const f = this.transform.projectTileCoordinates(e, i, s, o);
                            return { x: (f.point.x + 1) / 2 * this.transform.width + $t, y: (1 - f.point.y) / 2 * this.transform.height + $t, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / f.signedDistanceFromCamera * 0.5, isOccluded: f.isOccluded, signedDistanceFromCamera: f.signedDistanceFromCamera };
                        }
                    }
                    getPerspectiveRatio(e, i, s, o) {
                        const u = this.transform.projectTileCoordinates(e, i, s, o);
                        return 0.5 + this.transform.cameraToCenterDistance / u.signedDistanceFromCamera * 0.5;
                    }
                    isOffscreen(e, i, s, o) {
                        return s < $t || e >= this.screenRightBoundary || o < $t || i > this.screenBottomBoundary;
                    }
                    isInsideGrid(e, i, s, o) {
                        return s >= 0 && e < this.gridRightBoundary && o >= 0 && i < this.gridBottomBoundary;
                    }
                    getViewportMatrix() {
                        const e = c.ad([]);
                        return c.L(e, e, [-100, -100, 0]), e;
                    }
                    _projectCollisionBox(e, i, s, o, u, f, g, y, x, w, P) {
                        let T = 1, z = 0, R = 0, V = 1;
                        const U = e.anchorPointX + g[0], Z = e.anchorPointY + g[1];
                        if (f && !u) {
                            const ze = this.projectAndGetPerspectiveRatio(U + 1, Z, o, x, P), Ce = ze.x - y.x, Ne = Math.atan((ze.y - y.y) / Ce) + (Ce < 0 ? Math.PI : 0), tt = Math.sin(Ne), lt = Math.cos(Ne);
                            T = lt, z = tt, R = -tt, V = lt;
                        } else if (!f && u) {
                            const ze = Xe(this.transform);
                            T = ze.vecEast[0], z = ze.vecEast[1], R = ze.vecSouth[0], V = ze.vecSouth[1];
                        }
                        let q = y.x, J = y.y, Y = i;
                        u && (q = U, J = Z, Y = Math.pow(2, -(this.transform.zoom - s.overscaledZ)), Y *= this.transform.getPitchedTextCorrection(U, Z, o), w || (Y *= c.ae(0.5 + y.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), w && (q += T * w.x * Y + R * w.y * Y, J += z * w.x * Y + V * w.y * Y);
                        const ee = e.x1 * Y, ae = e.x2 * Y, te = (ee + ae) / 2, he = e.y1 * Y, be = e.y2 * Y, ge = (he + be) / 2, _e = [{ offsetX: ee, offsetY: he }, { offsetX: te, offsetY: he }, { offsetX: ae, offsetY: he }, { offsetX: ae, offsetY: ge }, { offsetX: ae, offsetY: be }, { offsetX: te, offsetY: be }, { offsetX: ee, offsetY: be }, { offsetX: ee, offsetY: ge }];
                        let ye = [];
                        for (const { offsetX: ze, offsetY: Ce } of _e) ye.push(new c.P(q + T * ze + R * Ce, J + z * ze + V * Ce));
                        let Ee = !1;
                        if (u) {
                            const ze = ye.map((Ce) => this.projectAndGetPerspectiveRatio(Ce.x, Ce.y, o, x, P));
                            Ee = ze.some((Ce) => !Ce.isOccluded), ye = ze.map((Ce) => new c.P(Ce.x, Ce.y));
                        } else Ee = !0;
                        return { box: c.ax(ye), allPointsOccluded: !Ee };
                    }
                }
                class It {
                    constructor(e, i, s, o) {
                        this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? i : -i))) : o && s ? 1 : 0, this.placed = s;
                    }
                    isHidden() {
                        return this.opacity === 0 && !this.placed;
                    }
                }
                class gn {
                    constructor(e, i, s, o, u) {
                        this.text = new It(e ? e.text : null, i, s, u), this.icon = new It(e ? e.icon : null, i, o, u);
                    }
                    isHidden() {
                        return this.text.isHidden() && this.icon.isHidden();
                    }
                }
                class za {
                    constructor(e, i, s) {
                        this.text = e, this.icon = i, this.skipFade = s;
                    }
                }
                class mo {
                    constructor(e, i, s, o, u) {
                        this.bucketInstanceId = e, this.featureIndex = i, this.sourceLayerIndex = s, this.bucketIndex = o, this.tileID = u;
                    }
                }
                class na {
                    constructor(e) {
                        this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
                    }
                    get(e) {
                        if (this.crossSourceCollisions) return { ID: 0, predicate: null };
                        if (!this.collisionGroups[e]) {
                            const i = ++this.maxGroupID;
                            this.collisionGroups[e] = { ID: i, predicate: (s) => s.collisionGroupID === i };
                        }
                        return this.collisionGroups[e];
                    }
                }
                function Ir(h, e, i, s, o) {
                    const { horizontalAlign: u, verticalAlign: f } = c.aE(h);
                    return new c.P(-(u - 0.5) * e + s[0] * o, -(f - 0.5) * i + s[1] * o);
                }
                class Ll {
                    constructor(e, i, s, o, u) {
                        this.transform = e.clone(), this.terrain = i, this.collisionIndex = new Ni(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = s, this.retainedQueryData = {}, this.collisionGroups = new na(o), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = u, u && (u.prevPlacement = void 0), this.placedOrientations = {};
                    }
                    _getTerrainElevationFunc(e) {
                        const i = this.terrain;
                        return i ? (s, o) => i.getElevation(e, s, o) : null;
                    }
                    getBucketParts(e, i, s, o) {
                        const u = s.getBucket(i), f = s.latestFeatureIndex;
                        if (!u || !f || i.id !== u.layerIds[0]) return;
                        const g = s.collisionBoxArray, y = u.layers[0].layout, x = u.layers[0].paint, w = Math.pow(2, this.transform.zoom - s.tileID.overscaledZ), P = s.tileSize / c.Z, T = s.tileID.toUnwrapped(), z = y.get("text-rotation-alignment") === "map", R = c.az(s, 1, this.transform.zoom), V = c.aA(this.collisionIndex.transform, s, x.get("text-translate"), x.get("text-translate-anchor")), U = c.aA(this.collisionIndex.transform, s, x.get("icon-translate"), x.get("icon-translate-anchor")), Z = Ze(z, this.transform, R);
                        this.retainedQueryData[u.bucketInstanceId] = new mo(u.bucketInstanceId, f, u.sourceLayerIndex, u.index, s.tileID);
                        const q = { bucket: u, layout: y, translationText: V, translationIcon: U, unwrappedTileID: T, pitchedLabelPlaneMatrix: Z, scale: w, textPixelRatio: P, holdingForFade: s.holdingForFade(), collisionBoxArray: g, partiallyEvaluatedTextSize: c.ak(u.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(u.sourceID) };
                        if (o) for (const J of u.sortKeyRanges) {
                            const { sortKey: Y, symbolInstanceStart: ee, symbolInstanceEnd: ae } = J;
                            e.push({ sortKey: Y, symbolInstanceStart: ee, symbolInstanceEnd: ae, parameters: q });
                        }
                        else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: u.symbolInstances.length, parameters: q });
                    }
                    attemptAnchorPlacement(e, i, s, o, u, f, g, y, x, w, P, T, z, R, V, U, Z, q, J, Y) {
                        const ee = c.aB[e.textAnchor], ae = [e.textOffset0, e.textOffset1], te = Ir(ee, s, o, ae, u), he = this.collisionIndex.placeCollisionBox(i, T, y, x, w, g, f, U, P.predicate, J, te, Y);
                        if ((!q || this.collisionIndex.placeCollisionBox(q, T, y, x, w, g, f, Z, P.predicate, J, te, Y).placeable) && he.placeable) {
                            let be;
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[z.crossTileID] && this.prevPlacement.placements[z.crossTileID] && this.prevPlacement.placements[z.crossTileID].text && (be = this.prevPlacement.variableOffsets[z.crossTileID].anchor), z.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                            return this.variableOffsets[z.crossTileID] = { textOffset: ae, width: s, height: o, anchor: ee, textBoxScale: u, prevAnchor: be }, this.markUsedJustification(R, ee, z, V), R.allowVerticalPlacement && (this.markUsedOrientation(R, V, z), this.placedOrientations[z.crossTileID] = V), { shift: te, placedGlyphBoxes: he };
                        }
                    }
                    placeLayerBucketPart(e, i, s) {
                        const { bucket: o, layout: u, translationText: f, translationIcon: g, unwrappedTileID: y, pitchedLabelPlaneMatrix: x, textPixelRatio: w, holdingForFade: P, collisionBoxArray: T, partiallyEvaluatedTextSize: z, collisionGroup: R } = e.parameters, V = u.get("text-optional"), U = u.get("icon-optional"), Z = c.aC(u, "text-overlap", "text-allow-overlap"), q = Z === "always", J = c.aC(u, "icon-overlap", "icon-allow-overlap"), Y = J === "always", ee = u.get("text-rotation-alignment") === "map", ae = u.get("text-pitch-alignment") === "map", te = u.get("icon-text-fit") !== "none", he = u.get("symbol-z-order") === "viewport-y", be = q && (Y || !o.hasIconData() || U), ge = Y && (q || !o.hasTextData() || V);
                        !o.collisionArrays && T && o.deserializeCollisionBoxes(T);
                        const _e = this.retainedQueryData[o.bucketInstanceId].tileID, ye = this._getTerrainElevationFunc(_e), Ee = this.transform.getFastPathSimpleProjectionMatrix(_e), ze = (Ce, Ne, tt) => {
                            var lt, At;
                            if (i[Ce.crossTileID]) return;
                            if (P) return void (this.placements[Ce.crossTileID] = new za(!1, !1, !1));
                            let xt = !1, kt = !1, zt = !0, wt = null, ft = { box: null, placeable: !1, offscreen: null, occluded: !1 }, Kt = { placeable: !1 }, ii = null, ui = null, mt = null, Zr = 0, xr = 0, Gr = 0;
                            Ne.textFeatureIndex ? Zr = Ne.textFeatureIndex : Ce.useRuntimeCollisionCircles && (Zr = Ce.featureIndex), Ne.verticalTextFeatureIndex && (xr = Ne.verticalTextFeatureIndex);
                            const va = Ne.textBox;
                            if (va) {
                                const $i = (qt) => {
                                    let Ht = c.al.horizontal;
                                    if (o.allowVerticalPlacement && !qt && this.prevPlacement) {
                                        const Ii = this.prevPlacement.placedOrientations[Ce.crossTileID];
                                        Ii && (this.placedOrientations[Ce.crossTileID] = Ii, Ht = Ii, this.markUsedOrientation(o, Ht, Ce));
                                    }
                                    return Ht;
                                }, Hr = (qt, Ht) => {
                                    if (o.allowVerticalPlacement && Ce.numVerticalGlyphVertices > 0 && Ne.verticalTextBox) {
                                        for (const Ii of o.writingModes) if (Ii === c.al.vertical ? (ft = Ht(), Kt = ft) : ft = qt(), ft && ft.placeable) break;
                                    } else ft = qt();
                                }, kr = Ce.textAnchorOffsetStartIndex, Wr = Ce.textAnchorOffsetEndIndex;
                                if (Wr === kr) {
                                    const qt = (Ht, Ii) => {
                                        const Pt = this.collisionIndex.placeCollisionBox(Ht, Z, w, _e, y, ae, ee, f, R.predicate, ye, void 0, Ee);
                                        return Pt && Pt.placeable && (this.markUsedOrientation(o, Ii, Ce), this.placedOrientations[Ce.crossTileID] = Ii), Pt;
                                    };
                                    Hr(() => qt(va, c.al.horizontal), () => {
                                        const Ht = Ne.verticalTextBox;
                                        return o.allowVerticalPlacement && Ce.numVerticalGlyphVertices > 0 && Ht ? qt(Ht, c.al.vertical) : { box: null, offscreen: null };
                                    }), $i(ft && ft.placeable);
                                } else {
                                    let qt = c.aB[(At = (lt = this.prevPlacement) === null || lt === void 0 ? void 0 : lt.variableOffsets[Ce.crossTileID]) === null || At === void 0 ? void 0 : At.anchor];
                                    const Ht = (Pt, Ks, Mc) => {
                                        const Ic = Pt.x2 - Pt.x1, Mh = Pt.y2 - Pt.y1, nl = Ce.textBoxScale, Wn = te && J === "never" ? Ks : null;
                                        let Ki = null, br = Z === "never" ? 1 : 2, Yi = "never";
                                        qt && br++;
                                        for (let zr = 0; zr < br; zr++) {
                                            for (let Ys = kr; Ys < Wr; Ys++) {
                                                const Xr = o.textAnchorOffsets.get(Ys);
                                                if (qt && Xr.textAnchor !== qt) continue;
                                                const sl = this.attemptAnchorPlacement(Xr, Pt, Ic, Mh, nl, ee, ae, w, _e, y, R, Yi, Ce, o, Mc, f, g, Wn, ye);
                                                if (sl && (Ki = sl.placedGlyphBoxes, Ki && Ki.placeable)) return xt = !0, wt = sl.shift, Ki;
                                            }
                                            qt ? qt = null : Yi = Z;
                                        }
                                        return s && !Ki && (Ki = { box: this.collisionIndex.placeCollisionBox(va, "always", w, _e, y, ae, ee, f, R.predicate, ye, void 0, Ee).box, offscreen: !1, placeable: !1, occluded: !1 }), Ki;
                                    };
                                    Hr(() => Ht(va, Ne.iconBox, c.al.horizontal), () => {
                                        const Pt = Ne.verticalTextBox;
                                        return o.allowVerticalPlacement && (!ft || !ft.placeable) && Ce.numVerticalGlyphVertices > 0 && Pt ? Ht(Pt, Ne.verticalIconBox, c.al.vertical) : { box: null, occluded: !0, offscreen: null };
                                    }), ft && (xt = ft.placeable, zt = ft.offscreen);
                                    const Ii = $i(ft && ft.placeable);
                                    if (!xt && this.prevPlacement) {
                                        const Pt = this.prevPlacement.variableOffsets[Ce.crossTileID];
                                        Pt && (this.variableOffsets[Ce.crossTileID] = Pt, this.markUsedJustification(o, Pt.anchor, Ce, Ii));
                                    }
                                }
                            }
                            if (ii = ft, xt = ii && ii.placeable, zt = ii && ii.offscreen, Ce.useRuntimeCollisionCircles) {
                                const $i = o.text.placedSymbolArray.get(Ce.centerJustifiedTextSymbolIndex), Hr = c.am(o.textSizeData, z, $i), kr = u.get("text-padding");
                                ui = this.collisionIndex.placeCollisionCircles(Z, $i, o.lineVertexArray, o.glyphOffsetArray, Hr, y, x, s, ae, R.predicate, Ce.collisionCircleDiameter, kr, f, ye), ui.circles.length && ui.collisionDetected && !s && c.w("Collisions detected, but collision boxes are not shown"), xt = q || ui.circles.length > 0 && !ui.collisionDetected, zt = zt && ui.offscreen;
                            }
                            if (Ne.iconFeatureIndex && (Gr = Ne.iconFeatureIndex), Ne.iconBox) {
                                const $i = (Hr) => this.collisionIndex.placeCollisionBox(Hr, J, w, _e, y, ae, ee, g, R.predicate, ye, te && wt ? wt : void 0, Ee);
                                Kt && Kt.placeable && Ne.verticalIconBox ? (mt = $i(Ne.verticalIconBox), kt = mt.placeable) : (mt = $i(Ne.iconBox), kt = mt.placeable), zt = zt && mt.offscreen;
                            }
                            const Hn = V || Ce.numHorizontalGlyphVertices === 0 && Ce.numVerticalGlyphVertices === 0, qr = U || Ce.numIconVertices === 0;
                            Hn || qr ? qr ? Hn || (kt = kt && xt) : xt = kt && xt : kt = xt = kt && xt;
                            const xa = kt && mt.placeable;
                            if (xt && ii.placeable && this.collisionIndex.insertCollisionBox(ii.box, Z, u.get("text-ignore-placement"), o.bucketInstanceId, Kt && Kt.placeable && xr ? xr : Zr, R.ID), xa && this.collisionIndex.insertCollisionBox(mt.box, J, u.get("icon-ignore-placement"), o.bucketInstanceId, Gr, R.ID), ui && xt && this.collisionIndex.insertCollisionCircles(ui.circles, Z, u.get("text-ignore-placement"), o.bucketInstanceId, Zr, R.ID), s && this.storeCollisionData(o.bucketInstanceId, tt, Ne, ii, mt, ui), Ce.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                            if (o.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
                            this.placements[Ce.crossTileID] = new za((xt || be) && !(ii != null && ii.occluded), (kt || ge) && !(mt != null && mt.occluded), zt || o.justReloaded), i[Ce.crossTileID] = !0;
                        };
                        if (he) {
                            if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
                            const Ce = o.getSortedSymbolIndexes(-this.transform.bearingInRadians);
                            for (let Ne = Ce.length - 1; Ne >= 0; --Ne) {
                                const tt = Ce[Ne];
                                ze(o.symbolInstances.get(tt), o.collisionArrays[tt], tt);
                            }
                        } else for (let Ce = e.symbolInstanceStart; Ce < e.symbolInstanceEnd; Ce++) ze(o.symbolInstances.get(Ce), o.collisionArrays[Ce], Ce);
                        o.justReloaded = !1;
                    }
                    storeCollisionData(e, i, s, o, u, f) {
                        if (s.textBox || s.iconBox) {
                            let g, y;
                            this.collisionBoxArrays.has(e) ? g = this.collisionBoxArrays.get(e) : (g = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, g)), g.has(i) ? y = g.get(i) : (y = { text: null, icon: null }, g.set(i, y)), s.textBox && (y.text = o.box), s.iconBox && (y.icon = u.box);
                        }
                        if (f) {
                            let g = this.collisionCircleArrays[e];
                            g === void 0 && (g = this.collisionCircleArrays[e] = []);
                            for (let y = 0; y < f.circles.length; y += 4) g.push(f.circles[y + 0] - $t), g.push(f.circles[y + 1] - $t), g.push(f.circles[y + 2]), g.push(f.collisionDetected ? 1 : 0);
                        }
                    }
                    markUsedJustification(e, i, s, o) {
                        let u;
                        u = o === c.al.vertical ? s.verticalPlacedTextSymbolIndex : { left: s.leftJustifiedTextSymbolIndex, center: s.centerJustifiedTextSymbolIndex, right: s.rightJustifiedTextSymbolIndex }[c.aD(i)];
                        const f = [s.leftJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.rightJustifiedTextSymbolIndex, s.verticalPlacedTextSymbolIndex];
                        for (const g of f) g >= 0 && (e.text.placedSymbolArray.get(g).crossTileID = u >= 0 && g !== u ? 0 : s.crossTileID);
                    }
                    markUsedOrientation(e, i, s) {
                        const o = i === c.al.horizontal || i === c.al.horizontalOnly ? i : 0, u = i === c.al.vertical ? i : 0, f = [s.leftJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.rightJustifiedTextSymbolIndex];
                        for (const g of f) e.text.placedSymbolArray.get(g).placedOrientation = o;
                        s.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(s.verticalPlacedTextSymbolIndex).placedOrientation = u);
                    }
                    commit(e) {
                        this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
                        const i = this.prevPlacement;
                        let s = !1;
                        this.prevZoomAdjustment = i ? i.zoomAdjustment(this.transform.zoom) : 0;
                        const o = i ? i.symbolFadeChange(e) : 1, u = i ? i.opacities : {}, f = i ? i.variableOffsets : {}, g = i ? i.placedOrientations : {};
                        for (const y in this.placements) {
                            const x = this.placements[y], w = u[y];
                            w ? (this.opacities[y] = new gn(w, o, x.text, x.icon), s = s || x.text !== w.text.placed || x.icon !== w.icon.placed) : (this.opacities[y] = new gn(null, o, x.text, x.icon, x.skipFade), s = s || x.text || x.icon);
                        }
                        for (const y in u) {
                            const x = u[y];
                            if (!this.opacities[y]) {
                                const w = new gn(x, o, !1, !1);
                                w.isHidden() || (this.opacities[y] = w, s = s || x.text.placed || x.icon.placed);
                            }
                        }
                        for (const y in f) this.variableOffsets[y] || !this.opacities[y] || this.opacities[y].isHidden() || (this.variableOffsets[y] = f[y]);
                        for (const y in g) this.placedOrientations[y] || !this.opacities[y] || this.opacities[y].isHidden() || (this.placedOrientations[y] = g[y]);
                        if (i && i.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
                        s ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = i ? i.lastPlacementChangeTime : e);
                    }
                    updateLayerOpacities(e, i) {
                        const s = {};
                        for (const o of i) {
                            const u = o.getBucket(e);
                            u && o.latestFeatureIndex && e.id === u.layerIds[0] && this.updateBucketOpacities(u, o.tileID, s, o.collisionBoxArray);
                        }
                    }
                    updateBucketOpacities(e, i, s, o) {
                        e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
                        const u = e.layers[0], f = u.layout, g = new gn(null, 0, !1, !1, !0), y = f.get("text-allow-overlap"), x = f.get("icon-allow-overlap"), w = u._unevaluatedLayout.hasValue("text-variable-anchor") || u._unevaluatedLayout.hasValue("text-variable-anchor-offset"), P = f.get("text-rotation-alignment") === "map", T = f.get("text-pitch-alignment") === "map", z = f.get("icon-text-fit") !== "none", R = new gn(null, 0, y && (x || !e.hasIconData() || f.get("icon-optional")), x && (y || !e.hasTextData() || f.get("text-optional")), !0);
                        !e.collisionArrays && o && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(o);
                        const V = (Z, q, J) => {
                            for (let Y = 0; Y < q / 4; Y++) Z.opacityVertexArray.emplaceBack(J);
                            Z.hasVisibleVertices = Z.hasVisibleVertices || J !== sa;
                        }, U = this.collisionBoxArrays.get(e.bucketInstanceId);
                        for (let Z = 0; Z < e.symbolInstances.length; Z++) {
                            const q = e.symbolInstances.get(Z), { numHorizontalGlyphVertices: J, numVerticalGlyphVertices: Y, crossTileID: ee } = q;
                            let ae = this.opacities[ee];
                            s[ee] ? ae = g : ae || (ae = R, this.opacities[ee] = ae), s[ee] = !0;
                            const te = q.numIconVertices > 0, he = this.placedOrientations[q.crossTileID], be = he === c.al.vertical, ge = he === c.al.horizontal || he === c.al.horizontalOnly;
                            if (J > 0 || Y > 0) {
                                const ye = _o(ae.text);
                                V(e.text, J, be ? sa : ye), V(e.text, Y, ge ? sa : ye);
                                const Ee = ae.text.isHidden();
                                [q.rightJustifiedTextSymbolIndex, q.centerJustifiedTextSymbolIndex, q.leftJustifiedTextSymbolIndex].forEach((Ne) => {
                                    Ne >= 0 && (e.text.placedSymbolArray.get(Ne).hidden = Ee || be ? 1 : 0);
                                }), q.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(q.verticalPlacedTextSymbolIndex).hidden = Ee || ge ? 1 : 0);
                                const ze = this.variableOffsets[q.crossTileID];
                                ze && this.markUsedJustification(e, ze.anchor, q, he);
                                const Ce = this.placedOrientations[q.crossTileID];
                                Ce && (this.markUsedJustification(e, "left", q, Ce), this.markUsedOrientation(e, Ce, q));
                            }
                            if (te) {
                                const ye = _o(ae.icon), Ee = !(z && q.verticalPlacedIconSymbolIndex && be);
                                q.placedIconSymbolIndex >= 0 && (V(e.icon, q.numIconVertices, Ee ? ye : sa), e.icon.placedSymbolArray.get(q.placedIconSymbolIndex).hidden = ae.icon.isHidden()), q.verticalPlacedIconSymbolIndex >= 0 && (V(e.icon, q.numVerticalIconVertices, Ee ? sa : ye), e.icon.placedSymbolArray.get(q.verticalPlacedIconSymbolIndex).hidden = ae.icon.isHidden());
                            }
                            const _e = U && U.has(Z) ? U.get(Z) : { text: null, icon: null };
                            if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                                const ye = e.collisionArrays[Z];
                                if (ye) {
                                    let Ee = new c.P(0, 0);
                                    if (ye.textBox || ye.verticalTextBox) {
                                        let ze = !0;
                                        if (w) {
                                            const Ce = this.variableOffsets[ee];
                                            Ce ? (Ee = Ir(Ce.anchor, Ce.width, Ce.height, Ce.textOffset, Ce.textBoxScale), P && Ee._rotate(T ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : ze = !1;
                                        }
                                        if (ye.textBox || ye.verticalTextBox) {
                                            let Ce;
                                            ye.textBox && (Ce = be), ye.verticalTextBox && (Ce = ge), go(e.textCollisionBox.collisionVertexArray, ae.text.placed, !ze || Ce, _e.text, Ee.x, Ee.y);
                                        }
                                    }
                                    if (ye.iconBox || ye.verticalIconBox) {
                                        const ze = !!(!ge && ye.verticalIconBox);
                                        let Ce;
                                        ye.iconBox && (Ce = ze), ye.verticalIconBox && (Ce = !ze), go(e.iconCollisionBox.collisionVertexArray, ae.icon.placed, Ce, _e.icon, z ? Ee.x : 0, z ? Ee.y : 0);
                                    }
                                }
                            }
                        }
                        if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
                        if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
                        e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId]);
                    }
                    symbolFadeChange(e) {
                        return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
                    }
                    zoomAdjustment(e) {
                        return Math.max(0, (this.transform.zoom - e) / 1.5);
                    }
                    hasTransitions(e) {
                        return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
                    }
                    stillRecent(e, i) {
                        const s = this.zoomAtLastRecencyCheck === i ? 1 - this.zoomAdjustment(i) : 1;
                        return this.zoomAtLastRecencyCheck = i, this.commitTime + this.fadeDuration * s > e;
                    }
                    setStale() {
                        this.stale = !0;
                    }
                }
                function go(h, e, i, s, o, u) {
                    s && s.length !== 0 || (s = [0, 0, 0, 0]);
                    const f = s[0] - $t, g = s[1] - $t, y = s[2] - $t, x = s[3] - $t;
                    h.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, u || 0, f, g), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, u || 0, y, g), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, u || 0, y, x), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, u || 0, f, x);
                }
                const Bl = Math.pow(2, 25), Ea = Math.pow(2, 24), Fl = Math.pow(2, 17), Qc = Math.pow(2, 16), eh = Math.pow(2, 9), th = Math.pow(2, 8), Nl = Math.pow(2, 1);
                function _o(h) {
                    if (h.opacity === 0 && !h.placed) return 0;
                    if (h.opacity === 1 && h.placed) return 4294967295;
                    const e = h.placed ? 1 : 0, i = Math.floor(127 * h.opacity);
                    return i * Bl + e * Ea + i * Fl + e * Qc + i * eh + e * th + i * Nl + e;
                }
                const sa = 0;
                class yo {
                    constructor(e) {
                        this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
                    }
                    continuePlacement(e, i, s, o, u) {
                        const f = this._bucketParts;
                        for (; this._currentTileIndex < e.length;) if (i.getBucketParts(f, o, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, u()) return !0;
                        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, f.sort((g, y) => g.sortKey - y.sortKey)); this._currentPartIndex < f.length;) if (i.placeLayerBucketPart(f[this._currentPartIndex], this._seenCrossTileIDs, s), this._currentPartIndex++, u()) return !0;
                        return !1;
                    }
                }
                class Ol {
                    constructor(e, i, s, o, u, f, g, y) {
                        this.placement = new Ll(e, i, f, g, y), this._currentPlacementIndex = s.length - 1, this._forceFullPlacement = o, this._showCollisionBoxes = u, this._done = !1;
                    }
                    isDone() {
                        return this._done;
                    }
                    continuePlacement(e, i, s) {
                        const o = Ue.now(), u = () => !this._forceFullPlacement && Ue.now() - o > 2;
                        for (; this._currentPlacementIndex >= 0;) {
                            const f = i[e[this._currentPlacementIndex]], g = this.placement.collisionIndex.transform.zoom;
                            if (f.type === "symbol" && (!f.minzoom || f.minzoom <= g) && (!f.maxzoom || f.maxzoom > g)) {
                                if (this._inProgressLayer || (this._inProgressLayer = new yo(f)), this._inProgressLayer.continuePlacement(s[f.source], this.placement, this._showCollisionBoxes, f, u)) return;
                                delete this._inProgressLayer;
                            }
                            this._currentPlacementIndex--;
                        }
                        this._done = !0;
                    }
                    commit(e) {
                        return this.placement.commit(e), this.placement;
                    }
                }
                const oa = 512 / c.Z / 2;
                class vo {
                    constructor(e, i, s) {
                        this.tileID = e, this.bucketInstanceId = s, this._symbolsByKey = {};
                        const o = /* @__PURE__ */ new Map();
                        for (let u = 0; u < i.length; u++) {
                            const f = i.get(u), g = f.key, y = o.get(g);
                            y ? y.push(f) : o.set(g, [f]);
                        }
                        for (const [u, f] of o) {
                            const g = { positions: f.map((y) => ({ x: Math.floor(y.anchorX * oa), y: Math.floor(y.anchorY * oa) })), crossTileIDs: f.map((y) => y.crossTileID) };
                            if (g.positions.length > 128) {
                                const y = new c.aF(g.positions.length, 16, Uint16Array);
                                for (const { x, y: w } of g.positions) y.add(x, w);
                                y.finish(), delete g.positions, g.index = y;
                            }
                            this._symbolsByKey[u] = g;
                        }
                    }
                    getScaledCoordinates(e, i) {
                        const { x: s, y: o, z: u } = this.tileID.canonical, { x: f, y: g, z: y } = i.canonical, x = oa / Math.pow(2, y - u), w = (g * c.Z + e.anchorY) * x, P = o * c.Z * oa;
                        return { x: Math.floor((f * c.Z + e.anchorX) * x - s * c.Z * oa), y: Math.floor(w - P) };
                    }
                    findMatches(e, i, s) {
                        const o = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z);
                        for (let u = 0; u < e.length; u++) {
                            const f = e.get(u);
                            if (f.crossTileID) continue;
                            const g = this._symbolsByKey[f.key];
                            if (!g) continue;
                            const y = this.getScaledCoordinates(f, i);
                            if (g.index) {
                                const x = g.index.range(y.x - o, y.y - o, y.x + o, y.y + o).sort();
                                for (const w of x) {
                                    const P = g.crossTileIDs[w];
                                    if (!s[P]) {
                                        s[P] = !0, f.crossTileID = P;
                                        break;
                                    }
                                }
                            } else if (g.positions) for (let x = 0; x < g.positions.length; x++) {
                                const w = g.positions[x], P = g.crossTileIDs[x];
                                if (Math.abs(w.x - y.x) <= o && Math.abs(w.y - y.y) <= o && !s[P]) {
                                    s[P] = !0, f.crossTileID = P;
                                    break;
                                }
                            }
                        }
                    }
                    getCrossTileIDsLists() {
                        return Object.values(this._symbolsByKey).map(({ crossTileIDs: e }) => e);
                    }
                }
                class ih {
                    constructor() {
                        this.maxCrossTileID = 0;
                    }
                    generate() {
                        return ++this.maxCrossTileID;
                    }
                }
                class _n {
                    constructor() {
                        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
                    }
                    handleWrapJump(e) {
                        const i = Math.round((e - this.lng) / 360);
                        if (i !== 0) for (const s in this.indexes) {
                            const o = this.indexes[s], u = {};
                            for (const f in o) {
                                const g = o[f];
                                g.tileID = g.tileID.unwrapTo(g.tileID.wrap + i), u[g.tileID.key] = g;
                            }
                            this.indexes[s] = u;
                        }
                        this.lng = e;
                    }
                    addBucket(e, i, s) {
                        if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
                            if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === i.bucketInstanceId) return !1;
                            this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
                        }
                        for (let u = 0; u < i.symbolInstances.length; u++) i.symbolInstances.get(u).crossTileID = 0;
                        this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
                        const o = this.usedCrossTileIDs[e.overscaledZ];
                        for (const u in this.indexes) {
                            const f = this.indexes[u];
                            if (Number(u) > e.overscaledZ) for (const g in f) {
                                const y = f[g];
                                y.tileID.isChildOf(e) && y.findMatches(i.symbolInstances, e, o);
                            }
                            else {
                                const g = f[e.scaledTo(Number(u)).key];
                                g && g.findMatches(i.symbolInstances, e, o);
                            }
                        }
                        for (let u = 0; u < i.symbolInstances.length; u++) {
                            const f = i.symbolInstances.get(u);
                            f.crossTileID || (f.crossTileID = s.generate(), o[f.crossTileID] = !0);
                        }
                        return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new vo(e, i.symbolInstances, i.bucketInstanceId), !0;
                    }
                    removeBucketCrossTileIDs(e, i) {
                        for (const s of i.getCrossTileIDsLists()) for (const o of s) delete this.usedCrossTileIDs[e][o];
                    }
                    removeStaleBuckets(e) {
                        let i = !1;
                        for (const s in this.indexes) {
                            const o = this.indexes[s];
                            for (const u in o) e[o[u].bucketInstanceId] || (this.removeBucketCrossTileIDs(s, o[u]), delete o[u], i = !0);
                        }
                        return i;
                    }
                }
                class yn {
                    constructor() {
                        this.layerIndexes = {}, this.crossTileIDs = new ih(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
                    }
                    addLayer(e, i, s) {
                        let o = this.layerIndexes[e.id];
                        o === void 0 && (o = this.layerIndexes[e.id] = new _n());
                        let u = !1;
                        const f = {};
                        o.handleWrapJump(s);
                        for (const g of i) {
                            const y = g.getBucket(e);
                            y && e.id === y.layerIds[0] && (y.bucketInstanceId || (y.bucketInstanceId = ++this.maxBucketInstanceId), o.addBucket(g.tileID, y, this.crossTileIDs) && (u = !0), f[y.bucketInstanceId] = !0);
                        }
                        return o.removeStaleBuckets(f) && (u = !0), u;
                    }
                    pruneUnusedLayers(e) {
                        const i = {};
                        e.forEach((s) => {
                            i[s] = !0;
                        });
                        for (const s in this.layerIndexes) i[s] || delete this.layerIndexes[s];
                    }
                }
                var xo = "void main() {fragColor=vec4(1.0);}";
                const Si = {
                    prelude: ut(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: ut("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: ut("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: ut(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: ut(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: ut(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: ut(xo, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: ut(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: ut(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: ut("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: ut("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: ut("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: ut(xo, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: ut(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: ut(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: ut(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: ut(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: ut(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: ut(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: ut(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: ut(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;switch(u_method){case BASIC:
basic_hillshade(deriv);break;case COMBINED:
combined_hillshade(deriv);break;case IGOR:
igor_hillshade(deriv);break;case MULTIDIRECTIONAL:
multidirectional_hillshade(deriv);break;case STANDARD:
default:
standard_hillshade(deriv);break;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: ut(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: ut(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: ut(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: ut(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: ut(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: ut(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: ut(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: ut(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: ut("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: ut("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: ut("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: ut("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: ut(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: ut("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
                };
                function ut(h, e) {
                    const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, s = e.match(/in ([\w]+) ([\w]+)/g), o = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), u = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), f = u ? u.concat(o) : o, g = {};
                    return {
                        fragmentSource: h = h.replace(i, (y, x, w, P, T) => (g[T] = !0, x === "define" ? `
#ifndef HAS_UNIFORM_u_${T}
in ${w} ${P} ${T};
#else
uniform ${w} ${P} u_${T};
#endif
` : `
#ifdef HAS_UNIFORM_u_${T}
    ${w} ${P} ${T} = u_${T};
#endif
`)), vertexSource: e = e.replace(i, (y, x, w, P, T) => {
                            const z = P === "float" ? "vec2" : "vec4", R = T.match(/color/) ? "color" : z;
                            return g[T] ? x === "define" ? `
#ifndef HAS_UNIFORM_u_${T}
uniform lowp float u_${T}_t;
in ${w} ${z} a_${T};
out ${w} ${P} ${T};
#else
uniform ${w} ${P} u_${T};
#endif
` : R === "vec4" ? `
#ifndef HAS_UNIFORM_u_${T}
    ${T} = a_${T};
#else
    ${w} ${P} ${T} = u_${T};
#endif
` : `
#ifndef HAS_UNIFORM_u_${T}
    ${T} = unpack_mix_${R}(a_${T}, u_${T}_t);
#else
    ${w} ${P} ${T} = u_${T};
#endif
` : x === "define" ? `
#ifndef HAS_UNIFORM_u_${T}
uniform lowp float u_${T}_t;
in ${w} ${z} a_${T};
#else
uniform ${w} ${P} u_${T};
#endif
` : R === "vec4" ? `
#ifndef HAS_UNIFORM_u_${T}
    ${w} ${P} ${T} = a_${T};
#else
    ${w} ${P} ${T} = u_${T};
#endif
` : `
#ifndef HAS_UNIFORM_u_${T}
    ${w} ${P} ${T} = unpack_mix_${R}(a_${T}, u_${T}_t);
#else
    ${w} ${P} ${T} = u_${T};
#endif
`;
                        }), staticAttributes: s, staticUniforms: f
                    };
                }
                class Ra {
                    constructor(e, i, s) {
                        this.vertexBuffer = e, this.indexBuffer = i, this.segments = s;
                    }
                    destroy() {
                        this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
                    }
                }
                var Ti = c.aG([{ name: "a_pos", type: "Int16", components: 2 }]);
                const la = "#define PROJECTION_MERCATOR", st = "mercator";
                class vn {
                    constructor() {
                        this._cachedMesh = null;
                    }
                    get name() {
                        return "mercator";
                    }
                    get useSubdivision() {
                        return !1;
                    }
                    get shaderVariantName() {
                        return st;
                    }
                    get shaderDefine() {
                        return la;
                    }
                    get shaderPreludeCode() {
                        return Si.projectionMercator;
                    }
                    get vertexShaderPreludeCode() {
                        return Si.projectionMercator.vertexSource;
                    }
                    get subdivisionGranularity() {
                        return c.aH.noSubdivision;
                    }
                    get useGlobeControls() {
                        return !1;
                    }
                    get transitionState() {
                        return 0;
                    }
                    get latitudeErrorCorrectionRadians() {
                        return 0;
                    }
                    destroy() {
                    }
                    updateGPUdependent(e) {
                    }
                    getMeshFromTileID(e, i, s, o, u) {
                        if (this._cachedMesh) return this._cachedMesh;
                        const f = new c.aI();
                        f.emplaceBack(0, 0), f.emplaceBack(c.Z, 0), f.emplaceBack(0, c.Z), f.emplaceBack(c.Z, c.Z);
                        const g = e.createVertexBuffer(f, Ti.members), y = c.aJ.simpleSegment(0, 0, 4, 2), x = new c.aK();
                        x.emplaceBack(1, 0, 2), x.emplaceBack(1, 2, 3);
                        const w = e.createIndexBuffer(x);
                        return this._cachedMesh = new Ra(g, w, y), this._cachedMesh;
                    }
                    recalculate() {
                    }
                    hasTransition() {
                        return !1;
                    }
                    setErrorQueryLatitudeDegrees(e) {
                    }
                }
                class xn {
                    constructor(e = 0, i = 0, s = 0, o = 0) {
                        if (isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(s) || s < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                        this.top = e, this.bottom = i, this.left = s, this.right = o;
                    }
                    interpolate(e, i, s) {
                        return i.top != null && e.top != null && (this.top = c.B.number(e.top, i.top, s)), i.bottom != null && e.bottom != null && (this.bottom = c.B.number(e.bottom, i.bottom, s)), i.left != null && e.left != null && (this.left = c.B.number(e.left, i.left, s)), i.right != null && e.right != null && (this.right = c.B.number(e.right, i.right, s)), this;
                    }
                    getCenter(e, i) {
                        const s = c.ae((this.left + e - this.right) / 2, 0, e), o = c.ae((this.top + i - this.bottom) / 2, 0, i);
                        return new c.P(s, o);
                    }
                    equals(e) {
                        return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
                    }
                    clone() {
                        return new xn(this.top, this.bottom, this.left, this.right);
                    }
                    toJSON() {
                        return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
                    }
                }
                function Da(h, e) {
                    if (!h.renderWorldCopies || h.lngRange) return;
                    const i = e.lng - h.center.lng;
                    e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
                }
                function zi(h) {
                    return Math.max(0, Math.floor(h));
                }
                class ci {
                    constructor(e, i, s, o, u, f) {
                        this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = f === void 0 || !!f, this._minZoom = i || 0, this._maxZoom = s || 22, this._minPitch = o ?? 0, this._maxPitch = u ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new c.Q(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = zi(this._zoom), this._scale = c.ac(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new xn(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
                    }
                    apply(e, i, s) {
                        this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = zi(this._zoom), this._scale = c.ac(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new xn(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !s && e.autoCalculateNearFarZ, i && this._constrain(), this._calcMatrices();
                    }
                    get pixelsToClipSpaceMatrix() {
                        return this._pixelsToClipSpaceMatrix;
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._clipSpaceToPixelsMatrix;
                    }
                    get minElevationForCurrentTile() {
                        return this._minElevationForCurrentTile;
                    }
                    setMinElevationForCurrentTile(e) {
                        this._minElevationForCurrentTile = e;
                    }
                    get tileSize() {
                        return this._tileSize;
                    }
                    get tileZoom() {
                        return this._tileZoom;
                    }
                    get scale() {
                        return this._scale;
                    }
                    get width() {
                        return this._width;
                    }
                    get height() {
                        return this._height;
                    }
                    get bearingInRadians() {
                        return this._bearingInRadians;
                    }
                    get lngRange() {
                        return this._lngRange;
                    }
                    get latRange() {
                        return this._latRange;
                    }
                    get pixelsToGLUnits() {
                        return this._pixelsToGLUnits;
                    }
                    get minZoom() {
                        return this._minZoom;
                    }
                    setMinZoom(e) {
                        this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
                    }
                    get maxZoom() {
                        return this._maxZoom;
                    }
                    setMaxZoom(e) {
                        this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
                    }
                    get minPitch() {
                        return this._minPitch;
                    }
                    setMinPitch(e) {
                        this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)));
                    }
                    get maxPitch() {
                        return this._maxPitch;
                    }
                    setMaxPitch(e) {
                        this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)));
                    }
                    get renderWorldCopies() {
                        return this._renderWorldCopies;
                    }
                    setRenderWorldCopies(e) {
                        e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e;
                    }
                    get worldSize() {
                        return this._tileSize * this._scale;
                    }
                    get centerOffset() {
                        return this.centerPoint._sub(this.size._div(2));
                    }
                    get size() {
                        return new c.P(this._width, this._height);
                    }
                    get bearing() {
                        return this._bearingInRadians / Math.PI * 180;
                    }
                    setBearing(e) {
                        const i = c.aL(e, -180, 180) * Math.PI / 180;
                        var s, o, u, f, g, y, x, w, P;
                        this._bearingInRadians !== i && (this._unmodified = !1, this._bearingInRadians = i, this._calcMatrices(), this._rotationMatrix = ht(), s = this._rotationMatrix, u = -this._bearingInRadians, f = (o = this._rotationMatrix)[0], g = o[1], y = o[2], x = o[3], w = Math.sin(u), P = Math.cos(u), s[0] = f * P + y * w, s[1] = g * P + x * w, s[2] = f * -w + y * P, s[3] = g * -w + x * P);
                    }
                    get rotationMatrix() {
                        return this._rotationMatrix;
                    }
                    get pitchInRadians() {
                        return this._pitchInRadians;
                    }
                    get pitch() {
                        return this._pitchInRadians / Math.PI * 180;
                    }
                    setPitch(e) {
                        const i = c.ae(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
                        this._pitchInRadians !== i && (this._unmodified = !1, this._pitchInRadians = i, this._calcMatrices());
                    }
                    get rollInRadians() {
                        return this._rollInRadians;
                    }
                    get roll() {
                        return this._rollInRadians / Math.PI * 180;
                    }
                    setRoll(e) {
                        const i = e / 180 * Math.PI;
                        this._rollInRadians !== i && (this._unmodified = !1, this._rollInRadians = i, this._calcMatrices());
                    }
                    get fovInRadians() {
                        return this._fovInRadians;
                    }
                    get fov() {
                        return c.aM(this._fovInRadians);
                    }
                    setFov(e) {
                        e = c.ae(e, 0.1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = c.ab(e), this._calcMatrices());
                    }
                    get zoom() {
                        return this._zoom;
                    }
                    setZoom(e) {
                        const i = this.getConstrained(this._center, e).zoom;
                        this._zoom !== i && (this._unmodified = !1, this._zoom = i, this._tileZoom = Math.max(0, Math.floor(i)), this._scale = c.ac(i), this._constrain(), this._calcMatrices());
                    }
                    get center() {
                        return this._center;
                    }
                    setCenter(e) {
                        e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices());
                    }
                    get elevation() {
                        return this._elevation;
                    }
                    setElevation(e) {
                        e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
                    }
                    get padding() {
                        return this._edgeInsets.toJSON();
                    }
                    setPadding(e) {
                        this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
                    }
                    get centerPoint() {
                        return this._edgeInsets.getCenter(this._width, this._height);
                    }
                    get pixelsPerMeter() {
                        return this._pixelPerMeter;
                    }
                    get unmodified() {
                        return this._unmodified;
                    }
                    get cameraToCenterDistance() {
                        return this._cameraToCenterDistance;
                    }
                    get nearZ() {
                        return this._nearZ;
                    }
                    get farZ() {
                        return this._farZ;
                    }
                    get autoCalculateNearFarZ() {
                        return this._autoCalculateNearFarZ;
                    }
                    overrideNearFarZ(e, i) {
                        this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = i, this._calcMatrices();
                    }
                    clearNearFarZOverride() {
                        this._autoCalculateNearFarZ = !0, this._calcMatrices();
                    }
                    isPaddingEqual(e) {
                        return this._edgeInsets.equals(e);
                    }
                    interpolatePadding(e, i, s) {
                        this._unmodified = !1, this._edgeInsets.interpolate(e, i, s), this._constrain(), this._calcMatrices();
                    }
                    resize(e, i, s = !0) {
                        this._width = e, this._height = i, s && this._constrain(), this._calcMatrices();
                    }
                    getMaxBounds() {
                        return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new bt([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
                    }
                    setMaxBounds(e) {
                        e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-85.051129, c.af]);
                    }
                    getConstrained(e, i) {
                        return this._callbacks.getConstrained(e, i);
                    }
                    getCameraQueryGeometry(e, i) {
                        if (i.length === 1) return [i[0], e];
                        {
                            let s = e.x, o = e.y, u = e.x, f = e.y;
                            for (const g of i) s = Math.min(s, g.x), o = Math.min(o, g.y), u = Math.max(u, g.x), f = Math.max(f, g.y);
                            return [new c.P(s, o), new c.P(u, o), new c.P(u, f), new c.P(s, f), new c.P(s, o)];
                        }
                    }
                    _constrain() {
                        if (!this.center || !this._width || !this._height || this._constraining) return;
                        this._constraining = !0;
                        const e = this._unmodified, { center: i, zoom: s } = this.getConstrained(this.center, this.zoom);
                        this.setCenter(i), this.setZoom(s), this._unmodified = e, this._constraining = !1;
                    }
                    _calcMatrices() {
                        if (this._width && this._height) {
                            this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
                            let e = c.ad(new Float64Array(16));
                            c.M(e, e, [this._width / 2, -this._height / 2, 1]), c.L(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = c.ad(new Float64Array(16)), c.M(e, e, [1, -1, 1]), c.L(e, e, [-1, -1, 0]), c.M(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
                        }
                        this._callbacks.calcMatrices();
                    }
                    calculateCenterFromCameraLngLatAlt(e, i, s, o) {
                        const u = s !== void 0 ? s : this.bearing, f = o = o !== void 0 ? o : this.pitch, g = c.$.fromLngLat(e, i), y = -Math.cos(c.ab(f)), x = Math.sin(c.ab(f)), w = x * Math.sin(c.ab(u)), P = -x * Math.cos(c.ab(u));
                        let T = this.elevation;
                        const z = i - T;
                        let R;
                        y * z >= 0 || Math.abs(y) < 0.1 ? (R = 1e4, T = i + R * y) : R = -z / y;
                        let V, U, Z = c.aN(1, g.y), q = 0;
                        do {
                            if (q += 1, q > 10) break;
                            U = R / Z, V = new c.$(g.x + w * U, g.y + P * U), Z = 1 / V.meterInMercatorCoordinateUnits();
                        } while (Math.abs(R - U * Z) > 1e-12);
                        return { center: V.toLngLat(), elevation: T, zoom: c.ah(this.height / 2 / Math.tan(this.fovInRadians / 2) / U / this.tileSize) };
                    }
                    recalculateZoomAndCenter(e) {
                        if (this.elevation - e == 0) return;
                        const i = c.ag(1, this.center.lat) * this.worldSize, s = this.cameraToCenterDistance / i, o = c.$.fromLngLat(this.center, this.elevation), u = B(this.center, this.elevation, this.pitch, this.bearing, s);
                        this._elevation = e;
                        const f = this.calculateCenterFromCameraLngLatAlt(u.toLngLat(), c.aN(u.z, o.y), this.bearing, this.pitch);
                        this._elevation = f.elevation, this._center = f.center, this.setZoom(f.zoom);
                    }
                    getCameraPoint() {
                        const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
                        return this.centerPoint.add(new c.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)));
                    }
                    getCameraAltitude() {
                        return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
                    }
                    getCameraLngLat() {
                        const e = c.ag(1, this.center.lat) * this.worldSize;
                        return B(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat();
                    }
                    getMercatorTileCoordinates(e) {
                        if (!e) return [0, 0, 1, 1];
                        const i = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
                        return [e.canonical.x / i, e.canonical.y / i, 1 / i / c.Z, 1 / i / c.Z];
                    }
                }
                class Ut {
                    constructor(e, i) {
                        this.min = e, this.max = i, this.center = c.aO([], c.aP([], this.min, this.max), 0.5);
                    }
                    quadrant(e) {
                        const i = [e % 2 == 0, e < 2], s = c.aQ(this.min), o = c.aQ(this.max);
                        for (let u = 0; u < i.length; u++) s[u] = i[u] ? this.min[u] : this.center[u], o[u] = i[u] ? this.center[u] : this.max[u];
                        return o[2] = this.max[2], new Ut(s, o);
                    }
                    distanceX(e) {
                        return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
                    }
                    distanceY(e) {
                        return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
                    }
                    intersectsFrustum(e) {
                        let i = !0;
                        for (let s = 0; s < e.planes.length; s++) {
                            const o = this.intersectsPlane(e.planes[s]);
                            if (o === 0) return 0;
                            o === 1 && (i = !1);
                        }
                        return i ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1;
                    }
                    intersectsPlane(e) {
                        let i = e[3], s = e[3];
                        for (let o = 0; o < 3; o++) e[o] > 0 ? (i += e[o] * this.min[o], s += e[o] * this.max[o]) : (s += e[o] * this.min[o], i += e[o] * this.max[o]);
                        return i >= 0 ? 2 : s < 0 ? 0 : 1;
                    }
                }
                class hi {
                    distanceToTile2d(e, i, s, o) {
                        const u = o.distanceX([e, i]), f = o.distanceY([e, i]);
                        return Math.hypot(u, f);
                    }
                    getWrap(e, i, s) {
                        return s;
                    }
                    getTileAABB(e, i, s, o) {
                        var u, f;
                        let g = s, y = s;
                        if (o.terrain) {
                            const w = new c.Y(e.z, i, e.z, e.x, e.y), P = o.terrain.getMinMaxElevation(w);
                            g = (u = P.minElevation) !== null && u !== void 0 ? u : s, y = (f = P.maxElevation) !== null && f !== void 0 ? f : s;
                        }
                        const x = 1 << e.z;
                        return new Ut([i + e.x / x, e.y / x, g], [i + (e.x + 1) / x, (e.y + 1) / x, y]);
                    }
                    allowVariableZoom(e, i) {
                        const s = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height, o = c.ae(78.5 - s / 2, 0, 60);
                        return !!i.terrain || e.pitch > o;
                    }
                    allowWorldCopies() {
                        return !0;
                    }
                    recalculateCache() {
                    }
                }
                class St {
                    constructor(e, i, s) {
                        this.points = e, this.planes = i, this.aabb = s;
                    }
                    static fromInvProjectionMatrix(e, i = 1, s = 0) {
                        const o = Math.pow(2, s), u = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((x) => {
                            const w = 1 / (x = c.at([], x, e))[3] / i * o;
                            return c.aR(x, x, [w, w, 1 / x[3], w]);
                        }), f = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((x) => {
                            const w = c.aS([], u[x[0]], u[x[1]]), P = c.aS([], u[x[2]], u[x[1]]), T = c.aT([], c.aU([], w, P)), z = -c.aV(T, u[x[1]]);
                            return T.concat(z);
                        }), g = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], y = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
                        for (const x of u) for (let w = 0; w < 3; w++) g[w] = Math.min(g[w], x[w]), y[w] = Math.max(y[w], x[w]);
                        return new St(u, f, new Ut(g, y));
                    }
                }
                class La {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix;
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix;
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits;
                    }
                    get centerOffset() {
                        return this._helper.centerOffset;
                    }
                    get size() {
                        return this._helper.size;
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix;
                    }
                    get centerPoint() {
                        return this._helper.centerPoint;
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter;
                    }
                    setMinZoom(e) {
                        this._helper.setMinZoom(e);
                    }
                    setMaxZoom(e) {
                        this._helper.setMaxZoom(e);
                    }
                    setMinPitch(e) {
                        this._helper.setMinPitch(e);
                    }
                    setMaxPitch(e) {
                        this._helper.setMaxPitch(e);
                    }
                    setRenderWorldCopies(e) {
                        this._helper.setRenderWorldCopies(e);
                    }
                    setBearing(e) {
                        this._helper.setBearing(e);
                    }
                    setPitch(e) {
                        this._helper.setPitch(e);
                    }
                    setRoll(e) {
                        this._helper.setRoll(e);
                    }
                    setFov(e) {
                        this._helper.setFov(e);
                    }
                    setZoom(e) {
                        this._helper.setZoom(e);
                    }
                    setCenter(e) {
                        this._helper.setCenter(e);
                    }
                    setElevation(e) {
                        this._helper.setElevation(e);
                    }
                    setMinElevationForCurrentTile(e) {
                        this._helper.setMinElevationForCurrentTile(e);
                    }
                    setPadding(e) {
                        this._helper.setPadding(e);
                    }
                    interpolatePadding(e, i, s) {
                        return this._helper.interpolatePadding(e, i, s);
                    }
                    isPaddingEqual(e) {
                        return this._helper.isPaddingEqual(e);
                    }
                    resize(e, i, s = !0) {
                        this._helper.resize(e, i, s);
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds();
                    }
                    setMaxBounds(e) {
                        this._helper.setMaxBounds(e);
                    }
                    overrideNearFarZ(e, i) {
                        this._helper.overrideNearFarZ(e, i);
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride();
                    }
                    getCameraQueryGeometry(e) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
                    }
                    get tileSize() {
                        return this._helper.tileSize;
                    }
                    get tileZoom() {
                        return this._helper.tileZoom;
                    }
                    get scale() {
                        return this._helper.scale;
                    }
                    get worldSize() {
                        return this._helper.worldSize;
                    }
                    get width() {
                        return this._helper.width;
                    }
                    get height() {
                        return this._helper.height;
                    }
                    get lngRange() {
                        return this._helper.lngRange;
                    }
                    get latRange() {
                        return this._helper.latRange;
                    }
                    get minZoom() {
                        return this._helper.minZoom;
                    }
                    get maxZoom() {
                        return this._helper.maxZoom;
                    }
                    get zoom() {
                        return this._helper.zoom;
                    }
                    get center() {
                        return this._helper.center;
                    }
                    get minPitch() {
                        return this._helper.minPitch;
                    }
                    get maxPitch() {
                        return this._helper.maxPitch;
                    }
                    get pitch() {
                        return this._helper.pitch;
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians;
                    }
                    get roll() {
                        return this._helper.roll;
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians;
                    }
                    get bearing() {
                        return this._helper.bearing;
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians;
                    }
                    get fov() {
                        return this._helper.fov;
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians;
                    }
                    get elevation() {
                        return this._helper.elevation;
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile;
                    }
                    get padding() {
                        return this._helper.padding;
                    }
                    get unmodified() {
                        return this._helper.unmodified;
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies;
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance;
                    }
                    get nearZ() {
                        return this._helper.nearZ;
                    }
                    get farZ() {
                        return this._helper.farZ;
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ;
                    }
                    setTransitionState(e, i) {
                    }
                    constructor(e, i, s, o, u) {
                        this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new ci({
                            calcMatrices: () => {
                                this._calcMatrices();
                            }, getConstrained: (f, g) => this.getConstrained(f, g)
                        }, e, i, s, o, u), this._coveringTilesDetailsProvider = new hi();
                    }
                    clone() {
                        const e = new La();
                        return e.apply(this), e;
                    }
                    apply(e, i, s) {
                        this._helper.apply(e, i, s);
                    }
                    get cameraPosition() {
                        return this._cameraPosition;
                    }
                    get projectionMatrix() {
                        return this._projectionMatrix;
                    }
                    get modelViewProjectionMatrix() {
                        return this._viewProjMatrix;
                    }
                    get inverseProjectionMatrix() {
                        return this._invProjMatrix;
                    }
                    get mercatorMatrix() {
                        return this._mercatorMatrix;
                    }
                    getVisibleUnwrappedCoordinates(e) {
                        const i = [new c.aW(0, e)];
                        if (this._helper._renderWorldCopies) {
                            const s = this.screenPointToMercatorCoordinate(new c.P(0, 0)), o = this.screenPointToMercatorCoordinate(new c.P(this._helper._width, 0)), u = this.screenPointToMercatorCoordinate(new c.P(this._helper._width, this._helper._height)), f = this.screenPointToMercatorCoordinate(new c.P(0, this._helper._height)), g = Math.floor(Math.min(s.x, o.x, u.x, f.x)), y = Math.floor(Math.max(s.x, o.x, u.x, f.x)), x = 1;
                            for (let w = g - x; w <= y + x; w++) w !== 0 && i.push(new c.aW(w, e));
                        }
                        return i;
                    }
                    getCameraFrustum() {
                        return St.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
                    }
                    getClippingPlane() {
                        return null;
                    }
                    getCoveringTilesDetailsProvider() {
                        return this._coveringTilesDetailsProvider;
                    }
                    recalculateZoomAndCenter(e) {
                        const i = this.screenPointToLocation(this.centerPoint, e), s = e ? e.getElevationForLngLatZoom(i, this._helper._tileZoom) : 0;
                        this._helper.recalculateZoomAndCenter(s);
                    }
                    setLocationAtPoint(e, i) {
                        const s = c.ag(this.elevation, this.center.lat), o = this.screenPointToMercatorCoordinateAtZ(i, s), u = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, s), f = c.$.fromLngLat(e), g = new c.$(f.x - (o.x - u.x), f.y - (o.y - u.y));
                        this.setCenter(g == null ? void 0 : g.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
                    }
                    locationToScreenPoint(e, i) {
                        return i ? this.coordinatePoint(c.$.fromLngLat(e), i.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(c.$.fromLngLat(e));
                    }
                    screenPointToLocation(e, i) {
                        var s;
                        return (s = this.screenPointToMercatorCoordinate(e, i)) === null || s === void 0 ? void 0 : s.toLngLat();
                    }
                    screenPointToMercatorCoordinate(e, i) {
                        if (i) {
                            const s = i.pointCoordinate(e);
                            if (s != null) return s;
                        }
                        return this.screenPointToMercatorCoordinateAtZ(e);
                    }
                    screenPointToMercatorCoordinateAtZ(e, i) {
                        const s = i || 0, o = [e.x, e.y, 0, 1], u = [e.x, e.y, 1, 1];
                        c.at(o, o, this._pixelMatrixInverse), c.at(u, u, this._pixelMatrixInverse);
                        const f = o[3], g = u[3], y = o[1] / f, x = u[1] / g, w = o[2] / f, P = u[2] / g, T = w === P ? 0 : (s - w) / (P - w);
                        return new c.$(c.B.number(o[0] / f, u[0] / g, T) / this.worldSize, c.B.number(y, x, T) / this.worldSize, s);
                    }
                    coordinatePoint(e, i = 0, s = this._pixelMatrix) {
                        const o = [e.x * this.worldSize, e.y * this.worldSize, i, 1];
                        return c.at(o, o, s), new c.P(o[0] / o[3], o[1] / o[3]);
                    }
                    getBounds() {
                        const e = Math.max(0, this._helper._height / 2 - oe(this));
                        return new bt().extend(this.screenPointToLocation(new c.P(0, e))).extend(this.screenPointToLocation(new c.P(this._helper._width, e))).extend(this.screenPointToLocation(new c.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new c.P(0, this._helper._height)));
                    }
                    isPointOnMapSurface(e, i) {
                        return i ? i.pointCoordinate(e) != null : e.y > this.height / 2 - oe(this);
                    }
                    calculatePosMatrix(e, i = !1, s) {
                        var o;
                        const u = (o = e.key) !== null && o !== void 0 ? o : c.aX(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y), f = i ? this._alignedPosMatrixCache : this._posMatrixCache;
                        if (f.has(u)) {
                            const x = f.get(u);
                            return s ? x.f32 : x.f64;
                        }
                        const g = L(e, this.worldSize);
                        c.N(g, i ? this._alignedProjMatrix : this._viewProjMatrix, g);
                        const y = { f64: g, f32: new Float32Array(g) };
                        return f.set(u, y), s ? y.f32 : y.f64;
                    }
                    calculateFogMatrix(e) {
                        const i = e.key, s = this._fogMatrixCacheF32;
                        if (s.has(i)) return s.get(i);
                        const o = L(e, this.worldSize);
                        return c.N(o, this._fogMatrix, o), s.set(i, new Float32Array(o)), s.get(i);
                    }
                    getConstrained(e, i) {
                        i = c.ae(+i, this.minZoom, this.maxZoom);
                        const s = { center: new c.Q(e.lng, e.lat), zoom: i };
                        let o = this._helper._lngRange;
                        this._helper._renderWorldCopies || o !== null || (o = [-179.9999999999, 180 - 1e-10]);
                        const u = this.tileSize * c.ac(s.zoom);
                        let f = 0, g = u, y = 0, x = u, w = 0, P = 0;
                        const { x: T, y: z } = this.size;
                        if (this._helper._latRange) {
                            const J = this._helper._latRange;
                            f = c.S(J[1]) * u, g = c.S(J[0]) * u, g - f < z && (w = z / (g - f));
                        }
                        o && (y = c.aL(c.U(o[0]) * u, 0, u), x = c.aL(c.U(o[1]) * u, 0, u), x < y && (x += u), x - y < T && (P = T / (x - y)));
                        const { x: R, y: V } = Ai(u, e);
                        let U, Z;
                        const q = Math.max(P || 0, w || 0);
                        if (q) {
                            const J = new c.P(P ? (x + y) / 2 : R, w ? (g + f) / 2 : V);
                            return s.center = mr(u, J).wrap(), s.zoom += c.ah(q), s;
                        }
                        if (this._helper._latRange) {
                            const J = z / 2;
                            V - J < f && (Z = f + J), V + J > g && (Z = g - J);
                        }
                        if (o) {
                            const J = (y + x) / 2;
                            let Y = R;
                            this._helper._renderWorldCopies && (Y = c.aL(R, J - u / 2, J + u / 2));
                            const ee = T / 2;
                            Y - ee < y && (U = y + ee), Y + ee > x && (U = x - ee);
                        }
                        if (U !== void 0 || Z !== void 0) {
                            const J = new c.P(U ?? R, Z ?? V);
                            s.center = mr(u, J).wrap();
                        }
                        return s;
                    }
                    calculateCenterFromCameraLngLatAlt(e, i, s, o) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(e, i, s, o);
                    }
                    _calculateNearFarZIfNeeded(e, i, s) {
                        if (!this._helper.autoCalculateNearFarZ) return;
                        const o = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), u = e - o * this._helper._pixelPerMeter / Math.cos(i), f = o < 0 ? u : e, g = Math.PI / 2 + this.pitchInRadians, y = c.ab(this.fov) * (Math.abs(Math.cos(c.ab(this.roll))) * this.height + Math.abs(Math.sin(c.ab(this.roll))) * this.width) / this.height * (0.5 + s.y / this.height), x = Math.sin(y) * f / Math.sin(c.ae(Math.PI - g - y, 0.01, Math.PI - 0.01)), w = oe(this), P = Math.atan(w / this._helper.cameraToCenterDistance), T = c.ab(0.75), z = P > T ? 2 * P * (0.5 + s.y / (2 * w)) : T, R = Math.sin(z) * f / Math.sin(c.ae(Math.PI - g - z, 0.01, Math.PI - 0.01)), V = Math.min(x, R);
                        this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i) * V + f), this._helper._nearZ = this._helper._height / 50;
                    }
                    _calcMatrices() {
                        if (!this._helper._height) return;
                        const e = this.centerOffset, i = Ai(this.worldSize, this.center), s = i.x, o = i.y;
                        this._helper._pixelPerMeter = c.ag(1, this.center.lat) * this.worldSize;
                        const u = c.ab(Math.min(this.pitch, qi)), f = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(u));
                        let g;
                        this._calculateNearFarZIfNeeded(f, u, e), g = new Float64Array(16), c.aY(g, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), c.an(this._invProjMatrix, g), g[8] = 2 * -e.x / this._helper._width, g[9] = 2 * e.y / this._helper._height, this._projectionMatrix = c.aZ(g), c.M(g, g, [1, -1, 1]), c.L(g, g, [0, 0, -this._helper.cameraToCenterDistance]), c.a_(g, g, -this.rollInRadians), c.a$(g, g, this.pitchInRadians), c.a_(g, g, -this.bearingInRadians), c.L(g, g, [-s, -o, 0]), this._mercatorMatrix = c.M([], g, [this.worldSize, this.worldSize, this.worldSize]), c.M(g, g, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = c.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, g), c.L(g, g, [0, 0, -this.elevation]), this._viewProjMatrix = g, this._invViewProjMatrix = c.an([], g);
                        const y = [0, 0, -1, 1];
                        c.at(y, y, this._invViewProjMatrix), this._cameraPosition = [y[0] / y[3], y[1] / y[3], y[2] / y[3]], this._fogMatrix = new Float64Array(16), c.aY(this._fogMatrix, this.fovInRadians, this.width / this.height, f, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, c.M(this._fogMatrix, this._fogMatrix, [1, -1, 1]), c.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), c.a_(this._fogMatrix, this._fogMatrix, -this.rollInRadians), c.a$(this._fogMatrix, this._fogMatrix, this.pitchInRadians), c.a_(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), c.L(this._fogMatrix, this._fogMatrix, [-s, -o, 0]), c.M(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), c.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = c.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, g);
                        const x = this._helper._width % 2 / 2, w = this._helper._height % 2 / 2, P = Math.cos(this.bearingInRadians), T = Math.sin(-this.bearingInRadians), z = s - Math.round(s) + P * x + T * w, R = o - Math.round(o) + P * w + T * x, V = new Float64Array(g);
                        if (c.L(V, V, [z > 0.5 ? z - 1 : z, R > 0.5 ? R - 1 : R, 0]), this._alignedProjMatrix = V, g = c.an(new Float64Array(16), this._pixelMatrix), !g) throw new Error("failed to invert matrix");
                        this._pixelMatrixInverse = g, this._clearMatrixCaches();
                    }
                    _clearMatrixCaches() {
                        this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
                    }
                    maxPitchScaleFactor() {
                        if (!this._pixelMatrixInverse) return 1;
                        const e = this.screenPointToMercatorCoordinate(new c.P(0, 0)), i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
                        return c.at(i, i, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint();
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude();
                    }
                    getCameraLngLat() {
                        const e = c.ag(1, this.center.lat) * this.worldSize;
                        return B(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat();
                    }
                    lngLatToCameraDepth(e, i) {
                        const s = c.$.fromLngLat(e), o = [s.x * this.worldSize, s.y * this.worldSize, i, 1];
                        return c.at(o, o, this._viewProjMatrix), o[2] / o[3];
                    }
                    getProjectionData(e) {
                        const { overscaledTileID: i, aligned: s, applyTerrainMatrix: o } = e, u = this._helper.getMercatorTileCoordinates(i), f = i ? this.calculatePosMatrix(i, s, !0) : null;
                        let g;
                        return g = i && i.terrainRttPosMatrix32f && o ? i.terrainRttPosMatrix32f : f || c.b0(), { mainMatrix: g, tileMercatorCoords: u, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: g };
                    }
                    isLocationOccluded(e) {
                        return !1;
                    }
                    getPixelScale() {
                        return 1;
                    }
                    getCircleRadiusCorrection() {
                        return 1;
                    }
                    getPitchedTextCorrection(e, i, s) {
                        return 1;
                    }
                    transformLightDirection(e) {
                        return c.aQ(e);
                    }
                    getRayDirectionFromPixel(e) {
                        throw new Error("Not implemented.");
                    }
                    projectTileCoordinates(e, i, s, o) {
                        const u = this.calculatePosMatrix(s);
                        let f;
                        o ? (f = [e, i, o(e, i), 1], c.at(f, f, u)) : (f = [e, i, 0, 1], aa(f, f, u));
                        const g = f[3];
                        return { point: new c.P(f[0] / g, f[1] / g), signedDistanceFromCamera: g, isOccluded: !1 };
                    }
                    populateCache(e) {
                        for (const i of e) this.calculatePosMatrix(i);
                    }
                    getMatrixForModel(e, i) {
                        const s = c.$.fromLngLat(e, i), o = s.meterInMercatorCoordinateUnits(), u = c.b1();
                        return c.L(u, u, [s.x, s.y, s.z]), c.a_(u, u, Math.PI), c.a$(u, u, Math.PI / 2), c.M(u, u, [-o, o, o]), u;
                    }
                    getProjectionDataForCustomLayer(e = !0) {
                        const i = new c.Y(0, 0, 0, 0, 0), s = this.getProjectionData({ overscaledTileID: i, applyGlobeMatrix: e }), o = L(i, this.worldSize);
                        c.N(o, this._viewProjMatrix, o), s.tileMercatorCoords = [0, 0, 1, 1];
                        const u = [c.Z, c.Z, this.worldSize / this._helper.pixelsPerMeter], f = c.b2();
                        return c.M(f, o, u), s.fallbackMatrix = f, s.mainMatrix = f, s;
                    }
                    getFastPathSimpleProjectionMatrix(e) {
                        return this.calculatePosMatrix(e);
                    }
                }
                function Pi() {
                    c.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                }
                function Oi(h) {
                    if (h.useSlerp) if (h.k < 1) {
                        const e = c.b3(h.startEulerAngles.roll, h.startEulerAngles.pitch, h.startEulerAngles.bearing), i = c.b3(h.endEulerAngles.roll, h.endEulerAngles.pitch, h.endEulerAngles.bearing), s = new Float64Array(4);
                        c.b4(s, e, i, h.k);
                        const o = c.b5(s);
                        h.tr.setRoll(o.roll), h.tr.setPitch(o.pitch), h.tr.setBearing(o.bearing);
                    } else h.tr.setRoll(h.endEulerAngles.roll), h.tr.setPitch(h.endEulerAngles.pitch), h.tr.setBearing(h.endEulerAngles.bearing);
                    else h.tr.setRoll(c.B.number(h.startEulerAngles.roll, h.endEulerAngles.roll, h.k)), h.tr.setPitch(c.B.number(h.startEulerAngles.pitch, h.endEulerAngles.pitch, h.k)), h.tr.setBearing(c.B.number(h.startEulerAngles.bearing, h.endEulerAngles.bearing, h.k));
                }
                function Ei(h, e, i, s, o) {
                    const u = o.padding, f = Ai(o.worldSize, i.getNorthWest()), g = Ai(o.worldSize, i.getNorthEast()), y = Ai(o.worldSize, i.getSouthEast()), x = Ai(o.worldSize, i.getSouthWest()), w = c.ab(-s), P = f.rotate(w), T = g.rotate(w), z = y.rotate(w), R = x.rotate(w), V = new c.P(Math.max(P.x, T.x, R.x, z.x), Math.max(P.y, T.y, R.y, z.y)), U = new c.P(Math.min(P.x, T.x, R.x, z.x), Math.min(P.y, T.y, R.y, z.y)), Z = V.sub(U), q = (o.width - (u.left + u.right + e.left + e.right)) / Z.x, J = (o.height - (u.top + u.bottom + e.top + e.bottom)) / Z.y;
                    if (J < 0 || q < 0) return void Pi();
                    const Y = Math.min(c.ah(o.scale * Math.min(q, J)), h.maxZoom), ee = c.P.convert(h.offset), ae = new c.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(c.ab(s)), te = ee.add(ae).mult(o.scale / c.ac(Y));
                    return { center: mr(o.worldSize, f.add(y).div(2).sub(te)), zoom: Y, bearing: s };
                }
                class bn {
                    get useGlobeControls() {
                        return !1;
                    }
                    handlePanInertia(e, i) {
                        return { easingOffset: e, easingCenter: i.center };
                    }
                    handleMapControlsRollPitchBearingZoom(e, i) {
                        e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta), e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta);
                    }
                    handleMapControlsPan(e, i, s) {
                        e.around.distSqr(i.centerPoint) < 0.01 || i.setLocationAtPoint(s, e.around);
                    }
                    cameraForBoxAndBearing(e, i, s, o, u) {
                        return Ei(e, i, s, o, u);
                    }
                    handleJumpToCenterZoom(e, i) {
                        e.zoom !== (i.zoom !== void 0 ? +i.zoom : e.zoom) && e.setZoom(+i.zoom), i.center !== void 0 && e.setCenter(c.Q.convert(i.center));
                    }
                    handleEaseTo(e, i) {
                        const s = e.zoom, o = e.padding, u = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, f = { roll: i.roll === void 0 ? e.roll : i.roll, pitch: i.pitch === void 0 ? e.pitch : i.pitch, bearing: i.bearing === void 0 ? e.bearing : i.bearing }, g = i.zoom !== void 0, y = !e.isPaddingEqual(i.padding);
                        let x = !1;
                        const w = g ? +i.zoom : e.zoom;
                        let P = e.centerPoint.add(i.offsetAsPoint);
                        const T = e.screenPointToLocation(P), { center: z, zoom: R } = e.getConstrained(c.Q.convert(i.center || T), w ?? s);
                        Da(e, z);
                        const V = Ai(e.worldSize, T), U = Ai(e.worldSize, z).sub(V), Z = c.ac(R - s);
                        return x = R !== s, {
                            easeFunc: (q) => {
                                if (x && e.setZoom(c.B.number(s, R, q)), c.b6(u, f) || Oi({ startEulerAngles: u, endEulerAngles: f, tr: e, k: q, useSlerp: u.roll != f.roll }), y && (e.interpolatePadding(o, i.padding, q), P = e.centerPoint.add(i.offsetAsPoint)), i.around) e.setLocationAtPoint(i.around, i.aroundPoint);
                                else {
                                    const J = c.ac(e.zoom - s), Y = R > s ? Math.min(2, Z) : Math.max(0.5, Z), ee = Math.pow(Y, 1 - q), ae = mr(e.worldSize, V.add(U.mult(q * ee)).mult(J));
                                    e.setLocationAtPoint(e.renderWorldCopies ? ae.wrap() : ae, P);
                                }
                            }, isZooming: x, elevationCenter: z
                        };
                    }
                    handleFlyTo(e, i) {
                        const s = i.zoom !== void 0, o = e.zoom, u = e.getConstrained(c.Q.convert(i.center || i.locationAtOffset), s ? +i.zoom : o), f = u.center, g = u.zoom;
                        Da(e, f);
                        const y = Ai(e.worldSize, i.locationAtOffset), x = Ai(e.worldSize, f).sub(y), w = x.mag(), P = c.ac(g - o);
                        let T;
                        if (i.minZoom !== void 0) {
                            const z = Math.min(+i.minZoom, o, g), R = e.getConstrained(f, z).zoom;
                            T = c.ac(R - o);
                        }
                        return {
                            easeFunc: (z, R, V, U) => {
                                e.setZoom(z === 1 ? g : o + c.ah(R));
                                const Z = z === 1 ? f : mr(e.worldSize, y.add(x.mult(V)).mult(R));
                                e.setLocationAtPoint(e.renderWorldCopies ? Z.wrap() : Z, U);
                            }, scaleOfZoom: P, targetCenter: f, scaleOfMinZoom: T, pixelPathLength: w
                        };
                    }
                }
                class vt {
                    constructor(e, i, s) {
                        this.blendFunction = e, this.blendColor = i, this.mask = s;
                    }
                }
                vt.Replace = [1, 0], vt.disabled = new vt(vt.Replace, c.b7.transparent, [!1, !1, !1, !1]), vt.unblended = new vt(vt.Replace, c.b7.transparent, [!0, !0, !0, !0]), vt.alphaBlended = new vt([1, 771], c.b7.transparent, [!0, !0, !0, !0]);
                const Ft = 2305;
                class ot {
                    constructor(e, i, s) {
                        this.enable = e, this.mode = i, this.frontFace = s;
                    }
                }
                ot.disabled = new ot(!1, 1029, Ft), ot.backCCW = new ot(!0, 1029, Ft), ot.frontCCW = new ot(!0, 1028, Ft);
                class Ke {
                    constructor(e, i, s) {
                        this.func = e, this.mask = i, this.range = s;
                    }
                }
                Ke.ReadOnly = !1, Ke.ReadWrite = !0, Ke.disabled = new Ke(519, Ke.ReadOnly, [0, 1]);
                const Ba = 7680;
                class et {
                    constructor(e, i, s, o, u, f) {
                        this.test = e, this.ref = i, this.mask = s, this.fail = o, this.depthFail = u, this.pass = f;
                    }
                }
                et.disabled = new et({ func: 519, mask: 0 }, 0, 0, Ba, Ba, Ba);
                const ps = /* @__PURE__ */ new WeakMap();
                function gi(h) {
                    var e;
                    if (ps.has(h)) return ps.get(h);
                    {
                        const i = (e = h.getParameter(h.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
                        return ps.set(h, i), i;
                    }
                }
                class bo {
                    get awaitingQuery() {
                        return !!this._readbackQueue;
                    }
                    constructor(e) {
                        this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
                        const i = e.context, s = i.gl;
                        this._texFormat = s.RGBA, this._texType = s.UNSIGNED_BYTE;
                        const o = new c.aI();
                        o.emplaceBack(-1, -1), o.emplaceBack(2, -1), o.emplaceBack(-1, 2);
                        const u = new c.aK();
                        u.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Ra(i.createVertexBuffer(o, Ti.members), i.createIndexBuffer(u), c.aJ.simpleSegment(0, 0, o.length, u.length)), this._resultBuffer = new Uint8Array(4), i.activeTexture.set(s.TEXTURE1);
                        const f = s.createTexture();
                        s.bindTexture(s.TEXTURE_2D, f), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.NEAREST), s.texImage2D(s.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(f), gi(s) && (this._pbo = s.createBuffer(), s.bindBuffer(s.PIXEL_PACK_BUFFER, this._pbo), s.bufferData(s.PIXEL_PACK_BUFFER, 4, s.STREAM_READ), s.bindBuffer(s.PIXEL_PACK_BUFFER, null));
                    }
                    destroy() {
                        const e = this._cachedRenderContext.context.gl;
                        this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
                    }
                    updateErrorLoop(e, i) {
                        const s = this._updateCount;
                        return this._readbackQueue ? s >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : s >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, i), this._updateCount++, this._measuredError;
                    }
                    _bindFramebuffer() {
                        const e = this._cachedRenderContext.context, i = e.gl;
                        e.activeTexture.set(i.TEXTURE1), i.bindTexture(i.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer);
                    }
                    _renderErrorTexture(e, i) {
                        const s = this._cachedRenderContext.context, o = s.gl;
                        if (this._bindFramebuffer(), s.viewport.set([0, 0, this._texWidth, this._texHeight]), s.clear({ color: c.b7.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(s, o.TRIANGLES, Ke.disabled, et.disabled, vt.unblended, ot.disabled, /* @__PURE__ */((u, f) => ({ u_input: u, u_output_expected: f }))(e, i), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && gi(o)) {
                            o.bindBuffer(o.PIXEL_PACK_BUFFER, this._pbo), o.readBuffer(o.COLOR_ATTACHMENT0), o.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), o.bindBuffer(o.PIXEL_PACK_BUFFER, null);
                            const u = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);
                            o.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: u };
                        } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
                    }
                    _tryReadback() {
                        const e = this._cachedRenderContext.context.gl;
                        if (this._pbo && this._readbackQueue && gi(e)) {
                            const i = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
                            if (i === e.WAIT_FAILED) return c.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
                            if (i === e.TIMEOUT_EXPIRED) return;
                            e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
                        } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
                        this._readbackQueue = null, this._measuredError = bo._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
                    }
                    static _parseRGBA8float(e) {
                        let i = 0;
                        return i += e[0] / 256, i += e[1] / 65536, i += e[2] / 16777216, e[3] < 127 && (i = -i), i / 128;
                    }
                }
                const wo = c.Z / 128;
                function wn(h, e) {
                    const i = h.granularity !== void 0 ? Math.max(h.granularity, 1) : 1, s = i + (h.generateBorders ? 2 : 0), o = i + (h.extendToNorthPole || h.generateBorders ? 1 : 0) + (h.extendToSouthPole || h.generateBorders ? 1 : 0), u = s + 1, f = o + 1, g = h.generateBorders ? -1 : 0, y = h.generateBorders || h.extendToNorthPole ? -1 : 0, x = i + (h.generateBorders ? 1 : 0), w = i + (h.generateBorders || h.extendToSouthPole ? 1 : 0), P = u * f, T = s * o * 6, z = u * f > 65536;
                    if (z && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
                    const R = z || e === "32bit", V = new Int16Array(2 * P);
                    let U = 0;
                    for (let J = y; J <= w; J++) for (let Y = g; Y <= x; Y++) {
                        let ee = Y / i * c.Z;
                        Y === -1 && (ee = -64), Y === i + 1 && (ee = c.Z + wo);
                        let ae = J / i * c.Z;
                        J === -1 && (ae = h.extendToNorthPole ? c.b9 : -64), J === i + 1 && (ae = h.extendToSouthPole ? c.ba : c.Z + wo), V[U++] = ee, V[U++] = ae;
                    }
                    const Z = R ? new Uint32Array(T) : new Uint16Array(T);
                    let q = 0;
                    for (let J = 0; J < o; J++) for (let Y = 0; Y < s; Y++) {
                        const ee = Y + 1 + J * u, ae = Y + (J + 1) * u, te = Y + 1 + (J + 1) * u;
                        Z[q++] = Y + J * u, Z[q++] = ae, Z[q++] = ee, Z[q++] = ee, Z[q++] = ae, Z[q++] = te;
                    }
                    return { vertices: V.buffer.slice(0), indices: Z.buffer.slice(0), uses32bitIndices: R };
                }
                const Fa = new c.aH({ fill: new c.bb(128, 2), line: new c.bb(512, 0), tile: new c.bb(128, 32), stencil: new c.bb(128, 1), circle: 3 });
                class Sn {
                    constructor() {
                        this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
                    }
                    get name() {
                        return "vertical-perspective";
                    }
                    get transitionState() {
                        return 1;
                    }
                    get useSubdivision() {
                        return !0;
                    }
                    get shaderVariantName() {
                        return "globe";
                    }
                    get shaderDefine() {
                        return "#define GLOBE";
                    }
                    get shaderPreludeCode() {
                        return Si.projectionGlobe;
                    }
                    get vertexShaderPreludeCode() {
                        return Si.projectionMercator.vertexSource;
                    }
                    get subdivisionGranularity() {
                        return Fa;
                    }
                    get useGlobeControls() {
                        return !0;
                    }
                    get latitudeErrorCorrectionRadians() {
                        return this._errorCorrectionUsable;
                    }
                    destroy() {
                        this._errorMeasurement && this._errorMeasurement.destroy();
                    }
                    updateGPUdependent(e) {
                        this._errorMeasurement || (this._errorMeasurement = new bo(e));
                        const i = c.S(this._errorQueryLatitudeDegrees), s = 2 * Math.atan(Math.exp(Math.PI - i * Math.PI * 2)) - 0.5 * Math.PI, o = this._errorMeasurement.updateErrorLoop(i, s), u = Ue.now();
                        o !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = o, this._errorMeasurementLastChangeTime = u);
                        const f = Math.min(Math.max((u - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
                        this._errorCorrectionUsable = c.bc(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, c.bd(f));
                    }
                    _getMeshKey(e) {
                        return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
                    }
                    getMeshFromTileID(e, i, s, o, u) {
                        const f = (u === "stencil" ? Fa.stencil : Fa.tile).getGranularityForZoomLevel(i.z);
                        return this._getMesh(e, { granularity: f, generateBorders: s, extendToNorthPole: i.y === 0 && o, extendToSouthPole: i.y === (1 << i.z) - 1 && o });
                    }
                    _getMesh(e, i) {
                        const s = this._getMeshKey(i);
                        if (s in this._tileMeshCache) return this._tileMeshCache[s];
                        const o = function (u, f) {
                            const g = wn(f, "16bit"), y = c.aI.deserialize({ arrayBuffer: g.vertices, length: g.vertices.byteLength / 2 / 2 }), x = c.aK.deserialize({ arrayBuffer: g.indices, length: g.indices.byteLength / 2 / 3 });
                            return new Ra(u.createVertexBuffer(y, Ti.members), u.createIndexBuffer(x), c.aJ.simpleSegment(0, 0, y.length, x.length));
                        }(e, i);
                        return this._tileMeshCache[s] = o, o;
                    }
                    recalculate(e) {
                    }
                    hasTransition() {
                        const e = Ue.now();
                        let i = !1;
                        return i = i || (e - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, i = i || this._errorMeasurement && this._errorMeasurement.awaitingQuery, i;
                    }
                    setErrorQueryLatitudeDegrees(e) {
                        this._errorQueryLatitudeDegrees = e;
                    }
                }
                const So = new c.r({ type: new c.D(c.v.projection.type) });
                class ds extends c.E {
                    constructor(e) {
                        super(), this._transitionable = new c.T(So), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new c.C(0)), this._mercatorProjection = new vn(), this._verticalPerspectiveProjection = new Sn();
                    }
                    get transitionState() {
                        const e = this.properties.get("type");
                        if (typeof e == "string" && e === "mercator") return 0;
                        if (typeof e == "string" && e === "vertical-perspective") return 1;
                        if (e instanceof c.be) {
                            if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
                            if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition;
                        }
                        return 1;
                    }
                    get useGlobeRendering() {
                        return this.transitionState > 0;
                    }
                    get latitudeErrorCorrectionRadians() {
                        return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
                    }
                    get currentProjection() {
                        return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
                    }
                    get name() {
                        return "globe";
                    }
                    get useSubdivision() {
                        return this.currentProjection.useSubdivision;
                    }
                    get shaderVariantName() {
                        return this.currentProjection.shaderVariantName;
                    }
                    get shaderDefine() {
                        return this.currentProjection.shaderDefine;
                    }
                    get shaderPreludeCode() {
                        return this.currentProjection.shaderPreludeCode;
                    }
                    get vertexShaderPreludeCode() {
                        return this.currentProjection.vertexShaderPreludeCode;
                    }
                    get subdivisionGranularity() {
                        return this.currentProjection.subdivisionGranularity;
                    }
                    get useGlobeControls() {
                        return this.transitionState > 0;
                    }
                    destroy() {
                        this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
                    }
                    updateGPUdependent(e) {
                        this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e);
                    }
                    getMeshFromTileID(e, i, s, o, u) {
                        return this.currentProjection.getMeshFromTileID(e, i, s, o, u);
                    }
                    setProjection(e) {
                        this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator");
                    }
                    updateTransitions(e) {
                        this._transitioning = this._transitionable.transitioned(e, this._transitioning);
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
                    }
                    recalculate(e) {
                        this.properties = this._transitioning.possiblyEvaluate(e);
                    }
                    setErrorQueryLatitudeDegrees(e) {
                        this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e);
                    }
                }
                function Tn(h) {
                    const e = ha(h.worldSize, h.center.lat);
                    return 2 * Math.PI * e;
                }
                function ca(h, e, i, s, o) {
                    const u = 1 / (1 << o), f = e / c.Z * u + s * u, g = c.bg((h / c.Z * u + i * u) * Math.PI * 2 + Math.PI, 2 * Math.PI), y = 2 * Math.atan(Math.exp(Math.PI - f * Math.PI * 2)) - 0.5 * Math.PI, x = Math.cos(y), w = new Float64Array(3);
                    return w[0] = Math.sin(g) * x, w[1] = Math.sin(y), w[2] = Math.cos(g) * x, w;
                }
                function ei(h) {
                    return function (e, i) {
                        const s = Math.cos(i), o = new Float64Array(3);
                        return o[0] = Math.sin(e) * s, o[1] = Math.sin(i), o[2] = Math.cos(e) * s, o;
                    }(h.lng * Math.PI / 180, h.lat * Math.PI / 180);
                }
                function ha(h, e) {
                    return h / (2 * Math.PI) / Math.cos(e * Math.PI / 180);
                }
                function Pn(h) {
                    const e = Math.asin(h[1]) / Math.PI * 180, i = Math.sqrt(h[0] * h[0] + h[2] * h[2]);
                    if (i > 1e-6) {
                        const s = h[0] / i, o = Math.acos(h[2] / i), u = (s > 0 ? o : -o) / Math.PI * 180;
                        return new c.Q(c.aL(u, -180, 180), e);
                    }
                    return new c.Q(0, e);
                }
                function $r(h) {
                    return Math.cos(h * Math.PI / 180);
                }
                function ti(h, e) {
                    const i = $r(h), s = $r(e);
                    return c.ah(s / i);
                }
                function fs(h, e) {
                    const i = h.rotate(e.bearingInRadians), s = e.zoom + ti(e.center.lat, 0), o = c.bc(1 / $r(e.center.lat), 1 / $r(Math.min(Math.abs(e.center.lat), 60)), c.bf(s, 7, 3, 0, 1)), u = 360 / Tn({ worldSize: e.worldSize, center: { lat: e.center.lat } });
                    return new c.Q(e.center.lng - i.x * u * o, c.ae(e.center.lat + i.y * u, -85.051129, c.af));
                }
                function ms(h) {
                    const e = 0.5 * h, i = Math.sin(e), s = Math.cos(e);
                    return Math.log(i + s) - Math.log(s - i);
                }
                function jl(h, e, i, s) {
                    const o = h.lat + i * s;
                    if (Math.abs(i) > 1) {
                        const u = (Math.sign(h.lat + i) !== Math.sign(h.lat) ? -Math.abs(h.lat) : Math.abs(h.lat)) * Math.PI / 180, f = Math.abs(h.lat + i) * Math.PI / 180, g = ms(u + s * (f - u)), y = ms(u), x = ms(f);
                        return new c.Q(h.lng + e * ((g - y) / (x - y)), o);
                    }
                    return new c.Q(h.lng + e * s, o);
                }
                class rh {
                    constructor(e) {
                        this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._aabbFactory = e;
                    }
                    recalculateCache() {
                        if (!this._hadAnyChanges) return;
                        const e = this._cachePrevious;
                        this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1;
                    }
                    getTileAABB(e, i, s, o) {
                        const u = `${e.z}_${e.x}_${e.y}`, f = this._cache.get(u);
                        if (f) return f;
                        const g = this._cachePrevious.get(u);
                        if (g) return this._cache.set(u, g), g;
                        const y = this._aabbFactory(e, i, s, o);
                        return this._cache.set(u, y), this._hadAnyChanges = !0, y;
                    }
                }
                function _i(h, e, i) {
                    const s = h - e;
                    return s < 0 ? -s : Math.max(0, s - i);
                }
                function Mn(h, e, i, s, o) {
                    const u = h - i;
                    let f;
                    return f = u < 0 ? Math.min(-u, 1 + u - o) : u > 1 ? Math.min(Math.max(u - o, 0), 1 - u) : 0, Math.max(f, _i(e, s, o));
                }
                class gr {
                    constructor() {
                        this._aabbCache = new rh(this._computeTileAABB);
                    }
                    recalculateCache() {
                        this._aabbCache.recalculateCache();
                    }
                    distanceToTile2d(e, i, s, o) {
                        const u = 1 << s.z, f = 1 / u, g = s.x / u, y = s.y / u;
                        let x = 2;
                        return x = Math.min(x, Mn(e, i, g, y, f)), x = Math.min(x, Mn(e, i, g + 0.5, -y - f, f)), x = Math.min(x, Mn(e, i, g + 0.5, 2 - y - f, f)), x;
                    }
                    getWrap(e, i, s) {
                        const o = 1 << i.z, u = 1 / o, f = i.x / o, g = _i(e.x, f, u), y = _i(e.x, f - 1, u), x = _i(e.x, f + 1, u), w = Math.min(g, y, x);
                        return w === x ? 1 : w === y ? -1 : 0;
                    }
                    allowVariableZoom(e, i) {
                        return pe(e, i) > 4;
                    }
                    allowWorldCopies() {
                        return !1;
                    }
                    getTileAABB(e, i, s, o) {
                        return this._aabbCache.getTileAABB(e, i, s, o);
                    }
                    _computeTileAABB(e, i, s, o) {
                        if (e.z <= 0) return new Ut([-1, -1, -1], [1, 1, 1]);
                        if (e.z === 1) return new Ut([e.x === 0 ? -1 : 0, e.y === 0 ? 0 : -1, -1], [e.x === 0 ? 0 : 1, e.y === 0 ? 1 : 0, 1]);
                        {
                            const u = [ca(0, 0, e.x, e.y, e.z), ca(c.Z, 0, e.x, e.y, e.z), ca(c.Z, c.Z, e.x, e.y, e.z), ca(0, c.Z, e.x, e.y, e.z)], f = [1, 1, 1], g = [-1, -1, -1];
                            for (const y of u) for (let x = 0; x < 3; x++) f[x] = Math.min(f[x], y[x]), g[x] = Math.max(g[x], y[x]);
                            if (e.y === 0 || e.y === (1 << e.z) - 1) {
                                const y = [0, e.y === 0 ? 1 : -1, 0];
                                for (let x = 0; x < 3; x++) f[x] = Math.min(f[x], y[x]), g[x] = Math.max(g[x], y[x]);
                            }
                            return new Ut(f, g);
                        }
                    }
                }
                class ua {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix;
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix;
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits;
                    }
                    get centerOffset() {
                        return this._helper.centerOffset;
                    }
                    get size() {
                        return this._helper.size;
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix;
                    }
                    get centerPoint() {
                        return this._helper.centerPoint;
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter;
                    }
                    setMinZoom(e) {
                        this._helper.setMinZoom(e);
                    }
                    setMaxZoom(e) {
                        this._helper.setMaxZoom(e);
                    }
                    setMinPitch(e) {
                        this._helper.setMinPitch(e);
                    }
                    setMaxPitch(e) {
                        this._helper.setMaxPitch(e);
                    }
                    setRenderWorldCopies(e) {
                        this._helper.setRenderWorldCopies(e);
                    }
                    setBearing(e) {
                        this._helper.setBearing(e);
                    }
                    setPitch(e) {
                        this._helper.setPitch(e);
                    }
                    setRoll(e) {
                        this._helper.setRoll(e);
                    }
                    setFov(e) {
                        this._helper.setFov(e);
                    }
                    setZoom(e) {
                        this._helper.setZoom(e);
                    }
                    setCenter(e) {
                        this._helper.setCenter(e);
                    }
                    setElevation(e) {
                        this._helper.setElevation(e);
                    }
                    setMinElevationForCurrentTile(e) {
                        this._helper.setMinElevationForCurrentTile(e);
                    }
                    setPadding(e) {
                        this._helper.setPadding(e);
                    }
                    interpolatePadding(e, i, s) {
                        return this._helper.interpolatePadding(e, i, s);
                    }
                    isPaddingEqual(e) {
                        return this._helper.isPaddingEqual(e);
                    }
                    resize(e, i) {
                        this._helper.resize(e, i);
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds();
                    }
                    setMaxBounds(e) {
                        this._helper.setMaxBounds(e);
                    }
                    overrideNearFarZ(e, i) {
                        this._helper.overrideNearFarZ(e, i);
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride();
                    }
                    getCameraQueryGeometry(e) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
                    }
                    get tileSize() {
                        return this._helper.tileSize;
                    }
                    get tileZoom() {
                        return this._helper.tileZoom;
                    }
                    get scale() {
                        return this._helper.scale;
                    }
                    get worldSize() {
                        return this._helper.worldSize;
                    }
                    get width() {
                        return this._helper.width;
                    }
                    get height() {
                        return this._helper.height;
                    }
                    get lngRange() {
                        return this._helper.lngRange;
                    }
                    get latRange() {
                        return this._helper.latRange;
                    }
                    get minZoom() {
                        return this._helper.minZoom;
                    }
                    get maxZoom() {
                        return this._helper.maxZoom;
                    }
                    get zoom() {
                        return this._helper.zoom;
                    }
                    get center() {
                        return this._helper.center;
                    }
                    get minPitch() {
                        return this._helper.minPitch;
                    }
                    get maxPitch() {
                        return this._helper.maxPitch;
                    }
                    get pitch() {
                        return this._helper.pitch;
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians;
                    }
                    get roll() {
                        return this._helper.roll;
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians;
                    }
                    get bearing() {
                        return this._helper.bearing;
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians;
                    }
                    get fov() {
                        return this._helper.fov;
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians;
                    }
                    get elevation() {
                        return this._helper.elevation;
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile;
                    }
                    get padding() {
                        return this._helper.padding;
                    }
                    get unmodified() {
                        return this._helper.unmodified;
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies;
                    }
                    get nearZ() {
                        return this._helper.nearZ;
                    }
                    get farZ() {
                        return this._helper.farZ;
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ;
                    }
                    setTransitionState(e) {
                    }
                    constructor() {
                        this._cachedClippingPlane = c.bk(), this._projectionMatrix = c.b1(), this._globeViewProjMatrix32f = c.b0(), this._globeViewProjMatrixNoCorrection = c.b1(), this._globeViewProjMatrixNoCorrectionInverted = c.b1(), this._globeProjMatrixInverted = c.b1(), this._cameraPosition = c.bh(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new ci({
                            calcMatrices: () => {
                                this._calcMatrices();
                            }, getConstrained: (e, i) => this.getConstrained(e, i)
                        }), this._coveringTilesDetailsProvider = new gr();
                    }
                    clone() {
                        const e = new ua();
                        return e.apply(this), e;
                    }
                    apply(e, i) {
                        this._globeLatitudeErrorCorrectionRadians = i || 0, this._helper.apply(e);
                    }
                    get projectionMatrix() {
                        return this._projectionMatrix;
                    }
                    get modelViewProjectionMatrix() {
                        return this._globeViewProjMatrixNoCorrection;
                    }
                    get inverseProjectionMatrix() {
                        return this._globeProjMatrixInverted;
                    }
                    get cameraPosition() {
                        const e = c.bh();
                        return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e;
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance;
                    }
                    getProjectionData(e) {
                        const { overscaledTileID: i, applyGlobeMatrix: s } = e, o = this._helper.getMercatorTileCoordinates(i);
                        return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: o, clippingPlane: this._cachedClippingPlane, projectionTransition: s ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
                    }
                    _computeClippingPlane(e) {
                        const i = this.pitchInRadians, s = this.cameraToCenterDistance / e, o = Math.sin(i) * s, u = Math.cos(i) * s + 1, f = 1 / Math.sqrt(o * o + u * u) * 1;
                        let g = -o, y = u;
                        const x = Math.sqrt(g * g + y * y);
                        g /= x, y /= x;
                        const w = [0, g, y];
                        c.bl(w, w, [0, 0, 0], -this.bearingInRadians), c.bm(w, w, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), c.bn(w, w, [0, 0, 0], this.center.lng * Math.PI / 180);
                        const P = 1 / c.bo(w);
                        return c.aO(w, w, P), [...w, -f * P];
                    }
                    isLocationOccluded(e) {
                        return !this.isSurfacePointVisible(ei(e));
                    }
                    transformLightDirection(e) {
                        const i = this._helper._center.lng * Math.PI / 180, s = this._helper._center.lat * Math.PI / 180, o = Math.cos(s), u = [Math.sin(i) * o, Math.sin(s), Math.cos(i) * o], f = [u[2], 0, -u[0]], g = [0, 0, 0];
                        c.aU(g, f, u), c.aT(f, f), c.aT(g, g);
                        const y = [0, 0, 0];
                        return c.aT(y, [f[0] * e[0] + g[0] * e[1] + u[0] * e[2], f[1] * e[0] + g[1] * e[1] + u[1] * e[2], f[2] * e[0] + g[2] * e[1] + u[2] * e[2]]), y;
                    }
                    getPixelScale() {
                        return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
                    }
                    getCircleRadiusCorrection() {
                        return Math.cos(this._helper._center.lat * Math.PI / 180);
                    }
                    getPitchedTextCorrection(e, i, s) {
                        const o = function (g, y, x) {
                            const w = 1 / (1 << x.z);
                            return new c.$(g / c.Z * w + x.x * w, y / c.Z * w + x.y * w);
                        }(e, i, s.canonical), u = (f = o.y, [c.bg(o.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - f * Math.PI * 2)) - 0.5 * Math.PI]);
                        var f;
                        return this.getCircleRadiusCorrection() / Math.cos(u[1]);
                    }
                    projectTileCoordinates(e, i, s, o) {
                        const u = s.canonical, f = ca(e, i, u.x, u.y, u.z), g = 1 + (o ? o(e, i) : 0) / c.bu, y = [f[0] * g, f[1] * g, f[2] * g, 1];
                        c.at(y, y, this._globeViewProjMatrixNoCorrection);
                        const x = this._cachedClippingPlane, w = x[0] * f[0] + x[1] * f[1] + x[2] * f[2] + x[3] < 0;
                        return { point: new c.P(y[0] / y[3], y[1] / y[3]), signedDistanceFromCamera: y[3], isOccluded: w };
                    }
                    _calcMatrices() {
                        if (!this._helper._width || !this._helper._height) return;
                        const e = ha(this.worldSize, this.center.lat), i = c.b2(), s = c.b2();
                        this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), c.aY(i, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
                        const o = this.centerOffset;
                        i[8] = 2 * -o.x / this._helper._width, i[9] = 2 * o.y / this._helper._height, this._projectionMatrix = c.aZ(i), this._globeProjMatrixInverted = c.b2(), c.an(this._globeProjMatrixInverted, i), c.L(i, i, [0, 0, -this.cameraToCenterDistance]), c.a_(i, i, this.rollInRadians), c.a$(i, i, -this.pitchInRadians), c.a_(i, i, this.bearingInRadians), c.L(i, i, [0, 0, -e]);
                        const u = c.bh();
                        u[0] = e, u[1] = e, u[2] = e, c.a$(s, i, this.center.lat * Math.PI / 180), c.bp(s, s, -this.center.lng * Math.PI / 180), c.M(s, s, u), this._globeViewProjMatrixNoCorrection = s, c.a$(i, i, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), c.bp(i, i, -this.center.lng * Math.PI / 180), c.M(i, i, u), this._globeViewProjMatrix32f = new Float32Array(i), this._globeViewProjMatrixNoCorrectionInverted = c.b2(), c.an(this._globeViewProjMatrixNoCorrectionInverted, s);
                        const f = c.bh();
                        this._cameraPosition = c.bh(), this._cameraPosition[2] = this.cameraToCenterDistance / e, c.bl(this._cameraPosition, this._cameraPosition, f, -this.rollInRadians), c.bm(this._cameraPosition, this._cameraPosition, f, this.pitchInRadians), c.bl(this._cameraPosition, this._cameraPosition, f, -this.bearingInRadians), c.aP(this._cameraPosition, this._cameraPosition, [0, 0, 1]), c.bm(this._cameraPosition, this._cameraPosition, f, -this.center.lat * Math.PI / 180), c.bn(this._cameraPosition, this._cameraPosition, f, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
                        const g = c.aZ(this._globeViewProjMatrixNoCorrectionInverted);
                        c.M(g, g, [1, 1, -1]), this._cachedFrustum = St.fromInvProjectionMatrix(g);
                    }
                    calculateFogMatrix(e) {
                        c.w("calculateFogMatrix is not supported on globe projection.");
                        const i = c.b2();
                        return c.ad(i), i;
                    }
                    getVisibleUnwrappedCoordinates(e) {
                        return [new c.aW(0, e)];
                    }
                    getCameraFrustum() {
                        return this._cachedFrustum;
                    }
                    getClippingPlane() {
                        return this._cachedClippingPlane;
                    }
                    getCoveringTilesDetailsProvider() {
                        return this._coveringTilesDetailsProvider;
                    }
                    recalculateZoomAndCenter(e) {
                        e && c.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
                    }
                    maxPitchScaleFactor() {
                        return 1;
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint();
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude();
                    }
                    getCameraLngLat() {
                        return this._helper.getCameraLngLat();
                    }
                    lngLatToCameraDepth(e, i) {
                        if (!this._globeViewProjMatrixNoCorrection) return 1;
                        const s = ei(e);
                        c.aO(s, s, 1 + i / c.bu);
                        const o = c.bk();
                        return c.at(o, [s[0], s[1], s[2], 1], this._globeViewProjMatrixNoCorrection), o[2] / o[3];
                    }
                    populateCache(e) {
                    }
                    getBounds() {
                        const e = 0.5 * this.width, i = 0.5 * this.height, s = [new c.P(0, 0), new c.P(e, 0), new c.P(this.width, 0), new c.P(this.width, i), new c.P(this.width, this.height), new c.P(e, this.height), new c.P(0, this.height), new c.P(0, i)], o = [];
                        for (const P of s) o.push(this.unprojectScreenPoint(P));
                        let u = 0, f = 0, g = 0, y = 0;
                        const x = this.center;
                        for (const P of o) {
                            const T = c.bq(x.lng, P.lng), z = c.bq(x.lat, P.lat);
                            T < f && (f = T), T > u && (u = T), z < y && (y = z), z > g && (g = z);
                        }
                        const w = [x.lng + f, x.lat + y, x.lng + u, x.lat + g];
                        return this.isSurfacePointOnScreen([0, 1, 0]) && (w[3] = 90, w[0] = -180, w[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (w[1] = -90, w[0] = -180, w[2] = 180), new bt(w);
                    }
                    getConstrained(e, i) {
                        const s = c.ae(e.lat, -85.051129, c.af), o = c.ae(+i, this.minZoom + ti(0, s), this.maxZoom);
                        return { center: new c.Q(e.lng, s), zoom: o };
                    }
                    calculateCenterFromCameraLngLatAlt(e, i, s, o) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(e, i, s, o);
                    }
                    setLocationAtPoint(e, i) {
                        const s = ei(this.unprojectScreenPoint(i)), o = ei(e), u = c.bh();
                        c.br(u);
                        const f = c.bh();
                        c.bn(f, s, u, -this.center.lng * Math.PI / 180), c.bm(f, f, u, this.center.lat * Math.PI / 180);
                        const g = o[0] * o[0] + o[2] * o[2], y = f[0] * f[0];
                        if (g < y) return;
                        const x = Math.sqrt(g - y), w = -x, P = c.bs(o[0], o[2], f[0], x), T = c.bs(o[0], o[2], f[0], w), z = c.bh();
                        c.bn(z, o, u, -P);
                        const R = c.bs(z[1], z[2], f[1], f[2]), V = c.bh();
                        c.bn(V, o, u, -T);
                        const U = c.bs(V[1], V[2], f[1], f[2]), Z = 0.5 * Math.PI, q = R >= -Z && R <= Z, J = U >= -Z && U <= Z;
                        let Y, ee;
                        if (q && J) {
                            const be = this.center.lng * Math.PI / 180, ge = this.center.lat * Math.PI / 180;
                            c.bv(P, be) + c.bv(R, ge) < c.bv(T, be) + c.bv(U, ge) ? (Y = P, ee = R) : (Y = T, ee = U);
                        } else if (q) Y = P, ee = R;
                        else {
                            if (!J) return;
                            Y = T, ee = U;
                        }
                        const ae = Y / Math.PI * 180, te = ee / Math.PI * 180, he = this.center.lat;
                        this.setCenter(new c.Q(ae, c.ae(te, -90, 90))), this.setZoom(this.zoom + ti(he, this.center.lat));
                    }
                    locationToScreenPoint(e, i) {
                        const s = ei(e);
                        if (i) {
                            const o = i.getElevationForLngLatZoom(e, this._helper._tileZoom);
                            c.aO(s, s, 1 + o / c.bu);
                        }
                        return this._projectSurfacePointToScreen(s);
                    }
                    _projectSurfacePointToScreen(e) {
                        const i = c.bk();
                        return c.at(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], new c.P((0.5 * i[0] + 0.5) * this.width, (0.5 * -i[1] + 0.5) * this.height);
                    }
                    screenPointToMercatorCoordinate(e, i) {
                        if (i) {
                            const s = i.pointCoordinate(e);
                            if (s) return s;
                        }
                        return c.$.fromLngLat(this.unprojectScreenPoint(e));
                    }
                    screenPointToLocation(e, i) {
                        var s;
                        return (s = this.screenPointToMercatorCoordinate(e, i)) === null || s === void 0 ? void 0 : s.toLngLat();
                    }
                    isPointOnMapSurface(e, i) {
                        const s = this._cameraPosition, o = this.getRayDirectionFromPixel(e);
                        return !!this.rayPlanetIntersection(s, o);
                    }
                    getRayDirectionFromPixel(e) {
                        const i = c.bk();
                        i[0] = e.x / this.width * 2 - 1, i[1] = -1 * (e.y / this.height * 2 - 1), i[2] = 1, i[3] = 1, c.at(i, i, this._globeViewProjMatrixNoCorrectionInverted), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3];
                        const s = c.bh();
                        s[0] = i[0] - this._cameraPosition[0], s[1] = i[1] - this._cameraPosition[1], s[2] = i[2] - this._cameraPosition[2];
                        const o = c.bh();
                        return c.aT(o, s), o;
                    }
                    isSurfacePointVisible(e) {
                        const i = this._cachedClippingPlane;
                        return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] >= 0;
                    }
                    isSurfacePointOnScreen(e) {
                        if (!this.isSurfacePointVisible(e)) return !1;
                        const i = c.bk();
                        return c.at(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3], i[0] > -1 && i[0] < 1 && i[1] > -1 && i[1] < 1 && i[2] > -1 && i[2] < 1;
                    }
                    rayPlanetIntersection(e, i) {
                        const s = c.aV(e, i), o = c.bh(), u = c.bh();
                        c.aO(u, i, s), c.aS(o, e, u);
                        const f = 1 - c.aV(o, o);
                        if (f < 0) return null;
                        const g = c.aV(e, e) - 1, y = -s + (s < 0 ? 1 : -1) * Math.sqrt(f), x = g / y, w = y;
                        return { tMin: Math.min(x, w), tMax: Math.max(x, w) };
                    }
                    unprojectScreenPoint(e) {
                        const i = this._cameraPosition, s = this.getRayDirectionFromPixel(e), o = this.rayPlanetIntersection(i, s);
                        if (o) {
                            const w = c.bh();
                            c.aP(w, i, [s[0] * o.tMin, s[1] * o.tMin, s[2] * o.tMin]);
                            const P = c.bh();
                            return c.aT(P, w), Pn(P);
                        }
                        const u = this._cachedClippingPlane, f = u[0] * s[0] + u[1] * s[1] + u[2] * s[2], g = -c.bt(u, i) / f, y = c.bh();
                        if (g > 0) c.aP(y, i, [s[0] * g, s[1] * g, s[2] * g]);
                        else {
                            const w = c.bh();
                            c.aP(w, i, [2 * s[0], 2 * s[1], 2 * s[2]]);
                            const P = c.bt(this._cachedClippingPlane, w);
                            c.aS(y, w, [this._cachedClippingPlane[0] * P, this._cachedClippingPlane[1] * P, this._cachedClippingPlane[2] * P]);
                        }
                        const x = function (w) {
                            const P = c.bh();
                            return P[0] = w[0] * -w[3], P[1] = w[1] * -w[3], P[2] = w[2] * -w[3], { center: P, radius: Math.sqrt(1 - w[3] * w[3]) };
                        }(u);
                        return Pn(function (w, P, T) {
                            const z = c.bh();
                            c.aS(z, T, w);
                            const R = c.bh();
                            return c.bi(R, w, z, P / c.bj(z)), R;
                        }(x.center, x.radius, y));
                    }
                    getMatrixForModel(e, i) {
                        const s = c.Q.convert(e), o = 1 / c.bu, u = c.b1();
                        return c.bp(u, u, s.lng / 180 * Math.PI), c.a$(u, u, -s.lat / 180 * Math.PI), c.L(u, u, [0, 0, 1 + i / c.bu]), c.a$(u, u, 0.5 * Math.PI), c.M(u, u, [o, o, o]), u;
                    }
                    getProjectionDataForCustomLayer(e = !0) {
                        const i = this.getProjectionData({ overscaledTileID: new c.Y(0, 0, 0, 0, 0), applyGlobeMatrix: e });
                        return i.tileMercatorCoords = [0, 0, 1, 1], i;
                    }
                    getFastPathSimpleProjectionMatrix(e) {
                    }
                }
                class In {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix;
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix;
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits;
                    }
                    get centerOffset() {
                        return this._helper.centerOffset;
                    }
                    get size() {
                        return this._helper.size;
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix;
                    }
                    get centerPoint() {
                        return this._helper.centerPoint;
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter;
                    }
                    setMinZoom(e) {
                        this._helper.setMinZoom(e);
                    }
                    setMaxZoom(e) {
                        this._helper.setMaxZoom(e);
                    }
                    setMinPitch(e) {
                        this._helper.setMinPitch(e);
                    }
                    setMaxPitch(e) {
                        this._helper.setMaxPitch(e);
                    }
                    setRenderWorldCopies(e) {
                        this._helper.setRenderWorldCopies(e);
                    }
                    setBearing(e) {
                        this._helper.setBearing(e);
                    }
                    setPitch(e) {
                        this._helper.setPitch(e);
                    }
                    setRoll(e) {
                        this._helper.setRoll(e);
                    }
                    setFov(e) {
                        this._helper.setFov(e);
                    }
                    setZoom(e) {
                        this._helper.setZoom(e);
                    }
                    setCenter(e) {
                        this._helper.setCenter(e);
                    }
                    setElevation(e) {
                        this._helper.setElevation(e);
                    }
                    setMinElevationForCurrentTile(e) {
                        this._helper.setMinElevationForCurrentTile(e);
                    }
                    setPadding(e) {
                        this._helper.setPadding(e);
                    }
                    interpolatePadding(e, i, s) {
                        return this._helper.interpolatePadding(e, i, s);
                    }
                    isPaddingEqual(e) {
                        return this._helper.isPaddingEqual(e);
                    }
                    resize(e, i, s = !0) {
                        this._helper.resize(e, i, s);
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds();
                    }
                    setMaxBounds(e) {
                        this._helper.setMaxBounds(e);
                    }
                    overrideNearFarZ(e, i) {
                        this._helper.overrideNearFarZ(e, i);
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride();
                    }
                    getCameraQueryGeometry(e) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
                    }
                    get tileSize() {
                        return this._helper.tileSize;
                    }
                    get tileZoom() {
                        return this._helper.tileZoom;
                    }
                    get scale() {
                        return this._helper.scale;
                    }
                    get worldSize() {
                        return this._helper.worldSize;
                    }
                    get width() {
                        return this._helper.width;
                    }
                    get height() {
                        return this._helper.height;
                    }
                    get lngRange() {
                        return this._helper.lngRange;
                    }
                    get latRange() {
                        return this._helper.latRange;
                    }
                    get minZoom() {
                        return this._helper.minZoom;
                    }
                    get maxZoom() {
                        return this._helper.maxZoom;
                    }
                    get zoom() {
                        return this._helper.zoom;
                    }
                    get center() {
                        return this._helper.center;
                    }
                    get minPitch() {
                        return this._helper.minPitch;
                    }
                    get maxPitch() {
                        return this._helper.maxPitch;
                    }
                    get pitch() {
                        return this._helper.pitch;
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians;
                    }
                    get roll() {
                        return this._helper.roll;
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians;
                    }
                    get bearing() {
                        return this._helper.bearing;
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians;
                    }
                    get fov() {
                        return this._helper.fov;
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians;
                    }
                    get elevation() {
                        return this._helper.elevation;
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile;
                    }
                    get padding() {
                        return this._helper.padding;
                    }
                    get unmodified() {
                        return this._helper.unmodified;
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies;
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance;
                    }
                    get nearZ() {
                        return this._helper.nearZ;
                    }
                    get farZ() {
                        return this._helper.farZ;
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ;
                    }
                    get isGlobeRendering() {
                        return this._globeness > 0;
                    }
                    setTransitionState(e, i) {
                        this._globeness = e, this._globeLatitudeErrorCorrectionRadians = i, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().recalculateCache(), this._mercatorTransform.getCoveringTilesDetailsProvider().recalculateCache();
                    }
                    get currentTransform() {
                        return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
                    }
                    constructor() {
                        this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new ci({
                            calcMatrices: () => {
                                this._calcMatrices();
                            }, getConstrained: (e, i) => this.getConstrained(e, i)
                        }), this._globeness = 1, this._mercatorTransform = new La(), this._verticalPerspectiveTransform = new ua();
                    }
                    clone() {
                        const e = new In();
                        return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e;
                    }
                    apply(e) {
                        this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
                    }
                    get projectionMatrix() {
                        return this.currentTransform.projectionMatrix;
                    }
                    get modelViewProjectionMatrix() {
                        return this.currentTransform.modelViewProjectionMatrix;
                    }
                    get inverseProjectionMatrix() {
                        return this.currentTransform.inverseProjectionMatrix;
                    }
                    get cameraPosition() {
                        return this.currentTransform.cameraPosition;
                    }
                    getProjectionData(e) {
                        const i = this._mercatorTransform.getProjectionData(e), s = this._verticalPerspectiveTransform.getProjectionData(e);
                        return { mainMatrix: this.isGlobeRendering ? s.mainMatrix : i.mainMatrix, clippingPlane: s.clippingPlane, tileMercatorCoords: s.tileMercatorCoords, projectionTransition: e.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: i.fallbackMatrix };
                    }
                    isLocationOccluded(e) {
                        return this.currentTransform.isLocationOccluded(e);
                    }
                    transformLightDirection(e) {
                        return this.currentTransform.transformLightDirection(e);
                    }
                    getPixelScale() {
                        return c.bc(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
                    }
                    getCircleRadiusCorrection() {
                        return c.bc(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
                    }
                    getPitchedTextCorrection(e, i, s) {
                        const o = this._mercatorTransform.getPitchedTextCorrection(e, i, s), u = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, i, s);
                        return c.bc(o, u, this._globeness);
                    }
                    projectTileCoordinates(e, i, s, o) {
                        return this.currentTransform.projectTileCoordinates(e, i, s, o);
                    }
                    _calcMatrices() {
                        this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
                    }
                    calculateFogMatrix(e) {
                        return this.currentTransform.calculateFogMatrix(e);
                    }
                    getVisibleUnwrappedCoordinates(e) {
                        return this.currentTransform.getVisibleUnwrappedCoordinates(e);
                    }
                    getCameraFrustum() {
                        return this.currentTransform.getCameraFrustum();
                    }
                    getClippingPlane() {
                        return this.currentTransform.getClippingPlane();
                    }
                    getCoveringTilesDetailsProvider() {
                        return this.currentTransform.getCoveringTilesDetailsProvider();
                    }
                    recalculateZoomAndCenter(e) {
                        this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e);
                    }
                    maxPitchScaleFactor() {
                        return this._mercatorTransform.maxPitchScaleFactor();
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint();
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude();
                    }
                    getCameraLngLat() {
                        return this._helper.getCameraLngLat();
                    }
                    lngLatToCameraDepth(e, i) {
                        return this.currentTransform.lngLatToCameraDepth(e, i);
                    }
                    populateCache(e) {
                        this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e);
                    }
                    getBounds() {
                        return this.currentTransform.getBounds();
                    }
                    getConstrained(e, i) {
                        return this.currentTransform.getConstrained(e, i);
                    }
                    calculateCenterFromCameraLngLatAlt(e, i, s, o) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(e, i, s, o);
                    }
                    setLocationAtPoint(e, i) {
                        if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, i), void this.apply(this._mercatorTransform);
                        this._verticalPerspectiveTransform.setLocationAtPoint(e, i), this.apply(this._verticalPerspectiveTransform);
                    }
                    locationToScreenPoint(e, i) {
                        return this.currentTransform.locationToScreenPoint(e, i);
                    }
                    screenPointToMercatorCoordinate(e, i) {
                        return this.currentTransform.screenPointToMercatorCoordinate(e, i);
                    }
                    screenPointToLocation(e, i) {
                        return this.currentTransform.screenPointToLocation(e, i);
                    }
                    isPointOnMapSurface(e, i) {
                        return this.currentTransform.isPointOnMapSurface(e, i);
                    }
                    getRayDirectionFromPixel(e) {
                        return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e);
                    }
                    getMatrixForModel(e, i) {
                        return this.currentTransform.getMatrixForModel(e, i);
                    }
                    getProjectionDataForCustomLayer(e = !0) {
                        const i = this._mercatorTransform.getProjectionDataForCustomLayer(e);
                        if (!this.isGlobeRendering) return i;
                        const s = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
                        return s.fallbackMatrix = i.mainMatrix, s;
                    }
                    getFastPathSimpleProjectionMatrix(e) {
                        return this.currentTransform.getFastPathSimpleProjectionMatrix(e);
                    }
                }
                class Hi {
                    get useGlobeControls() {
                        return !0;
                    }
                    handlePanInertia(e, i) {
                        const s = fs(e, i);
                        return Math.abs(s.lng - i.center.lng) > 180 && (s.lng = i.center.lng + 179.5 * Math.sign(s.lng - i.center.lng)), { easingCenter: s, easingOffset: new c.P(0, 0) };
                    }
                    handleMapControlsRollPitchBearingZoom(e, i) {
                        const s = e.around, o = i.screenPointToLocation(s);
                        e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta);
                        const u = i.zoom;
                        e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta);
                        const f = i.zoom - u;
                        if (f === 0) return;
                        const g = c.bq(i.center.lng, o.lng), y = g / (Math.abs(g / 180) + 1), x = c.bq(i.center.lat, o.lat), w = i.getRayDirectionFromPixel(s), P = i.cameraPosition, T = -1 * c.aV(P, w), z = c.bh();
                        c.aP(z, P, [w[0] * T, w[1] * T, w[2] * T]);
                        const R = c.bo(z) - 1, V = Math.exp(0.5 * -Math.max(R - 0.3, 0)), U = ha(i.worldSize, i.center.lat) / Math.min(i.width, i.height), Z = c.bf(U, 0.9, 0.5, 1, 0.25), q = (1 - c.ac(-f)) * Math.min(V, Z), J = i.center.lat, Y = i.zoom, ee = new c.Q(i.center.lng + y * q, c.ae(i.center.lat + x * q, -85.051129, c.af));
                        i.setLocationAtPoint(o, s);
                        const ae = i.center, te = c.bf(Math.abs(g), 45, 85, 0, 1), he = c.bf(U, 0.75, 0.35, 0, 1), be = Math.pow(Math.max(te, he), 0.25), ge = c.bq(ae.lng, ee.lng), _e = c.bq(ae.lat, ee.lat);
                        i.setCenter(new c.Q(ae.lng + ge * be, ae.lat + _e * be).wrap()), i.setZoom(Y + ti(J, i.center.lat));
                    }
                    handleMapControlsPan(e, i, s) {
                        if (!e.panDelta) return;
                        const o = i.center.lat, u = i.zoom;
                        i.setCenter(fs(e.panDelta, i).wrap()), i.setZoom(u + ti(o, i.center.lat));
                    }
                    cameraForBoxAndBearing(e, i, s, o, u) {
                        const f = Ei(e, i, s, o, u), g = i.left / u.width * 2 - 1, y = (u.width - i.right) / u.width * 2 - 1, x = i.top / u.height * -2 + 1, w = (u.height - i.bottom) / u.height * -2 + 1, P = c.bq(s.getWest(), s.getEast()) < 0, T = P ? s.getEast() : s.getWest(), z = P ? s.getWest() : s.getEast(), R = Math.max(s.getNorth(), s.getSouth()), V = Math.min(s.getNorth(), s.getSouth()), U = T + 0.5 * c.bq(T, z), Z = R + 0.5 * c.bq(R, V), q = u.clone();
                        q.setCenter(f.center), q.setBearing(f.bearing), q.setPitch(0), q.setRoll(0), q.setZoom(f.zoom);
                        const J = q.modelViewProjectionMatrix, Y = [ei(s.getNorthWest()), ei(s.getNorthEast()), ei(s.getSouthWest()), ei(s.getSouthEast()), ei(new c.Q(z, Z)), ei(new c.Q(T, Z)), ei(new c.Q(U, R)), ei(new c.Q(U, V))], ee = ei(f.center);
                        let ae = Number.POSITIVE_INFINITY;
                        for (const te of Y) g < 0 && (ae = Hi.getLesserNonNegativeNonNull(ae, Hi.solveVectorScale(te, ee, J, "x", g))), y > 0 && (ae = Hi.getLesserNonNegativeNonNull(ae, Hi.solveVectorScale(te, ee, J, "x", y))), x > 0 && (ae = Hi.getLesserNonNegativeNonNull(ae, Hi.solveVectorScale(te, ee, J, "y", x))), w < 0 && (ae = Hi.getLesserNonNegativeNonNull(ae, Hi.solveVectorScale(te, ee, J, "y", w)));
                        if (Number.isFinite(ae) && ae !== 0) return f.zoom = q.zoom + c.ah(ae), f;
                        Pi();
                    }
                    handleJumpToCenterZoom(e, i) {
                        const s = e.center.lat, o = e.getConstrained(i.center ? c.Q.convert(i.center) : e.center, e.zoom).center;
                        e.setCenter(o.wrap());
                        const u = i.zoom !== void 0 ? +i.zoom : e.zoom + ti(s, o.lat);
                        e.zoom !== u && e.setZoom(u);
                    }
                    handleEaseTo(e, i) {
                        const s = e.zoom, o = e.center, u = e.padding, f = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, g = { roll: i.roll === void 0 ? e.roll : i.roll, pitch: i.pitch === void 0 ? e.pitch : i.pitch, bearing: i.bearing === void 0 ? e.bearing : i.bearing }, y = i.zoom !== void 0, x = !e.isPaddingEqual(i.padding);
                        let w = !1;
                        const P = i.center ? c.Q.convert(i.center) : o, T = e.getConstrained(P, s).center;
                        Da(e, T);
                        const z = e.clone();
                        z.setCenter(T), z.setZoom(y ? +i.zoom : s + ti(o.lat, P.lat)), z.setBearing(i.bearing);
                        const R = new c.P(c.ae(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), c.ae(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height));
                        z.setLocationAtPoint(T, R);
                        const V = (i.offset && i.offsetAsPoint.mag()) > 0 ? z.center : T, U = y ? +i.zoom : s + ti(o.lat, V.lat), Z = s + ti(o.lat, 0), q = U + ti(V.lat, 0), J = c.bq(o.lng, V.lng), Y = c.bq(o.lat, V.lat), ee = c.ac(q - Z);
                        return w = U !== s, {
                            easeFunc: (ae) => {
                                if (c.b6(f, g) || Oi({ startEulerAngles: f, endEulerAngles: g, tr: e, k: ae, useSlerp: f.roll != g.roll }), x && e.interpolatePadding(u, i.padding, ae), i.around) c.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(i.around, i.aroundPoint);
                                else {
                                    const te = q > Z ? Math.min(2, ee) : Math.max(0.5, ee), he = Math.pow(te, 1 - ae), be = jl(o, J, Y, ae * he);
                                    e.setCenter(be.wrap());
                                }
                                if (w) {
                                    const te = c.B.number(Z, q, ae) + ti(0, e.center.lat);
                                    e.setZoom(te);
                                }
                            }, isZooming: w, elevationCenter: V
                        };
                    }
                    handleFlyTo(e, i) {
                        const s = i.zoom !== void 0, o = e.center, u = e.zoom, f = e.padding, g = !e.isPaddingEqual(i.padding), y = e.getConstrained(c.Q.convert(i.center || i.locationAtOffset), u).center, x = s ? +i.zoom : e.zoom + ti(e.center.lat, y.lat), w = e.clone();
                        w.setCenter(y), w.setZoom(x), w.setBearing(i.bearing);
                        const P = new c.P(c.ae(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), c.ae(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height));
                        w.setLocationAtPoint(y, P);
                        const T = w.center;
                        Da(e, T);
                        const z = function (Y, ee, ae) {
                            const te = ei(ee), he = ei(ae), be = c.aV(te, he), ge = Math.acos(be), _e = Tn(Y);
                            return ge / (2 * Math.PI) * _e;
                        }(e, o, T), R = u + ti(o.lat, 0), V = x + ti(T.lat, 0), U = c.ac(V - R);
                        let Z;
                        if (typeof i.minZoom == "number") {
                            const Y = +i.minZoom + ti(T.lat, 0), ee = Math.min(Y, R, V) + ti(0, T.lat), ae = e.getConstrained(T, ee).zoom + ti(T.lat, 0);
                            Z = c.ac(ae - R);
                        }
                        const q = c.bq(o.lng, T.lng), J = c.bq(o.lat, T.lat);
                        return {
                            easeFunc: (Y, ee, ae, te) => {
                                const he = jl(o, q, J, ae);
                                g && e.interpolatePadding(f, i.padding, Y);
                                const be = Y === 1 ? T : he;
                                e.setCenter(be.wrap());
                                const ge = R + c.ah(ee);
                                e.setZoom(Y === 1 ? x : ge + ti(0, be.lat));
                            }, scaleOfZoom: U, targetCenter: T, scaleOfMinZoom: Z, pixelPathLength: z
                        };
                    }
                    static solveVectorScale(e, i, s, o, u) {
                        const f = o === "x" ? [s[0], s[4], s[8], s[12]] : [s[1], s[5], s[9], s[13]], g = [s[3], s[7], s[11], s[15]], y = e[0] * f[0] + e[1] * f[1] + e[2] * f[2], x = e[0] * g[0] + e[1] * g[1] + e[2] * g[2], w = i[0] * f[0] + i[1] * f[1] + i[2] * f[2], P = i[0] * g[0] + i[1] * g[1] + i[2] * g[2];
                        return w + u * x === y + u * P || g[3] * (y - w) + f[3] * (P - x) + y * P == w * x ? null : (w + f[3] - u * P - u * g[3]) / (w - y - u * P + u * x);
                    }
                    static getLesserNonNegativeNonNull(e, i) {
                        return i !== null && i >= 0 && i < e ? i : e;
                    }
                }
                class pa {
                    constructor(e) {
                        this._globe = e, this._mercatorCameraHelper = new bn(), this._verticalPerspectiveCameraHelper = new Hi();
                    }
                    get useGlobeControls() {
                        return this._globe.useGlobeRendering;
                    }
                    get currentHelper() {
                        return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
                    }
                    handlePanInertia(e, i) {
                        return this.currentHelper.handlePanInertia(e, i);
                    }
                    handleMapControlsRollPitchBearingZoom(e, i) {
                        return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, i);
                    }
                    handleMapControlsPan(e, i, s) {
                        this.currentHelper.handleMapControlsPan(e, i, s);
                    }
                    cameraForBoxAndBearing(e, i, s, o, u) {
                        return this.currentHelper.cameraForBoxAndBearing(e, i, s, o, u);
                    }
                    handleJumpToCenterZoom(e, i) {
                        this.currentHelper.handleJumpToCenterZoom(e, i);
                    }
                    handleEaseTo(e, i) {
                        return this.currentHelper.handleEaseTo(e, i);
                    }
                    handleFlyTo(e, i) {
                        return this.currentHelper.handleFlyTo(e, i);
                    }
                }
                const gs = (h, e) => c.x(h, e && e.filter((i) => i.identifier !== "source.canvas")), ah = c.bw();
                class To extends c.E {
                    constructor(e, i = {}) {
                        super(), this._rtlPluginLoaded = () => {
                            for (const s in this.sourceCaches) {
                                const o = this.sourceCaches[s].getSource().type;
                                o !== "vector" && o !== "geojson" || this.sourceCaches[s].reload();
                            }
                        }, this.map = e, this.dispatcher = new Di(Nr(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", (s, o) => this.getGlyphs(s, o)), this.dispatcher.registerMessageHandler("GI", (s, o) => this.getImages(s, o)), this.imageManager = new hs(), this.imageManager.setEventedParent(this), this.glyphManager = new mi(e._requestManager, i.localIdeographFontFamily), this.lineAtlas = new pr(256, 512), this.crossTileSymbolIndex = new yn(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new c.bx(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", c.by()), Tr().on(Ma, this._rtlPluginLoaded), this.on("data", (s) => {
                            if (s.dataType !== "source" || s.sourceDataType !== "metadata") return;
                            const o = this.sourceCaches[s.sourceId];
                            if (!o) return;
                            const u = o.getSource();
                            if (u && u.vectorLayerIds) for (const f in this._layers) {
                                const g = this._layers[f];
                                g.source === u.id && this._validateLayer(g);
                            }
                        });
                    }
                    loadURL(e, i = {}, s) {
                        this.fire(new c.l("dataloading", { dataType: "style" })), i.validate = typeof i.validate != "boolean" || i.validate;
                        const o = this.map._requestManager.transformRequest(e, "Style");
                        this._loadStyleRequest = new AbortController();
                        const u = this._loadStyleRequest;
                        c.j(o, this._loadStyleRequest).then((f) => {
                            this._loadStyleRequest = null, this._load(f.data, i, s);
                        }).catch((f) => {
                            this._loadStyleRequest = null, f && !u.signal.aborted && this.fire(new c.k(f));
                        });
                    }
                    loadJSON(e, i = {}, s) {
                        this.fire(new c.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), Ue.frameAsync(this._frameRequest).then(() => {
                            this._frameRequest = null, i.validate = i.validate !== !1, this._load(e, i, s);
                        }).catch(() => {
                        });
                    }
                    loadEmpty() {
                        this.fire(new c.l("dataloading", { dataType: "style" })), this._load(ah, { validate: !1 });
                    }
                    _load(e, i, s) {
                        var o, u;
                        const f = i.transformStyle ? i.transformStyle(s, e) : e;
                        if (!i.validate || !gs(this, c.y(f))) {
                            this._loaded = !0, this.stylesheet = f;
                            for (const g in f.sources) this.addSource(g, f.sources[g], { validate: !1 });
                            f.sprite ? this._loadSprite(f.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(f.glyphs), this._createLayers(), this.light = new hn(this.stylesheet.light), this._setProjectionInternal(((o = this.stylesheet.projection) === null || o === void 0 ? void 0 : o.type) || "mercator"), this.sky = new Fr(this.stylesheet.sky), this.map.setTerrain((u = this.stylesheet.terrain) !== null && u !== void 0 ? u : null), this.fire(new c.l("data", { dataType: "style" })), this.fire(new c.l("style.load"));
                        }
                    }
                    _createLayers() {
                        const e = c.bz(this.stylesheet.layers);
                        this.dispatcher.broadcast("SL", e), this._order = e.map((i) => i.id), this._layers = {}, this._serializedLayers = null;
                        for (const i of e) {
                            const s = c.bA(i);
                            s.setEventedParent(this, { layer: { id: i.id } }), this._layers[i.id] = s;
                        }
                    }
                    _loadSprite(e, i = !1, s = void 0) {
                        let o;
                        this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function (u, f, g, y) {
                            return c._(this, void 0, void 0, function* () {
                                const x = Rt(u), w = g > 1 ? "@2x" : "", P = {}, T = {};
                                for (const { id: z, url: R } of x) {
                                    const V = f.transformRequest(hr(R, w, ".json"), "SpriteJSON");
                                    P[z] = c.j(V, y);
                                    const U = f.transformRequest(hr(R, w, ".png"), "SpriteImage");
                                    T[z] = bi.getImage(U, y);
                                }
                                return yield Promise.all([...Object.values(P), ...Object.values(T)]), function (z, R) {
                                    return c._(this, void 0, void 0, function* () {
                                        const V = {};
                                        for (const U in z) {
                                            V[U] = {};
                                            const Z = Ue.getImageCanvasContext((yield R[U]).data), q = (yield z[U]).data;
                                            for (const J in q) {
                                                const { width: Y, height: ee, x: ae, y: te, sdf: he, pixelRatio: be, stretchX: ge, stretchY: _e, content: ye, textFitWidth: Ee, textFitHeight: ze } = q[J];
                                                V[U][J] = { data: null, pixelRatio: be, sdf: he, stretchX: ge, stretchY: _e, content: ye, textFitWidth: Ee, textFitHeight: ze, spriteData: { width: Y, height: ee, x: ae, y: te, context: Z } };
                                            }
                                        }
                                        return V;
                                    });
                                }(P, T);
                            });
                        }(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((u) => {
                            if (this._spriteRequest = null, u) for (const f in u) {
                                this._spritesImagesIds[f] = [];
                                const g = this._spritesImagesIds[f] ? this._spritesImagesIds[f].filter((y) => !(y in u)) : [];
                                for (const y of g) this.imageManager.removeImage(y), this._changedImages[y] = !0;
                                for (const y in u[f]) {
                                    const x = f === "default" ? y : `${f}:${y}`;
                                    this._spritesImagesIds[f].push(x), x in this.imageManager.images ? this.imageManager.updateImage(x, u[f][y], !1) : this.imageManager.addImage(x, u[f][y]), i && (this._changedImages[x] = !0);
                                }
                            }
                        }).catch((u) => {
                            this._spriteRequest = null, o = u, this.fire(new c.k(o));
                        }).finally(() => {
                            this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), i && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" })), s && s(o);
                        });
                    }
                    _unloadSprite() {
                        for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
                        this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" }));
                    }
                    _validateLayer(e) {
                        const i = this.sourceCaches[e.source];
                        if (!i) return;
                        const s = e.sourceLayer;
                        if (!s) return;
                        const o = i.getSource();
                        (o.type === "geojson" || o.vectorLayerIds && o.vectorLayerIds.indexOf(s) === -1) && this.fire(new c.k(new Error(`Source layer "${s}" does not exist on source "${o.id}" as specified by style layer "${e.id}".`)));
                    }
                    loaded() {
                        if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
                        for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return !1;
                        return !!this.imageManager.isLoaded();
                    }
                    _serializeByIds(e, i = !1) {
                        const s = this._serializedAllLayers();
                        if (!e || e.length === 0) return Object.values(i ? c.bB(s) : s);
                        const o = [];
                        for (const u of e) if (s[u]) {
                            const f = i ? c.bB(s[u]) : s[u];
                            o.push(f);
                        }
                        return o;
                    }
                    _serializedAllLayers() {
                        let e = this._serializedLayers;
                        if (e) return e;
                        e = this._serializedLayers = {};
                        const i = Object.keys(this._layers);
                        for (const s of i) {
                            const o = this._layers[s];
                            o.type !== "custom" && (e[s] = o.serialize());
                        }
                        return e;
                    }
                    hasTransitions() {
                        var e, i, s;
                        if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((i = this.sky) === null || i === void 0) && i.hasTransition() || !((s = this.projection) === null || s === void 0) && s.hasTransition()) return !0;
                        for (const o in this.sourceCaches) if (this.sourceCaches[o].hasTransition()) return !0;
                        for (const o in this._layers) if (this._layers[o].hasTransition()) return !0;
                        return !1;
                    }
                    _checkLoaded() {
                        if (!this._loaded) throw new Error("Style is not done loading.");
                    }
                    update(e) {
                        if (!this._loaded) return;
                        const i = this._changed;
                        if (i) {
                            const o = Object.keys(this._updatedLayers), u = Object.keys(this._removedLayers);
                            (o.length || u.length) && this._updateWorkerLayers(o, u);
                            for (const f in this._updatedSources) {
                                const g = this._updatedSources[f];
                                if (g === "reload") this._reloadSource(f);
                                else {
                                    if (g !== "clear") throw new Error(`Invalid action ${g}`);
                                    this._clearSource(f);
                                }
                            }
                            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
                            for (const f in this._updatedPaintProps) this._layers[f].updateTransitions(e);
                            this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates();
                        }
                        const s = {};
                        for (const o in this.sourceCaches) {
                            const u = this.sourceCaches[o];
                            s[o] = u.used, u.used = !1;
                        }
                        for (const o of this._order) {
                            const u = this._layers[o];
                            u.recalculate(e, this._availableImages), !u.isHidden(e.zoom) && u.source && (this.sourceCaches[u.source].used = !0);
                        }
                        for (const o in s) {
                            const u = this.sourceCaches[o];
                            !!s[o] != !!u.used && u.fire(new c.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: o }));
                        }
                        this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, i && this.fire(new c.l("data", { dataType: "style" }));
                    }
                    _updateTilesForChangedImages() {
                        const e = Object.keys(this._changedImages);
                        if (e.length) {
                            for (const i in this.sourceCaches) this.sourceCaches[i].reloadTilesForDependencies(["icons", "patterns"], e);
                            this._changedImages = {};
                        }
                    }
                    _updateTilesForChangedGlyphs() {
                        if (this._glyphsDidChange) {
                            for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
                            this._glyphsDidChange = !1;
                        }
                    }
                    _updateWorkerLayers(e, i) {
                        this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, !1), removedIds: i });
                    }
                    _resetUpdates() {
                        this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
                    }
                    setState(e, i = {}) {
                        var s;
                        this._checkLoaded();
                        const o = this.serialize();
                        if (e = i.transformStyle ? i.transformStyle(o, e) : e, ((s = i.validate) === null || s === void 0 || s) && gs(this, c.y(e))) return !1;
                        (e = c.bB(e)).layers = c.bz(e.layers);
                        const u = c.bC(o, e), f = this._getOperationsToPerform(u);
                        if (f.unimplemented.length > 0) throw new Error(`Unimplemented: ${f.unimplemented.join(", ")}.`);
                        if (f.operations.length === 0) return !1;
                        for (const g of f.operations) g();
                        return this.stylesheet = e, this._serializedLayers = null, !0;
                    }
                    _getOperationsToPerform(e) {
                        const i = [], s = [];
                        for (const o of e) switch (o.command) {
                            case "setCenter":
                            case "setZoom":
                            case "setBearing":
                            case "setPitch":
                            case "setRoll":
                                continue;
                            case "addLayer":
                                i.push(() => this.addLayer.apply(this, o.args));
                                break;
                            case "removeLayer":
                                i.push(() => this.removeLayer.apply(this, o.args));
                                break;
                            case "setPaintProperty":
                                i.push(() => this.setPaintProperty.apply(this, o.args));
                                break;
                            case "setLayoutProperty":
                                i.push(() => this.setLayoutProperty.apply(this, o.args));
                                break;
                            case "setFilter":
                                i.push(() => this.setFilter.apply(this, o.args));
                                break;
                            case "addSource":
                                i.push(() => this.addSource.apply(this, o.args));
                                break;
                            case "removeSource":
                                i.push(() => this.removeSource.apply(this, o.args));
                                break;
                            case "setLayerZoomRange":
                                i.push(() => this.setLayerZoomRange.apply(this, o.args));
                                break;
                            case "setLight":
                                i.push(() => this.setLight.apply(this, o.args));
                                break;
                            case "setGeoJSONSourceData":
                                i.push(() => this.setGeoJSONSourceData.apply(this, o.args));
                                break;
                            case "setGlyphs":
                                i.push(() => this.setGlyphs.apply(this, o.args));
                                break;
                            case "setSprite":
                                i.push(() => this.setSprite.apply(this, o.args));
                                break;
                            case "setTerrain":
                                i.push(() => this.map.setTerrain.apply(this, o.args));
                                break;
                            case "setSky":
                                i.push(() => this.setSky.apply(this, o.args));
                                break;
                            case "setProjection":
                                this.setProjection.apply(this, o.args);
                                break;
                            case "setTransition":
                                i.push(() => {
                                });
                                break;
                            default:
                                s.push(o.command);
                        }
                        return { operations: i, unimplemented: s };
                    }
                    addImage(e, i) {
                        if (this.getImage(e)) return this.fire(new c.k(new Error(`An image named "${e}" already exists.`)));
                        this.imageManager.addImage(e, i), this._afterImageUpdated(e);
                    }
                    updateImage(e, i) {
                        this.imageManager.updateImage(e, i);
                    }
                    getImage(e) {
                        return this.imageManager.getImage(e);
                    }
                    removeImage(e) {
                        if (!this.getImage(e)) return this.fire(new c.k(new Error(`An image named "${e}" does not exist.`)));
                        this.imageManager.removeImage(e), this._afterImageUpdated(e);
                    }
                    _afterImageUpdated(e) {
                        this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" }));
                    }
                    listImages() {
                        return this._checkLoaded(), this.imageManager.listImages();
                    }
                    addSource(e, i, s = {}) {
                        if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
                        if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
                        if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(c.y.source, `sources.${e}`, i, null, s)) return;
                        this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
                        const o = this.sourceCaches[e] = new ce(e, i, this.dispatcher);
                        o.style = this, o.setEventedParent(this, () => ({ isSourceLoaded: o.loaded(), source: o.serialize(), sourceId: e })), o.onAdd(this.map), this._changed = !0;
                    }
                    removeSource(e) {
                        if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
                        for (const s in this._layers) if (this._layers[s].source === e) return this.fire(new c.k(new Error(`Source "${e}" cannot be removed while layer "${s}" is using it.`)));
                        const i = this.sourceCaches[e];
                        delete this.sourceCaches[e], delete this._updatedSources[e], i.fire(new c.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), i.setEventedParent(null), i.onRemove(this.map), this._changed = !0;
                    }
                    setGeoJSONSourceData(e, i) {
                        if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
                        const s = this.sourceCaches[e].getSource();
                        if (s.type !== "geojson") throw new Error(`geojsonSource.type is ${s.type}, which is !== 'geojson`);
                        s.setData(i), this._changed = !0;
                    }
                    getSource(e) {
                        return this.sourceCaches[e] && this.sourceCaches[e].getSource();
                    }
                    addLayer(e, i, s = {}) {
                        this._checkLoaded();
                        const o = e.id;
                        if (this.getLayer(o)) return void this.fire(new c.k(new Error(`Layer "${o}" already exists on this map.`)));
                        let u;
                        if (e.type === "custom") {
                            if (gs(this, c.bD(e))) return;
                            u = c.bA(e);
                        } else {
                            if ("source" in e && typeof e.source == "object" && (this.addSource(o, e.source), e = c.bB(e), e = c.e(e, { source: o })), this._validate(c.y.layer, `layers.${o}`, e, { arrayIndex: -1 }, s)) return;
                            u = c.bA(e), this._validateLayer(u), u.setEventedParent(this, { layer: { id: o } });
                        }
                        const f = i ? this._order.indexOf(i) : this._order.length;
                        if (i && f === -1) this.fire(new c.k(new Error(`Cannot add layer "${o}" before non-existing layer "${i}".`)));
                        else {
                            if (this._order.splice(f, 0, o), this._layerOrderChanged = !0, this._layers[o] = u, this._removedLayers[o] && u.source && u.type !== "custom") {
                                const g = this._removedLayers[o];
                                delete this._removedLayers[o], g.type !== u.type ? this._updatedSources[u.source] = "clear" : (this._updatedSources[u.source] = "reload", this.sourceCaches[u.source].pause());
                            }
                            this._updateLayer(u), u.onAdd && u.onAdd(this.map);
                        }
                    }
                    moveLayer(e, i) {
                        if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new c.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
                        if (e === i) return;
                        const s = this._order.indexOf(e);
                        this._order.splice(s, 1);
                        const o = i ? this._order.indexOf(i) : this._order.length;
                        i && o === -1 ? this.fire(new c.k(new Error(`Cannot move layer "${e}" before non-existing layer "${i}".`))) : (this._order.splice(o, 0, e), this._layerOrderChanged = !0);
                    }
                    removeLayer(e) {
                        this._checkLoaded();
                        const i = this._layers[e];
                        if (!i) return void this.fire(new c.k(new Error(`Cannot remove non-existing layer "${e}".`)));
                        i.setEventedParent(null);
                        const s = this._order.indexOf(e);
                        this._order.splice(s, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = i, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], i.onRemove && i.onRemove(this.map);
                    }
                    getLayer(e) {
                        return this._layers[e];
                    }
                    getLayersOrder() {
                        return [...this._order];
                    }
                    hasLayer(e) {
                        return e in this._layers;
                    }
                    setLayerZoomRange(e, i, s) {
                        this._checkLoaded();
                        const o = this.getLayer(e);
                        o ? o.minzoom === i && o.maxzoom === s || (i != null && (o.minzoom = i), s != null && (o.maxzoom = s), this._updateLayer(o)) : this.fire(new c.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
                    }
                    setFilter(e, i, s = {}) {
                        this._checkLoaded();
                        const o = this.getLayer(e);
                        if (o) {
                            if (!c.bE(o.filter, i)) return i == null ? (o.filter = void 0, void this._updateLayer(o)) : void (this._validate(c.y.filter, `layers.${o.id}.filter`, i, null, s) || (o.filter = c.bB(i), this._updateLayer(o)));
                        } else this.fire(new c.k(new Error(`Cannot filter non-existing layer "${e}".`)));
                    }
                    getFilter(e) {
                        return c.bB(this.getLayer(e).filter);
                    }
                    setLayoutProperty(e, i, s, o = {}) {
                        this._checkLoaded();
                        const u = this.getLayer(e);
                        u ? c.bE(u.getLayoutProperty(i), s) || (u.setLayoutProperty(i, s, o), this._updateLayer(u)) : this.fire(new c.k(new Error(`Cannot style non-existing layer "${e}".`)));
                    }
                    getLayoutProperty(e, i) {
                        const s = this.getLayer(e);
                        if (s) return s.getLayoutProperty(i);
                        this.fire(new c.k(new Error(`Cannot get style of non-existing layer "${e}".`)));
                    }
                    setPaintProperty(e, i, s, o = {}) {
                        this._checkLoaded();
                        const u = this.getLayer(e);
                        u ? c.bE(u.getPaintProperty(i), s) || (u.setPaintProperty(i, s, o) && this._updateLayer(u), this._changed = !0, this._updatedPaintProps[e] = !0, this._serializedLayers = null) : this.fire(new c.k(new Error(`Cannot style non-existing layer "${e}".`)));
                    }
                    getPaintProperty(e, i) {
                        return this.getLayer(e).getPaintProperty(i);
                    }
                    setFeatureState(e, i) {
                        this._checkLoaded();
                        const s = e.source, o = e.sourceLayer, u = this.sourceCaches[s];
                        if (u === void 0) return void this.fire(new c.k(new Error(`The source '${s}' does not exist in the map's style.`)));
                        const f = u.getSource().type;
                        f === "geojson" && o ? this.fire(new c.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : f !== "vector" || o ? (e.id === void 0 && this.fire(new c.k(new Error("The feature id parameter must be provided."))), u.setFeatureState(o, e.id, i)) : this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
                    }
                    removeFeatureState(e, i) {
                        this._checkLoaded();
                        const s = e.source, o = this.sourceCaches[s];
                        if (o === void 0) return void this.fire(new c.k(new Error(`The source '${s}' does not exist in the map's style.`)));
                        const u = o.getSource().type, f = u === "vector" ? e.sourceLayer : void 0;
                        u !== "vector" || f ? i && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new c.k(new Error("A feature id is required to remove its specific state property."))) : o.removeFeatureState(f, e.id, i) : this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
                    }
                    getFeatureState(e) {
                        this._checkLoaded();
                        const i = e.source, s = e.sourceLayer, o = this.sourceCaches[i];
                        if (o !== void 0) return o.getSource().type !== "vector" || s ? (e.id === void 0 && this.fire(new c.k(new Error("The feature id parameter must be provided."))), o.getFeatureState(s, e.id)) : void this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
                        this.fire(new c.k(new Error(`The source '${i}' does not exist in the map's style.`)));
                    }
                    getTransition() {
                        return c.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
                    }
                    serialize() {
                        if (!this._loaded) return;
                        const e = c.bF(this.sourceCaches, (u) => u.serialize()), i = this._serializeByIds(this._order, !0), s = this.map.getTerrain() || void 0, o = this.stylesheet;
                        return c.bG({ version: o.version, name: o.name, metadata: o.metadata, light: o.light, sky: o.sky, center: o.center, zoom: o.zoom, bearing: o.bearing, pitch: o.pitch, sprite: o.sprite, glyphs: o.glyphs, transition: o.transition, projection: o.projection, sources: e, layers: i, terrain: s }, (u) => u !== void 0);
                    }
                    _updateLayer(e) {
                        this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0;
                    }
                    _flattenAndSortRenderedFeatures(e) {
                        const i = (f) => this._layers[f].type === "fill-extrusion", s = {}, o = [];
                        for (let f = this._order.length - 1; f >= 0; f--) {
                            const g = this._order[f];
                            if (i(g)) {
                                s[g] = f;
                                for (const y of e) {
                                    const x = y[g];
                                    if (x) for (const w of x) o.push(w);
                                }
                            }
                        }
                        o.sort((f, g) => g.intersectionZ - f.intersectionZ);
                        const u = [];
                        for (let f = this._order.length - 1; f >= 0; f--) {
                            const g = this._order[f];
                            if (i(g)) for (let y = o.length - 1; y >= 0; y--) {
                                const x = o[y].feature;
                                if (s[x.layer.id] < f) break;
                                u.push(x), o.pop();
                            }
                            else for (const y of e) {
                                const x = y[g];
                                if (x) for (const w of x) u.push(w.feature);
                            }
                        }
                        return u;
                    }
                    queryRenderedFeatures(e, i, s) {
                        i && i.filter && this._validate(c.y.filter, "queryRenderedFeatures.filter", i.filter, null, i);
                        const o = {};
                        if (i && i.layers) {
                            if (!(Array.isArray(i.layers) || i.layers instanceof Set)) return this.fire(new c.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
                            for (const x of i.layers) {
                                const w = this._layers[x];
                                if (!w) return this.fire(new c.k(new Error(`The layer '${x}' does not exist in the map's style and cannot be queried for features.`))), [];
                                o[w.source] = !0;
                            }
                        }
                        const u = [];
                        i.availableImages = this._availableImages;
                        const f = this._serializedAllLayers(), g = i.layers instanceof Set ? i.layers : Array.isArray(i.layers) ? new Set(i.layers) : null, y = Object.assign(Object.assign({}, i), { layers: g });
                        for (const x in this.sourceCaches) i.layers && !o[x] || u.push(un(this.sourceCaches[x], this._layers, f, e, y, s, this.map.terrain ? (w, P, T) => this.map.terrain.getElevation(w, P, T) : void 0));
                        return this.placement && u.push(function (x, w, P, T, z, R, V) {
                            const U = {}, Z = R.queryRenderedSymbols(T), q = [];
                            for (const J of Object.keys(Z).map(Number)) q.push(V[J]);
                            q.sort(Li);
                            for (const J of q) {
                                const Y = J.featureIndex.lookupSymbolFeatures(Z[J.bucketInstanceId], w, J.bucketIndex, J.sourceLayerIndex, z.filter, z.layers, z.availableImages, x);
                                for (const ee in Y) {
                                    const ae = U[ee] = U[ee] || [], te = Y[ee];
                                    te.sort((he, be) => {
                                        const ge = J.featureSortOrder;
                                        if (ge) {
                                            const _e = ge.indexOf(he.featureIndex);
                                            return ge.indexOf(be.featureIndex) - _e;
                                        }
                                        return be.featureIndex - he.featureIndex;
                                    });
                                    for (const he of te) ae.push(he);
                                }
                            }
                            return function (J, Y, ee) {
                                for (const ae in J) for (const te of J[ae]) Bi(te, ee[Y[ae].source]);
                                return J;
                            }(U, x, P);
                        }(this._layers, f, this.sourceCaches, e, y, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(u);
                    }
                    querySourceFeatures(e, i) {
                        i && i.filter && this._validate(c.y.filter, "querySourceFeatures.filter", i.filter, null, i);
                        const s = this.sourceCaches[e];
                        return s ? function (o, u) {
                            const f = o.getRenderableIds().map((x) => o.getTileByID(x)), g = [], y = {};
                            for (let x = 0; x < f.length; x++) {
                                const w = f[x], P = w.tileID.canonical.key;
                                y[P] || (y[P] = !0, w.querySourceFeatures(g, u));
                            }
                            return g;
                        }(s, i) : [];
                    }
                    getLight() {
                        return this.light.getLight();
                    }
                    setLight(e, i = {}) {
                        this._checkLoaded();
                        const s = this.light.getLight();
                        let o = !1;
                        for (const f in e) if (!c.bE(e[f], s[f])) {
                            o = !0;
                            break;
                        }
                        if (!o) return;
                        const u = { now: Ue.now(), transition: c.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
                        this.light.setLight(e, i), this.light.updateTransitions(u);
                    }
                    getProjection() {
                        var e;
                        return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection;
                    }
                    setProjection(e) {
                        if (this._checkLoaded(), this.projection) {
                            if (this.projection.name === e.type) return;
                            this.projection.destroy(), delete this.projection;
                        }
                        this.stylesheet.projection = e, this._setProjectionInternal(e.type);
                    }
                    getSky() {
                        var e;
                        return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky;
                    }
                    setSky(e, i = {}) {
                        this._checkLoaded();
                        const s = this.getSky();
                        let o = !1;
                        if (!e && !s) return;
                        if (e && !s) o = !0;
                        else if (!e && s) o = !0;
                        else for (const f in e) if (!c.bE(e[f], s[f])) {
                            o = !0;
                            break;
                        }
                        if (!o) return;
                        const u = { now: Ue.now(), transition: c.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
                        this.stylesheet.sky = e, this.sky.setSky(e, i), this.sky.updateTransitions(u);
                    }
                    _setProjectionInternal(e) {
                        const i = function (s) {
                            if (Array.isArray(s)) {
                                const o = new ds({ type: s });
                                return { projection: o, transform: new In(), cameraHelper: new pa(o) };
                            }
                            switch (s) {
                                case "mercator":
                                    return { projection: new vn(), transform: new La(), cameraHelper: new bn() };
                                case "globe": {
                                    const o = new ds({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                                    return { projection: o, transform: new In(), cameraHelper: new pa(o) };
                                }
                                case "vertical-perspective":
                                    return { projection: new Sn(), transform: new ua(), cameraHelper: new Hi() };
                                default:
                                    return c.w(`Unknown projection name: ${s}. Falling back to mercator projection.`), { projection: new vn(), transform: new La(), cameraHelper: new bn() };
                            }
                        }(e);
                        this.projection = i.projection, this.map.migrateProjection(i.transform, i.cameraHelper);
                        for (const s in this.sourceCaches) this.sourceCaches[s].reload();
                    }
                    _validate(e, i, s, o, u = {}) {
                        return (!u || u.validate !== !1) && gs(this, e.call(c.y, c.e({ key: i, style: this.serialize(), value: s, styleSpec: c.v }, o)));
                    }
                    _remove(e = !0) {
                        this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Tr().off(Ma, this._rtlPluginLoaded);
                        for (const i in this._layers) this._layers[i].setEventedParent(null);
                        for (const i in this.sourceCaches) {
                            const s = this.sourceCaches[i];
                            s.setEventedParent(null), s.onRemove(this.map);
                        }
                        this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e);
                    }
                    _clearSource(e) {
                        this.sourceCaches[e].clearTiles();
                    }
                    _reloadSource(e) {
                        this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
                    }
                    _updateSources(e) {
                        for (const i in this.sourceCaches) this.sourceCaches[i].update(e, this.map.terrain);
                    }
                    _generateCollisionBoxes() {
                        for (const e in this.sourceCaches) this._reloadSource(e);
                    }
                    _updatePlacement(e, i, s, o, u = !1) {
                        let f = !1, g = !1;
                        const y = {};
                        for (const x of this._order) {
                            const w = this._layers[x];
                            if (w.type !== "symbol") continue;
                            if (!y[w.source]) {
                                const T = this.sourceCaches[w.source];
                                y[w.source] = T.getRenderableIds(!0).map((z) => T.getTileByID(z)).sort((z, R) => R.tileID.overscaledZ - z.tileID.overscaledZ || (z.tileID.isLessThan(R.tileID) ? -1 : 1));
                            }
                            const P = this.crossTileSymbolIndex.addLayer(w, y[w.source], e.center.lng);
                            f = f || P;
                        }
                        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((u = u || this._layerOrderChanged || s === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(Ue.now(), e.zoom)) && (this.pauseablePlacement = new Ol(e, this.map.terrain, this._order, u, i, s, o, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, y), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(Ue.now()), g = !0), f && this.pauseablePlacement.placement.setStale()), g || f) for (const x of this._order) {
                            const w = this._layers[x];
                            w.type === "symbol" && this.placement.updateLayerOpacities(w, y[w.source]);
                        }
                        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(Ue.now());
                    }
                    _releaseSymbolFadeTiles() {
                        for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles();
                    }
                    getImages(e, i) {
                        return c._(this, void 0, void 0, function* () {
                            const s = yield this.imageManager.getImages(i.icons);
                            this._updateTilesForChangedImages();
                            const o = this.sourceCaches[i.source];
                            return o && o.setDependencies(i.tileID.key, i.type, i.icons), s;
                        });
                    }
                    getGlyphs(e, i) {
                        return c._(this, void 0, void 0, function* () {
                            const s = yield this.glyphManager.getGlyphs(i.stacks), o = this.sourceCaches[i.source];
                            return o && o.setDependencies(i.tileID.key, i.type, [""]), s;
                        });
                    }
                    getGlyphsUrl() {
                        return this.stylesheet.glyphs || null;
                    }
                    setGlyphs(e, i = {}) {
                        this._checkLoaded(), e && this._validate(c.y.glyphs, "glyphs", e, null, i) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
                    }
                    addSprite(e, i, s = {}, o) {
                        this._checkLoaded();
                        const u = [{ id: e, url: i }], f = [...Rt(this.stylesheet.sprite), ...u];
                        this._validate(c.y.sprite, "sprite", f, null, s) || (this.stylesheet.sprite = f, this._loadSprite(u, !0, o));
                    }
                    removeSprite(e) {
                        this._checkLoaded();
                        const i = Rt(this.stylesheet.sprite);
                        if (i.find((s) => s.id === e)) {
                            if (this._spritesImagesIds[e]) for (const s of this._spritesImagesIds[e]) this.imageManager.removeImage(s), this._changedImages[s] = !0;
                            i.splice(i.findIndex((s) => s.id === e), 1), this.stylesheet.sprite = i.length > 0 ? i : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" }));
                        } else this.fire(new c.k(new Error(`Sprite "${e}" doesn't exists on this map.`)));
                    }
                    getSprite() {
                        return Rt(this.stylesheet.sprite);
                    }
                    setSprite(e, i = {}, s) {
                        this._checkLoaded(), e && this._validate(c.y.sprite, "sprite", e, null, i) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, s) : (this._unloadSprite(), s && s(null)));
                    }
                }
                var nh = c.aG([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
                class sh {
                    constructor() {
                        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
                    }
                    bind(e, i, s, o, u, f, g, y, x) {
                        this.context = e;
                        let w = this.boundPaintVertexBuffers.length !== o.length;
                        for (let P = 0; !w && P < o.length; P++) this.boundPaintVertexBuffers[P] !== o[P] && (w = !0);
                        !this.vao || this.boundProgram !== i || this.boundLayoutVertexBuffer !== s || w || this.boundIndexBuffer !== u || this.boundVertexOffset !== f || this.boundDynamicVertexBuffer !== g || this.boundDynamicVertexBuffer2 !== y || this.boundDynamicVertexBuffer3 !== x ? this.freshBind(i, s, o, u, f, g, y, x) : (e.bindVertexArray.set(this.vao), g && g.bind(), u && u.dynamicDraw && u.bind(), y && y.bind(), x && x.bind());
                    }
                    freshBind(e, i, s, o, u, f, g, y) {
                        const x = e.numAttributes, w = this.context, P = w.gl;
                        this.vao && this.destroy(), this.vao = w.createVertexArray(), w.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = i, this.boundPaintVertexBuffers = s, this.boundIndexBuffer = o, this.boundVertexOffset = u, this.boundDynamicVertexBuffer = f, this.boundDynamicVertexBuffer2 = g, this.boundDynamicVertexBuffer3 = y, i.enableAttributes(P, e);
                        for (const T of s) T.enableAttributes(P, e);
                        f && f.enableAttributes(P, e), g && g.enableAttributes(P, e), y && y.enableAttributes(P, e), i.bind(), i.setVertexAttribPointers(P, e, u);
                        for (const T of s) T.bind(), T.setVertexAttribPointers(P, e, u);
                        f && (f.bind(), f.setVertexAttribPointers(P, e, u)), o && o.bind(), g && (g.bind(), g.setVertexAttribPointers(P, e, u)), y && (y.bind(), y.setVertexAttribPointers(P, e, u)), w.currentNumAttributes = x;
                    }
                    destroy() {
                        this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
                    }
                }
                const oh = (h, e, i, s, o) => ({ u_texture: 0, u_ele_delta: h, u_fog_matrix: e, u_fog_color: i ? i.properties.get("fog-color") : c.b7.white, u_fog_ground_blend: i ? i.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: o ? 0 : i ? i.calculateFogBlendOpacity(s) : 0, u_horizon_color: i ? i.properties.get("horizon-color") : c.b7.white, u_horizon_fog_blend: i ? i.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: o ? 1 : 0 }), _s = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
                function Na(h) {
                    const e = [];
                    for (let i = 0; i < h.length; i++) {
                        if (h[i] === null) continue;
                        const s = h[i].split(" ");
                        e.push(s.pop());
                    }
                    return e;
                }
                class ys {
                    constructor(e, i, s, o, u, f, g, y, x = []) {
                        const w = e.gl;
                        this.program = w.createProgram();
                        const P = Na(i.staticAttributes), T = s ? s.getBinderAttributes() : [], z = P.concat(T), R = Si.prelude.staticUniforms ? Na(Si.prelude.staticUniforms) : [], V = g.staticUniforms ? Na(g.staticUniforms) : [], U = i.staticUniforms ? Na(i.staticUniforms) : [], Z = s ? s.getBinderUniforms() : [], q = R.concat(V).concat(U).concat(Z), J = [];
                        for (const ge of q) J.indexOf(ge) < 0 && J.push(ge);
                        const Y = s ? s.defines() : [];
                        gi(w) && Y.unshift("#version 300 es"), u && Y.push("#define OVERDRAW_INSPECTOR;"), f && Y.push("#define TERRAIN3D;"), y && Y.push(y), x && Y.push(...x);
                        let ee = Y.concat(Si.prelude.fragmentSource, g.fragmentSource, i.fragmentSource).join(`
`), ae = Y.concat(Si.prelude.vertexSource, g.vertexSource, i.vertexSource).join(`
`);
                        gi(w) || (ee = function (ge) {
                            return ge.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
                        }(ee), ae = function (ge) {
                            return ge.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
                        }(ae));
                        const te = w.createShader(w.FRAGMENT_SHADER);
                        if (w.isContextLost()) return void (this.failedToCreate = !0);
                        if (w.shaderSource(te, ee), w.compileShader(te), !w.getShaderParameter(te, w.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${w.getShaderInfoLog(te)}`);
                        w.attachShader(this.program, te);
                        const he = w.createShader(w.VERTEX_SHADER);
                        if (w.isContextLost()) return void (this.failedToCreate = !0);
                        if (w.shaderSource(he, ae), w.compileShader(he), !w.getShaderParameter(he, w.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${w.getShaderInfoLog(he)}`);
                        w.attachShader(this.program, he), this.attributes = {};
                        const be = {};
                        this.numAttributes = z.length;
                        for (let ge = 0; ge < this.numAttributes; ge++) z[ge] && (w.bindAttribLocation(this.program, ge, z[ge]), this.attributes[z[ge]] = ge);
                        if (w.linkProgram(this.program), !w.getProgramParameter(this.program, w.LINK_STATUS)) throw new Error(`Program failed to link: ${w.getProgramInfoLog(this.program)}`);
                        w.deleteShader(he), w.deleteShader(te);
                        for (let ge = 0; ge < J.length; ge++) {
                            const _e = J[ge];
                            if (_e && !be[_e]) {
                                const ye = w.getUniformLocation(this.program, _e);
                                ye && (be[_e] = ye);
                            }
                        }
                        this.fixedUniforms = o(e, be), this.terrainUniforms = ((ge, _e) => ({ u_depth: new c.bH(ge, _e.u_depth), u_terrain: new c.bH(ge, _e.u_terrain), u_terrain_dim: new c.b8(ge, _e.u_terrain_dim), u_terrain_matrix: new c.bJ(ge, _e.u_terrain_matrix), u_terrain_unpack: new c.bK(ge, _e.u_terrain_unpack), u_terrain_exaggeration: new c.b8(ge, _e.u_terrain_exaggeration) }))(e, be), this.projectionUniforms = ((ge, _e) => ({ u_projection_matrix: new c.bJ(ge, _e.u_projection_matrix), u_projection_tile_mercator_coords: new c.bK(ge, _e.u_projection_tile_mercator_coords), u_projection_clipping_plane: new c.bK(ge, _e.u_projection_clipping_plane), u_projection_transition: new c.b8(ge, _e.u_projection_transition), u_projection_fallback_matrix: new c.bJ(ge, _e.u_projection_fallback_matrix) }))(e, be), this.binderUniforms = s ? s.getUniforms(e, be) : [];
                    }
                    draw(e, i, s, o, u, f, g, y, x, w, P, T, z, R, V, U, Z, q, J) {
                        const Y = e.gl;
                        if (this.failedToCreate) return;
                        if (e.program.set(this.program), e.setDepthMode(s), e.setStencilMode(o), e.setColorMode(u), e.setCullFace(f), y) {
                            e.activeTexture.set(Y.TEXTURE2), Y.bindTexture(Y.TEXTURE_2D, y.depthTexture), e.activeTexture.set(Y.TEXTURE3), Y.bindTexture(Y.TEXTURE_2D, y.texture);
                            for (const ae in this.terrainUniforms) this.terrainUniforms[ae].set(y[ae]);
                        }
                        if (x) for (const ae in x) this.projectionUniforms[_s[ae]].set(x[ae]);
                        if (g) for (const ae in this.fixedUniforms) this.fixedUniforms[ae].set(g[ae]);
                        U && U.setUniforms(e, this.binderUniforms, R, { zoom: V });
                        let ee = 0;
                        switch (i) {
                            case Y.LINES:
                                ee = 2;
                                break;
                            case Y.TRIANGLES:
                                ee = 3;
                                break;
                            case Y.LINE_STRIP:
                                ee = 1;
                        }
                        for (const ae of z.get()) {
                            const te = ae.vaos || (ae.vaos = {});
                            (te[w] || (te[w] = new sh())).bind(e, this, P, U ? U.getPaintVertexBuffers() : [], T, ae.vertexOffset, Z, q, J), Y.drawElements(i, ae.primitiveLength * ee, Y.UNSIGNED_SHORT, ae.primitiveOffset * ee * 2);
                        }
                    }
                }
                function vs(h, e, i) {
                    const s = 1 / c.az(i, 1, e.transform.tileZoom), o = Math.pow(2, i.tileID.overscaledZ), u = i.tileSize * Math.pow(2, e.transform.tileZoom) / o, f = u * (i.tileID.canonical.x + i.tileID.wrap * o), g = u * i.tileID.canonical.y;
                    return { u_image: 0, u_texsize: i.imageAtlasTexture.size, u_scale: [s, h.fromScale, h.toScale], u_fade: h.t, u_pixel_coord_upper: [f >> 16, g >> 16], u_pixel_coord_lower: [65535 & f, 65535 & g] };
                }
                const xs = (h, e, i, s) => {
                    const o = h.style.light, u = o.properties.get("position"), f = [u.x, u.y, u.z], g = c.bN();
                    o.properties.get("anchor") === "viewport" && c.bO(g, h.transform.bearingInRadians), c.bP(f, f, g);
                    const y = h.transform.transformLightDirection(f), x = o.properties.get("color");
                    return { u_lightpos: f, u_lightpos_globe: y, u_lightintensity: o.properties.get("intensity"), u_lightcolor: [x.r, x.g, x.b], u_vertical_gradient: +e, u_opacity: i, u_fill_translate: s };
                }, _r = (h, e, i, s, o, u, f) => c.e(xs(h, e, i, s), vs(u, h, f), { u_height_factor: -Math.pow(2, o.overscaledZ) / f.tileSize / 8 }), $l = (h, e, i, s) => c.e(vs(e, h, i), { u_fill_translate: s }), Po = (h, e) => ({ u_world: h, u_fill_translate: e }), Cn = (h, e, i, s, o) => c.e($l(h, e, i, o), { u_world: s }), An = (h, e, i, s, o) => {
                    const u = h.transform;
                    let f, g, y = 0;
                    if (i.paint.get("circle-pitch-alignment") === "map") {
                        const x = c.az(e, 1, u.zoom);
                        f = !0, g = [x, x], y = x / (c.Z * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * o;
                    } else f = !1, g = u.pixelsToGLUnits;
                    return { u_camera_to_center_distance: u.cameraToCenterDistance, u_scale_with_map: +(i.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +f, u_device_pixel_ratio: h.pixelRatio, u_extrude_scale: g, u_globe_extrude_scale: y, u_translate: s };
                }, lh = (h) => ({ u_pixel_extrude_scale: [1 / h.width, 1 / h.height] }), bs = (h) => ({ u_viewport_size: [h.width, h.height] }), Ul = (h, e = 1) => ({ u_color: h, u_overlay: 0, u_overlay_scale: e }), da = (h, e, i, s) => {
                    const o = c.az(h, 1, e) / (c.Z * Math.pow(2, h.tileID.overscaledZ)) * 2 * Math.PI * s;
                    return { u_extrude_scale: c.az(h, 1, e), u_intensity: i, u_globe_extrude_scale: o };
                }, Vl = (h, e, i, s) => {
                    const o = c.K();
                    c.bQ(o, 0, h.width, h.height, 0, 0, 1);
                    const u = h.context.gl;
                    return { u_matrix: o, u_world: [u.drawingBufferWidth, u.drawingBufferHeight], u_image: i, u_color_ramp: s, u_opacity: e.paint.get("heatmap-opacity") };
                }, Zl = (h, e, i) => {
                    const s = i.paint.get("hillshade-accent-color");
                    let o;
                    switch (i.paint.get("hillshade-method")) {
                        case "basic":
                            o = 4;
                            break;
                        case "combined":
                            o = 1;
                            break;
                        case "igor":
                            o = 2;
                            break;
                        case "multidirectional":
                            o = 3;
                            break;
                        default:
                            o = 0;
                    }
                    const u = i.getIlluminationProperties();
                    for (let f = 0; f < u.directionRadians.length; f++) i.paint.get("hillshade-illumination-anchor") === "viewport" && (u.directionRadians[f] += h.transform.bearingInRadians);
                    return { u_image: 0, u_latrange: Gl(0, e.tileID), u_exaggeration: i.paint.get("hillshade-exaggeration"), u_altitudes: u.altitudeRadians, u_azimuths: u.directionRadians, u_accent: s, u_method: o, u_highlights: u.highlightColor, u_shadows: u.shadowColor };
                }, ch = (h, e) => {
                    const i = e.stride, s = c.K();
                    return c.bQ(s, 0, c.Z, -8192, 0, 0, 1), c.L(s, s, [0, -8192, 0]), { u_matrix: s, u_image: 1, u_dimension: [i, i], u_zoom: h.overscaledZ, u_unpack: e.getUnpackVector() };
                };
                function Gl(h, e) {
                    const i = Math.pow(2, e.canonical.z), s = e.canonical.y;
                    return [new c.$(0, s / i).toLngLat().lat, new c.$(0, (s + 1) / i).toLngLat().lat];
                }
                const kn = (h, e, i, s) => {
                    const o = h.transform;
                    return { u_translation: Ur(h, e, i), u_ratio: s / c.az(e, 1, o.zoom), u_device_pixel_ratio: h.pixelRatio, u_units_to_pixels: [1 / o.pixelsToGLUnits[0], 1 / o.pixelsToGLUnits[1]] };
                }, ql = (h, e, i, s, o) => c.e(kn(h, e, i, s), { u_image: 0, u_image_height: o }), Hl = (h, e, i, s, o) => {
                    const u = h.transform, f = Mo(e, u);
                    return { u_translation: Ur(h, e, i), u_texsize: e.imageAtlasTexture.size, u_ratio: s / c.az(e, 1, u.zoom), u_device_pixel_ratio: h.pixelRatio, u_image: 0, u_scale: [f, o.fromScale, o.toScale], u_fade: o.t, u_units_to_pixels: [1 / u.pixelsToGLUnits[0], 1 / u.pixelsToGLUnits[1]] };
                }, Wl = (h, e, i, s, o, u) => {
                    const f = h.lineAtlas, g = Mo(e, h.transform), y = i.layout.get("line-cap") === "round", x = f.getDash(o.from, y), w = f.getDash(o.to, y), P = x.width * u.fromScale, T = w.width * u.toScale;
                    return c.e(kn(h, e, i, s), { u_patternscale_a: [g / P, -x.height / 2], u_patternscale_b: [g / T, -w.height / 2], u_sdfgamma: f.width / (256 * Math.min(P, T) * h.pixelRatio) / 2, u_image: 0, u_tex_y_a: x.y, u_tex_y_b: w.y, u_mix: u.t });
                };
                function Mo(h, e) {
                    return 1 / c.az(h, 1, e.tileZoom);
                }
                function Ur(h, e, i) {
                    return c.aA(h.transform, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"));
                }
                const Xl = (h, e, i, s, o) => {
                    return { u_tl_parent: h, u_scale_parent: e, u_buffer_scale: 1, u_fade_t: i.mix, u_opacity: i.opacity * s.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: s.paint.get("raster-brightness-min"), u_brightness_high: s.paint.get("raster-brightness-max"), u_saturation_factor: (f = s.paint.get("raster-saturation"), f > 0 ? 1 - 1 / (1.001 - f) : -f), u_contrast_factor: (u = s.paint.get("raster-contrast"), u > 0 ? 1 / (1 - u) : 1 + u), u_spin_weights: Kl(s.paint.get("raster-hue-rotate")), u_coords_top: [o[0].x, o[0].y, o[1].x, o[1].y], u_coords_bottom: [o[3].x, o[3].y, o[2].x, o[2].y] };
                    var u, f;
                };
                function Kl(h) {
                    h *= Math.PI / 180;
                    const e = Math.sin(h), i = Math.cos(h);
                    return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3];
                }
                const Oa = (h, e, i, s, o, u, f, g, y, x, w, P, T) => {
                    const z = f.transform;
                    return { u_is_size_zoom_constant: +(h === "constant" || h === "source"), u_is_size_feature_constant: +(h === "constant" || h === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: z.cameraToCenterDistance, u_pitch: z.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i, u_aspect_ratio: z.width / z.height, u_fade_change: f.options.fadeDuration ? f.symbolFadeChange : 1, u_label_plane_matrix: g, u_coord_matrix: y, u_is_text: +w, u_pitch_with_map: +s, u_is_along_line: o, u_is_variable_anchor: u, u_texsize: P, u_texture: 0, u_translation: x, u_pitched_scale: T };
                }, Yl = (h, e, i, s, o, u, f, g, y, x, w, P, T, z) => {
                    const R = f.transform;
                    return c.e(Oa(h, e, i, s, o, u, f, g, y, x, w, P, z), { u_gamma_scale: s ? Math.cos(R.pitch * Math.PI / 180) * R.cameraToCenterDistance : 1, u_device_pixel_ratio: f.pixelRatio, u_is_halo: 1 });
                }, ws = (h, e, i, s, o, u, f, g, y, x, w, P, T) => c.e(Yl(h, e, i, s, o, u, f, g, y, x, !0, w, 0, T), { u_texsize_icon: P, u_texture_icon: 1 }), hh = (h, e) => ({ u_opacity: h, u_color: e }), uh = (h, e, i, s, o) => c.e(function (u, f, g, y) {
                    const x = g.imageManager.getPattern(u.from.toString()), w = g.imageManager.getPattern(u.to.toString()), { width: P, height: T } = g.imageManager.getPixelSize(), z = Math.pow(2, y.tileID.overscaledZ), R = y.tileSize * Math.pow(2, g.transform.tileZoom) / z, V = R * (y.tileID.canonical.x + y.tileID.wrap * z), U = R * y.tileID.canonical.y;
                    return { u_image: 0, u_pattern_tl_a: x.tl, u_pattern_br_a: x.br, u_pattern_tl_b: w.tl, u_pattern_br_b: w.br, u_texsize: [P, T], u_mix: f.t, u_pattern_size_a: x.displaySize, u_pattern_size_b: w.displaySize, u_scale_a: f.fromScale, u_scale_b: f.toScale, u_tile_units_to_pixels: 1 / c.az(y, 1, g.transform.tileZoom), u_pixel_coord_upper: [V >> 16, U >> 16], u_pixel_coord_lower: [65535 & V, 65535 & U] };
                }(i, o, e, s), { u_opacity: h }), Io = (h, e) => {
                }, Jl = { fillExtrusion: (h, e) => ({ u_lightpos: new c.bL(h, e.u_lightpos), u_lightpos_globe: new c.bL(h, e.u_lightpos_globe), u_lightintensity: new c.b8(h, e.u_lightintensity), u_lightcolor: new c.bL(h, e.u_lightcolor), u_vertical_gradient: new c.b8(h, e.u_vertical_gradient), u_opacity: new c.b8(h, e.u_opacity), u_fill_translate: new c.bM(h, e.u_fill_translate) }), fillExtrusionPattern: (h, e) => ({ u_lightpos: new c.bL(h, e.u_lightpos), u_lightpos_globe: new c.bL(h, e.u_lightpos_globe), u_lightintensity: new c.b8(h, e.u_lightintensity), u_lightcolor: new c.bL(h, e.u_lightcolor), u_vertical_gradient: new c.b8(h, e.u_vertical_gradient), u_height_factor: new c.b8(h, e.u_height_factor), u_opacity: new c.b8(h, e.u_opacity), u_fill_translate: new c.bM(h, e.u_fill_translate), u_image: new c.bH(h, e.u_image), u_texsize: new c.bM(h, e.u_texsize), u_pixel_coord_upper: new c.bM(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.bM(h, e.u_pixel_coord_lower), u_scale: new c.bL(h, e.u_scale), u_fade: new c.b8(h, e.u_fade) }), fill: (h, e) => ({ u_fill_translate: new c.bM(h, e.u_fill_translate) }), fillPattern: (h, e) => ({ u_image: new c.bH(h, e.u_image), u_texsize: new c.bM(h, e.u_texsize), u_pixel_coord_upper: new c.bM(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.bM(h, e.u_pixel_coord_lower), u_scale: new c.bL(h, e.u_scale), u_fade: new c.b8(h, e.u_fade), u_fill_translate: new c.bM(h, e.u_fill_translate) }), fillOutline: (h, e) => ({ u_world: new c.bM(h, e.u_world), u_fill_translate: new c.bM(h, e.u_fill_translate) }), fillOutlinePattern: (h, e) => ({ u_world: new c.bM(h, e.u_world), u_image: new c.bH(h, e.u_image), u_texsize: new c.bM(h, e.u_texsize), u_pixel_coord_upper: new c.bM(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.bM(h, e.u_pixel_coord_lower), u_scale: new c.bL(h, e.u_scale), u_fade: new c.b8(h, e.u_fade), u_fill_translate: new c.bM(h, e.u_fill_translate) }), circle: (h, e) => ({ u_camera_to_center_distance: new c.b8(h, e.u_camera_to_center_distance), u_scale_with_map: new c.bH(h, e.u_scale_with_map), u_pitch_with_map: new c.bH(h, e.u_pitch_with_map), u_extrude_scale: new c.bM(h, e.u_extrude_scale), u_device_pixel_ratio: new c.b8(h, e.u_device_pixel_ratio), u_globe_extrude_scale: new c.b8(h, e.u_globe_extrude_scale), u_translate: new c.bM(h, e.u_translate) }), collisionBox: (h, e) => ({ u_pixel_extrude_scale: new c.bM(h, e.u_pixel_extrude_scale) }), collisionCircle: (h, e) => ({ u_viewport_size: new c.bM(h, e.u_viewport_size) }), debug: (h, e) => ({ u_color: new c.bI(h, e.u_color), u_overlay: new c.bH(h, e.u_overlay), u_overlay_scale: new c.b8(h, e.u_overlay_scale) }), depth: Io, clippingMask: Io, heatmap: (h, e) => ({ u_extrude_scale: new c.b8(h, e.u_extrude_scale), u_intensity: new c.b8(h, e.u_intensity), u_globe_extrude_scale: new c.b8(h, e.u_globe_extrude_scale) }), heatmapTexture: (h, e) => ({ u_matrix: new c.bJ(h, e.u_matrix), u_world: new c.bM(h, e.u_world), u_image: new c.bH(h, e.u_image), u_color_ramp: new c.bH(h, e.u_color_ramp), u_opacity: new c.b8(h, e.u_opacity) }), hillshade: (h, e) => ({ u_image: new c.bH(h, e.u_image), u_latrange: new c.bM(h, e.u_latrange), u_exaggeration: new c.b8(h, e.u_exaggeration), u_altitudes: new c.bS(h, e.u_altitudes), u_azimuths: new c.bS(h, e.u_azimuths), u_accent: new c.bI(h, e.u_accent), u_method: new c.bH(h, e.u_method), u_shadows: new c.bR(h, e.u_shadows), u_highlights: new c.bR(h, e.u_highlights) }), hillshadePrepare: (h, e) => ({ u_matrix: new c.bJ(h, e.u_matrix), u_image: new c.bH(h, e.u_image), u_dimension: new c.bM(h, e.u_dimension), u_zoom: new c.b8(h, e.u_zoom), u_unpack: new c.bK(h, e.u_unpack) }), line: (h, e) => ({ u_translation: new c.bM(h, e.u_translation), u_ratio: new c.b8(h, e.u_ratio), u_device_pixel_ratio: new c.b8(h, e.u_device_pixel_ratio), u_units_to_pixels: new c.bM(h, e.u_units_to_pixels) }), lineGradient: (h, e) => ({ u_translation: new c.bM(h, e.u_translation), u_ratio: new c.b8(h, e.u_ratio), u_device_pixel_ratio: new c.b8(h, e.u_device_pixel_ratio), u_units_to_pixels: new c.bM(h, e.u_units_to_pixels), u_image: new c.bH(h, e.u_image), u_image_height: new c.b8(h, e.u_image_height) }), linePattern: (h, e) => ({ u_translation: new c.bM(h, e.u_translation), u_texsize: new c.bM(h, e.u_texsize), u_ratio: new c.b8(h, e.u_ratio), u_device_pixel_ratio: new c.b8(h, e.u_device_pixel_ratio), u_image: new c.bH(h, e.u_image), u_units_to_pixels: new c.bM(h, e.u_units_to_pixels), u_scale: new c.bL(h, e.u_scale), u_fade: new c.b8(h, e.u_fade) }), lineSDF: (h, e) => ({ u_translation: new c.bM(h, e.u_translation), u_ratio: new c.b8(h, e.u_ratio), u_device_pixel_ratio: new c.b8(h, e.u_device_pixel_ratio), u_units_to_pixels: new c.bM(h, e.u_units_to_pixels), u_patternscale_a: new c.bM(h, e.u_patternscale_a), u_patternscale_b: new c.bM(h, e.u_patternscale_b), u_sdfgamma: new c.b8(h, e.u_sdfgamma), u_image: new c.bH(h, e.u_image), u_tex_y_a: new c.b8(h, e.u_tex_y_a), u_tex_y_b: new c.b8(h, e.u_tex_y_b), u_mix: new c.b8(h, e.u_mix) }), raster: (h, e) => ({ u_tl_parent: new c.bM(h, e.u_tl_parent), u_scale_parent: new c.b8(h, e.u_scale_parent), u_buffer_scale: new c.b8(h, e.u_buffer_scale), u_fade_t: new c.b8(h, e.u_fade_t), u_opacity: new c.b8(h, e.u_opacity), u_image0: new c.bH(h, e.u_image0), u_image1: new c.bH(h, e.u_image1), u_brightness_low: new c.b8(h, e.u_brightness_low), u_brightness_high: new c.b8(h, e.u_brightness_high), u_saturation_factor: new c.b8(h, e.u_saturation_factor), u_contrast_factor: new c.b8(h, e.u_contrast_factor), u_spin_weights: new c.bL(h, e.u_spin_weights), u_coords_top: new c.bK(h, e.u_coords_top), u_coords_bottom: new c.bK(h, e.u_coords_bottom) }), symbolIcon: (h, e) => ({ u_is_size_zoom_constant: new c.bH(h, e.u_is_size_zoom_constant), u_is_size_feature_constant: new c.bH(h, e.u_is_size_feature_constant), u_size_t: new c.b8(h, e.u_size_t), u_size: new c.b8(h, e.u_size), u_camera_to_center_distance: new c.b8(h, e.u_camera_to_center_distance), u_pitch: new c.b8(h, e.u_pitch), u_rotate_symbol: new c.bH(h, e.u_rotate_symbol), u_aspect_ratio: new c.b8(h, e.u_aspect_ratio), u_fade_change: new c.b8(h, e.u_fade_change), u_label_plane_matrix: new c.bJ(h, e.u_label_plane_matrix), u_coord_matrix: new c.bJ(h, e.u_coord_matrix), u_is_text: new c.bH(h, e.u_is_text), u_pitch_with_map: new c.bH(h, e.u_pitch_with_map), u_is_along_line: new c.bH(h, e.u_is_along_line), u_is_variable_anchor: new c.bH(h, e.u_is_variable_anchor), u_texsize: new c.bM(h, e.u_texsize), u_texture: new c.bH(h, e.u_texture), u_translation: new c.bM(h, e.u_translation), u_pitched_scale: new c.b8(h, e.u_pitched_scale) }), symbolSDF: (h, e) => ({ u_is_size_zoom_constant: new c.bH(h, e.u_is_size_zoom_constant), u_is_size_feature_constant: new c.bH(h, e.u_is_size_feature_constant), u_size_t: new c.b8(h, e.u_size_t), u_size: new c.b8(h, e.u_size), u_camera_to_center_distance: new c.b8(h, e.u_camera_to_center_distance), u_pitch: new c.b8(h, e.u_pitch), u_rotate_symbol: new c.bH(h, e.u_rotate_symbol), u_aspect_ratio: new c.b8(h, e.u_aspect_ratio), u_fade_change: new c.b8(h, e.u_fade_change), u_label_plane_matrix: new c.bJ(h, e.u_label_plane_matrix), u_coord_matrix: new c.bJ(h, e.u_coord_matrix), u_is_text: new c.bH(h, e.u_is_text), u_pitch_with_map: new c.bH(h, e.u_pitch_with_map), u_is_along_line: new c.bH(h, e.u_is_along_line), u_is_variable_anchor: new c.bH(h, e.u_is_variable_anchor), u_texsize: new c.bM(h, e.u_texsize), u_texture: new c.bH(h, e.u_texture), u_gamma_scale: new c.b8(h, e.u_gamma_scale), u_device_pixel_ratio: new c.b8(h, e.u_device_pixel_ratio), u_is_halo: new c.bH(h, e.u_is_halo), u_translation: new c.bM(h, e.u_translation), u_pitched_scale: new c.b8(h, e.u_pitched_scale) }), symbolTextAndIcon: (h, e) => ({ u_is_size_zoom_constant: new c.bH(h, e.u_is_size_zoom_constant), u_is_size_feature_constant: new c.bH(h, e.u_is_size_feature_constant), u_size_t: new c.b8(h, e.u_size_t), u_size: new c.b8(h, e.u_size), u_camera_to_center_distance: new c.b8(h, e.u_camera_to_center_distance), u_pitch: new c.b8(h, e.u_pitch), u_rotate_symbol: new c.bH(h, e.u_rotate_symbol), u_aspect_ratio: new c.b8(h, e.u_aspect_ratio), u_fade_change: new c.b8(h, e.u_fade_change), u_label_plane_matrix: new c.bJ(h, e.u_label_plane_matrix), u_coord_matrix: new c.bJ(h, e.u_coord_matrix), u_is_text: new c.bH(h, e.u_is_text), u_pitch_with_map: new c.bH(h, e.u_pitch_with_map), u_is_along_line: new c.bH(h, e.u_is_along_line), u_is_variable_anchor: new c.bH(h, e.u_is_variable_anchor), u_texsize: new c.bM(h, e.u_texsize), u_texsize_icon: new c.bM(h, e.u_texsize_icon), u_texture: new c.bH(h, e.u_texture), u_texture_icon: new c.bH(h, e.u_texture_icon), u_gamma_scale: new c.b8(h, e.u_gamma_scale), u_device_pixel_ratio: new c.b8(h, e.u_device_pixel_ratio), u_is_halo: new c.bH(h, e.u_is_halo), u_translation: new c.bM(h, e.u_translation), u_pitched_scale: new c.b8(h, e.u_pitched_scale) }), background: (h, e) => ({ u_opacity: new c.b8(h, e.u_opacity), u_color: new c.bI(h, e.u_color) }), backgroundPattern: (h, e) => ({ u_opacity: new c.b8(h, e.u_opacity), u_image: new c.bH(h, e.u_image), u_pattern_tl_a: new c.bM(h, e.u_pattern_tl_a), u_pattern_br_a: new c.bM(h, e.u_pattern_br_a), u_pattern_tl_b: new c.bM(h, e.u_pattern_tl_b), u_pattern_br_b: new c.bM(h, e.u_pattern_br_b), u_texsize: new c.bM(h, e.u_texsize), u_mix: new c.b8(h, e.u_mix), u_pattern_size_a: new c.bM(h, e.u_pattern_size_a), u_pattern_size_b: new c.bM(h, e.u_pattern_size_b), u_scale_a: new c.b8(h, e.u_scale_a), u_scale_b: new c.b8(h, e.u_scale_b), u_pixel_coord_upper: new c.bM(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.bM(h, e.u_pixel_coord_lower), u_tile_units_to_pixels: new c.b8(h, e.u_tile_units_to_pixels) }), terrain: (h, e) => ({ u_texture: new c.bH(h, e.u_texture), u_ele_delta: new c.b8(h, e.u_ele_delta), u_fog_matrix: new c.bJ(h, e.u_fog_matrix), u_fog_color: new c.bI(h, e.u_fog_color), u_fog_ground_blend: new c.b8(h, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new c.b8(h, e.u_fog_ground_blend_opacity), u_horizon_color: new c.bI(h, e.u_horizon_color), u_horizon_fog_blend: new c.b8(h, e.u_horizon_fog_blend), u_is_globe_mode: new c.b8(h, e.u_is_globe_mode) }), terrainDepth: (h, e) => ({ u_ele_delta: new c.b8(h, e.u_ele_delta) }), terrainCoords: (h, e) => ({ u_texture: new c.bH(h, e.u_texture), u_terrain_coords_id: new c.b8(h, e.u_terrain_coords_id), u_ele_delta: new c.b8(h, e.u_ele_delta) }), projectionErrorMeasurement: (h, e) => ({ u_input: new c.b8(h, e.u_input), u_output_expected: new c.b8(h, e.u_output_expected) }), atmosphere: (h, e) => ({ u_sun_pos: new c.bL(h, e.u_sun_pos), u_atmosphere_blend: new c.b8(h, e.u_atmosphere_blend), u_globe_position: new c.bL(h, e.u_globe_position), u_globe_radius: new c.b8(h, e.u_globe_radius), u_inv_proj_matrix: new c.bJ(h, e.u_inv_proj_matrix) }), sky: (h, e) => ({ u_sky_color: new c.bI(h, e.u_sky_color), u_horizon_color: new c.bI(h, e.u_horizon_color), u_horizon: new c.bM(h, e.u_horizon), u_horizon_normal: new c.bM(h, e.u_horizon_normal), u_sky_horizon_blend: new c.b8(h, e.u_sky_horizon_blend), u_sky_blend: new c.b8(h, e.u_sky_blend) }) };
                class Ql {
                    constructor(e, i, s) {
                        this.context = e;
                        const o = e.gl;
                        this.buffer = o.createBuffer(), this.dynamicDraw = !!s, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || delete i.arrayBuffer;
                    }
                    bind() {
                        this.context.bindElementBuffer.set(this.buffer);
                    }
                    updateData(e) {
                        const i = this.context.gl;
                        if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
                        this.context.unbindVAO(), this.bind(), i.bufferSubData(i.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
                    }
                    destroy() {
                        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
                    }
                }
                const Co = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
                class ec {
                    constructor(e, i, s, o) {
                        this.length = i.length, this.attributes = s, this.itemSize = i.bytesPerElement, this.dynamicDraw = o, this.context = e;
                        const u = e.gl;
                        this.buffer = u.createBuffer(), e.bindVertexBuffer.set(this.buffer), u.bufferData(u.ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? u.DYNAMIC_DRAW : u.STATIC_DRAW), this.dynamicDraw || delete i.arrayBuffer;
                    }
                    bind() {
                        this.context.bindVertexBuffer.set(this.buffer);
                    }
                    updateData(e) {
                        if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
                        const i = this.context.gl;
                        this.bind(), i.bufferSubData(i.ARRAY_BUFFER, 0, e.arrayBuffer);
                    }
                    enableAttributes(e, i) {
                        for (let s = 0; s < this.attributes.length; s++) {
                            const o = i.attributes[this.attributes[s].name];
                            o !== void 0 && e.enableVertexAttribArray(o);
                        }
                    }
                    setVertexAttribPointers(e, i, s) {
                        for (let o = 0; o < this.attributes.length; o++) {
                            const u = this.attributes[o], f = i.attributes[u.name];
                            f !== void 0 && e.vertexAttribPointer(f, u.components, e[Co[u.type]], !1, this.itemSize, u.offset + this.itemSize * (s || 0));
                        }
                    }
                    destroy() {
                        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
                    }
                }
                class pt {
                    constructor(e) {
                        this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
                    }
                    get() {
                        return this.current;
                    }
                    set(e) {
                    }
                    getDefault() {
                        return this.default;
                    }
                    setDefault() {
                        this.set(this.default);
                    }
                }
                class Cr extends pt {
                    getDefault() {
                        return c.b7.transparent;
                    }
                    set(e) {
                        const i = this.current;
                        (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
                    }
                }
                class Ao extends pt {
                    getDefault() {
                        return 1;
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
                    }
                }
                class ko extends pt {
                    getDefault() {
                        return 0;
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
                    }
                }
                class zo extends pt {
                    getDefault() {
                        return [!0, !0, !0, !0];
                    }
                    set(e) {
                        const i = this.current;
                        (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
                    }
                }
                class tc extends pt {
                    getDefault() {
                        return !0;
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
                    }
                }
                class Eo extends pt {
                    getDefault() {
                        return 255;
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
                    }
                }
                class fa extends pt {
                    getDefault() {
                        return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
                    }
                    set(e) {
                        const i = this.current;
                        (e.func !== i.func || e.ref !== i.ref || e.mask !== i.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
                    }
                }
                class Ro extends pt {
                    getDefault() {
                        const e = this.gl;
                        return [e.KEEP, e.KEEP, e.KEEP];
                    }
                    set(e) {
                        const i = this.current;
                        (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
                    }
                }
                class ph extends pt {
                    getDefault() {
                        return !1;
                    }
                    set(e) {
                        if (e === this.current && !this.dirty) return;
                        const i = this.gl;
                        e ? i.enable(i.STENCIL_TEST) : i.disable(i.STENCIL_TEST), this.current = e, this.dirty = !1;
                    }
                }
                class dh extends pt {
                    getDefault() {
                        return [0, 1];
                    }
                    set(e) {
                        const i = this.current;
                        (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
                    }
                }
                class fh extends pt {
                    getDefault() {
                        return !1;
                    }
                    set(e) {
                        if (e === this.current && !this.dirty) return;
                        const i = this.gl;
                        e ? i.enable(i.DEPTH_TEST) : i.disable(i.DEPTH_TEST), this.current = e, this.dirty = !1;
                    }
                }
                class mh extends pt {
                    getDefault() {
                        return this.gl.LESS;
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
                    }
                }
                class ic extends pt {
                    getDefault() {
                        return !1;
                    }
                    set(e) {
                        if (e === this.current && !this.dirty) return;
                        const i = this.gl;
                        e ? i.enable(i.BLEND) : i.disable(i.BLEND), this.current = e, this.dirty = !1;
                    }
                }
                class gh extends pt {
                    getDefault() {
                        const e = this.gl;
                        return [e.ONE, e.ZERO];
                    }
                    set(e) {
                        const i = this.current;
                        (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);
                    }
                }
                class rc extends pt {
                    getDefault() {
                        return c.b7.transparent;
                    }
                    set(e) {
                        const i = this.current;
                        (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
                    }
                }
                class Ss extends pt {
                    getDefault() {
                        return this.gl.FUNC_ADD;
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);
                    }
                }
                class Ts extends pt {
                    getDefault() {
                        return !1;
                    }
                    set(e) {
                        if (e === this.current && !this.dirty) return;
                        const i = this.gl;
                        e ? i.enable(i.CULL_FACE) : i.disable(i.CULL_FACE), this.current = e, this.dirty = !1;
                    }
                }
                class Ps extends pt {
                    getDefault() {
                        return this.gl.BACK;
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
                    }
                }
                class Do extends pt {
                    getDefault() {
                        return this.gl.CCW;
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
                    }
                }
                class ma extends pt {
                    getDefault() {
                        return null;
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
                    }
                }
                class Ms extends pt {
                    getDefault() {
                        return this.gl.TEXTURE0;
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
                    }
                }
                class ja extends pt {
                    getDefault() {
                        const e = this.gl;
                        return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
                    }
                    set(e) {
                        const i = this.current;
                        (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
                    }
                }
                class Wi extends pt {
                    getDefault() {
                        return null;
                    }
                    set(e) {
                        if (e === this.current && !this.dirty) return;
                        const i = this.gl;
                        i.bindFramebuffer(i.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
                    }
                }
                class ac extends pt {
                    getDefault() {
                        return null;
                    }
                    set(e) {
                        if (e === this.current && !this.dirty) return;
                        const i = this.gl;
                        i.bindRenderbuffer(i.RENDERBUFFER, e), this.current = e, this.dirty = !1;
                    }
                }
                class nc extends pt {
                    getDefault() {
                        return null;
                    }
                    set(e) {
                        if (e === this.current && !this.dirty) return;
                        const i = this.gl;
                        i.bindTexture(i.TEXTURE_2D, e), this.current = e, this.dirty = !1;
                    }
                }
                class Lo extends pt {
                    getDefault() {
                        return null;
                    }
                    set(e) {
                        if (e === this.current && !this.dirty) return;
                        const i = this.gl;
                        i.bindBuffer(i.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
                    }
                }
                class ga extends pt {
                    getDefault() {
                        return null;
                    }
                    set(e) {
                        const i = this.gl;
                        i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
                    }
                }
                class Is extends pt {
                    getDefault() {
                        return null;
                    }
                    set(e) {
                        var i;
                        if (e === this.current && !this.dirty) return;
                        const s = this.gl;
                        gi(s) ? s.bindVertexArray(e) : (i = s.getExtension("OES_vertex_array_object")) === null || i === void 0 || i.bindVertexArrayOES(e), this.current = e, this.dirty = !1;
                    }
                }
                class Cs extends pt {
                    getDefault() {
                        return 4;
                    }
                    set(e) {
                        if (e === this.current && !this.dirty) return;
                        const i = this.gl;
                        i.pixelStorei(i.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
                    }
                }
                class zn extends pt {
                    getDefault() {
                        return !1;
                    }
                    set(e) {
                        if (e === this.current && !this.dirty) return;
                        const i = this.gl;
                        i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
                    }
                }
                class As extends pt {
                    getDefault() {
                        return !1;
                    }
                    set(e) {
                        if (e === this.current && !this.dirty) return;
                        const i = this.gl;
                        i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
                    }
                }
                class ks extends pt {
                    constructor(e, i) {
                        super(e), this.context = e, this.parent = i;
                    }
                    getDefault() {
                        return null;
                    }
                }
                class $a extends ks {
                    setDirty() {
                        this.dirty = !0;
                    }
                    set(e) {
                        if (e === this.current && !this.dirty) return;
                        this.context.bindFramebuffer.set(this.parent);
                        const i = this.gl;
                        i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
                    }
                }
                class Ua extends ks {
                    set(e) {
                        if (e === this.current && !this.dirty) return;
                        this.context.bindFramebuffer.set(this.parent);
                        const i = this.gl;
                        i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, e), this.current = e, this.dirty = !1;
                    }
                }
                class sc extends ks {
                    set(e) {
                        if (e === this.current && !this.dirty) return;
                        this.context.bindFramebuffer.set(this.parent);
                        const i = this.gl;
                        i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, e), this.current = e, this.dirty = !1;
                    }
                }
                const zs = "Framebuffer is not complete";
                class it {
                    constructor(e, i, s, o, u) {
                        this.context = e, this.width = i, this.height = s;
                        const f = e.gl, g = this.framebuffer = f.createFramebuffer();
                        if (this.colorAttachment = new $a(e, g), o) this.depthAttachment = u ? new sc(e, g) : new Ua(e, g);
                        else if (u) throw new Error("Stencil cannot be set without depth");
                        if (f.checkFramebufferStatus(f.FRAMEBUFFER) !== f.FRAMEBUFFER_COMPLETE) throw new Error(zs);
                    }
                    destroy() {
                        const e = this.context.gl, i = this.colorAttachment.get();
                        if (i && e.deleteTexture(i), this.depthAttachment) {
                            const s = this.depthAttachment.get();
                            s && e.deleteRenderbuffer(s);
                        }
                        e.deleteFramebuffer(this.framebuffer);
                    }
                }
                class Es {
                    constructor(e) {
                        var i, s;
                        if (this.gl = e, this.clearColor = new Cr(this), this.clearDepth = new Ao(this), this.clearStencil = new ko(this), this.colorMask = new zo(this), this.depthMask = new tc(this), this.stencilMask = new Eo(this), this.stencilFunc = new fa(this), this.stencilOp = new Ro(this), this.stencilTest = new ph(this), this.depthRange = new dh(this), this.depthTest = new fh(this), this.depthFunc = new mh(this), this.blend = new ic(this), this.blendFunc = new gh(this), this.blendColor = new rc(this), this.blendEquation = new Ss(this), this.cullFace = new Ts(this), this.cullFaceSide = new Ps(this), this.frontFace = new Do(this), this.program = new ma(this), this.activeTexture = new Ms(this), this.viewport = new ja(this), this.bindFramebuffer = new Wi(this), this.bindRenderbuffer = new ac(this), this.bindTexture = new nc(this), this.bindVertexBuffer = new Lo(this), this.bindElementBuffer = new ga(this), this.bindVertexArray = new Is(this), this.pixelStoreUnpack = new Cs(this), this.pixelStoreUnpackPremultiplyAlpha = new zn(this), this.pixelStoreUnpackFlipY = new As(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), gi(e)) {
                            this.HALF_FLOAT = e.HALF_FLOAT;
                            const o = e.getExtension("EXT_color_buffer_half_float");
                            this.RGBA16F = (i = e.RGBA16F) !== null && i !== void 0 ? i : o == null ? void 0 : o.RGBA16F_EXT, this.RGB16F = (s = e.RGB16F) !== null && s !== void 0 ? s : o == null ? void 0 : o.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
                        } else {
                            e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
                            const o = e.getExtension("OES_texture_half_float");
                            this.HALF_FLOAT = o == null ? void 0 : o.HALF_FLOAT_OES;
                        }
                    }
                    setDefault() {
                        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
                    }
                    setDirty() {
                        this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
                    }
                    createIndexBuffer(e, i) {
                        return new Ql(this, e, i);
                    }
                    createVertexBuffer(e, i, s) {
                        return new ec(this, e, i, s);
                    }
                    createRenderbuffer(e, i, s) {
                        const o = this.gl, u = o.createRenderbuffer();
                        return this.bindRenderbuffer.set(u), o.renderbufferStorage(o.RENDERBUFFER, e, i, s), this.bindRenderbuffer.set(null), u;
                    }
                    createFramebuffer(e, i, s, o) {
                        return new it(this, e, i, s, o);
                    }
                    clear({ color: e, depth: i, stencil: s }) {
                        const o = this.gl;
                        let u = 0;
                        e && (u |= o.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), i !== void 0 && (u |= o.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i), this.depthMask.set(!0)), s !== void 0 && (u |= o.STENCIL_BUFFER_BIT, this.clearStencil.set(s), this.stencilMask.set(255)), o.clear(u);
                    }
                    setCullFace(e) {
                        e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
                    }
                    setDepthMode(e) {
                        e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
                    }
                    setStencilMode(e) {
                        e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(!1);
                    }
                    setColorMode(e) {
                        c.bE(e.blendFunction, vt.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
                    }
                    createVertexArray() {
                        var e;
                        return gi(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES();
                    }
                    deleteVertexArray(e) {
                        var i;
                        return gi(this.gl) ? this.gl.deleteVertexArray(e) : (i = this.gl.getExtension("OES_vertex_array_object")) === null || i === void 0 ? void 0 : i.deleteVertexArrayOES(e);
                    }
                    unbindVAO() {
                        this.bindVertexArray.set(null);
                    }
                }
                let Rs;
                function Bo(h, e, i, s, o) {
                    const u = h.context, f = h.transform, g = u.gl, y = h.useProgram("collisionBox"), x = [];
                    let w = 0, P = 0;
                    for (let Z = 0; Z < s.length; Z++) {
                        const q = s[Z], J = e.getTile(q).getBucket(i);
                        if (!J) continue;
                        const Y = o ? J.textCollisionBox : J.iconCollisionBox, ee = J.collisionCircleArray;
                        ee.length > 0 && (x.push({ circleArray: ee, circleOffset: P, coord: q }), w += ee.length / 4, P = w), Y && y.draw(u, g.LINES, Ke.disabled, et.disabled, h.colorModeForRenderPass(), ot.disabled, lh(h.transform), h.style.map.terrain && h.style.map.terrain.getTerrainData(q), f.getProjectionData({ overscaledTileID: q, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), i.id, Y.layoutVertexBuffer, Y.indexBuffer, Y.segments, null, h.transform.zoom, null, null, Y.collisionVertexBuffer);
                    }
                    if (!o || !x.length) return;
                    const T = h.useProgram("collisionCircle"), z = new c.bT();
                    z.resize(4 * w), z._trim();
                    let R = 0;
                    for (const Z of x) for (let q = 0; q < Z.circleArray.length / 4; q++) {
                        const J = 4 * q, Y = Z.circleArray[J + 0], ee = Z.circleArray[J + 1], ae = Z.circleArray[J + 2], te = Z.circleArray[J + 3];
                        z.emplace(R++, Y, ee, ae, te, 0), z.emplace(R++, Y, ee, ae, te, 1), z.emplace(R++, Y, ee, ae, te, 2), z.emplace(R++, Y, ee, ae, te, 3);
                    }
                    (!Rs || Rs.length < 2 * w) && (Rs = function (Z) {
                        const q = 2 * Z, J = new c.bV();
                        J.resize(q), J._trim();
                        for (let Y = 0; Y < q; Y++) {
                            const ee = 6 * Y;
                            J.uint16[ee + 0] = 4 * Y + 0, J.uint16[ee + 1] = 4 * Y + 1, J.uint16[ee + 2] = 4 * Y + 2, J.uint16[ee + 3] = 4 * Y + 2, J.uint16[ee + 4] = 4 * Y + 3, J.uint16[ee + 5] = 4 * Y + 0;
                        }
                        return J;
                    }(w));
                    const V = u.createIndexBuffer(Rs, !0), U = u.createVertexBuffer(z, c.bU.members, !0);
                    for (const Z of x) {
                        const q = bs(h.transform);
                        T.draw(u, g.TRIANGLES, Ke.disabled, et.disabled, h.colorModeForRenderPass(), ot.disabled, q, h.style.map.terrain && h.style.map.terrain.getTerrainData(Z.coord), null, i.id, U, V, c.aJ.simpleSegment(0, 2 * Z.circleOffset, Z.circleArray.length, Z.circleArray.length / 2), null, h.transform.zoom, null, null, null);
                    }
                    U.destroy(), V.destroy();
                }
                const En = c.ad(new Float32Array(16));
                function _h(h, e, i, s, o, u) {
                    const { horizontalAlign: f, verticalAlign: g } = c.aE(h);
                    return new c.P((-(f - 0.5) * e / o + s[0]) * u, (-(g - 0.5) * i / o + s[1]) * u);
                }
                function yh(h, e, i, s, o, u) {
                    const f = e.tileAnchorPoint.add(new c.P(e.translation[0], e.translation[1]));
                    if (e.pitchWithMap) {
                        let g = s.mult(u);
                        i || (g = g.rotate(-o));
                        const y = f.add(g);
                        return ve(y.x, y.y, e.pitchedLabelPlaneMatrix, e.getElevation).point;
                    }
                    if (i) {
                        const g = Bt(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(h), y = Math.atan(g.y / g.x) + (g.x < 0 ? Math.PI : 0);
                        return h.add(s.rotate(y));
                    }
                    return h.add(s);
                }
                function oc(h, e, i, s, o, u, f, g, y, x, w, P) {
                    const T = h.text.placedSymbolArray, z = h.text.dynamicLayoutVertexArray, R = h.icon.dynamicLayoutVertexArray, V = {};
                    z.clear();
                    for (let U = 0; U < T.length; U++) {
                        const Z = T.get(U), q = Z.hidden || !Z.crossTileID || h.allowVerticalPlacement && !Z.placedOrientation ? null : s[Z.crossTileID];
                        if (q) {
                            const J = new c.P(Z.anchorX, Z.anchorY), Y = { getElevation: P, width: o.width, height: o.height, pitchedLabelPlaneMatrix: u, pitchWithMap: i, transform: o, tileAnchorPoint: J, translation: x, unwrappedTileID: w }, ee = i ? Qe(J.x, J.y, Y) : Bt(J.x, J.y, Y), ae = gt(o.cameraToCenterDistance, ee.signedDistanceFromCamera);
                            let te = c.am(h.textSizeData, g, Z) * ae / c.ay;
                            i && (te *= h.tilePixelRatio / f);
                            const { width: he, height: be, anchor: ge, textOffset: _e, textBoxScale: ye } = q, Ee = _h(ge, he, be, _e, ye, te), ze = o.getPitchedTextCorrection(J.x + x[0], J.y + x[1], w), Ce = yh(ee.point, Y, e, Ee, -o.bearingInRadians, ze), Ne = h.allowVerticalPlacement && Z.placedOrientation === c.al.vertical ? Math.PI / 2 : 0;
                            for (let tt = 0; tt < Z.numGlyphs; tt++) c.as(z, Ce, Ne);
                            y && Z.associatedIconIndex >= 0 && (V[Z.associatedIconIndex] = { shiftedAnchor: Ce, angle: Ne });
                        } else Mr(Z.numGlyphs, z);
                    }
                    if (y) {
                        R.clear();
                        const U = h.icon.placedSymbolArray;
                        for (let Z = 0; Z < U.length; Z++) {
                            const q = U.get(Z);
                            if (q.hidden) Mr(q.numGlyphs, R);
                            else {
                                const J = V[Z];
                                if (J) for (let Y = 0; Y < q.numGlyphs; Y++) c.as(R, J.shiftedAnchor, J.angle);
                                else Mr(q.numGlyphs, R);
                            }
                        }
                        h.icon.dynamicLayoutVertexBuffer.updateData(R);
                    }
                    h.text.dynamicLayoutVertexBuffer.updateData(z);
                }
                function vh(h, e, i) {
                    return i.iconsInText && e ? "symbolTextAndIcon" : h ? "symbolSDF" : "symbolIcon";
                }
                function Ds(h, e, i, s, o, u, f, g, y, x, w, P, T) {
                    const z = h.context, R = z.gl, V = h.transform, U = g === "map", Z = y === "map", q = g !== "viewport" && i.layout.get("symbol-placement") !== "point", J = U && !Z && !q, Y = !i.layout.get("symbol-sort-key").isConstant();
                    let ee = !1;
                    const ae = h.getDepthModeForSublayer(0, Ke.ReadOnly), te = i._unevaluatedLayout.hasValue("text-variable-anchor") || i._unevaluatedLayout.hasValue("text-variable-anchor-offset"), he = [], be = V.getCircleRadiusCorrection();
                    for (const ge of s) {
                        const _e = e.getTile(ge), ye = _e.getBucket(i);
                        if (!ye) continue;
                        const Ee = o ? ye.text : ye.icon;
                        if (!Ee || !Ee.segments.get().length || !Ee.hasVisibleVertices) continue;
                        const ze = Ee.programConfigurations.get(i.id), Ce = o || ye.sdfIcons, Ne = o ? ye.textSizeData : ye.iconSizeData, tt = Z || V.pitch !== 0, lt = h.useProgram(vh(Ce, o, ye), ze), At = c.ak(Ne, V.zoom), xt = h.style.map.terrain && h.style.map.terrain.getTerrainData(ge);
                        let kt, zt, wt, ft, Kt = [0, 0], ii = null;
                        if (o) zt = _e.glyphAtlasTexture, wt = R.LINEAR, kt = _e.glyphAtlasTexture.size, ye.iconsInText && (Kt = _e.imageAtlasTexture.size, ii = _e.imageAtlasTexture, ft = tt || h.options.rotating || h.options.zooming || Ne.kind === "composite" || Ne.kind === "camera" ? R.LINEAR : R.NEAREST);
                        else {
                            const qt = i.layout.get("icon-size").constantOr(0) !== 1 || ye.iconsNeedLinear;
                            zt = _e.imageAtlasTexture, wt = Ce || h.options.rotating || h.options.zooming || qt || tt ? R.LINEAR : R.NEAREST, kt = _e.imageAtlasTexture.size;
                        }
                        const ui = c.az(_e, 1, h.transform.zoom), mt = Ze(U, h.transform, ui), Zr = c.K();
                        c.an(Zr, mt);
                        const xr = Ye(Z, U, h.transform, ui), Gr = c.aA(V, _e, u, f), va = V.getProjectionData({ overscaledTileID: ge, applyGlobeMatrix: !T, applyTerrainMatrix: !0 }), Hn = te && ye.hasTextData(), qr = i.layout.get("icon-text-fit") !== "none" && Hn && ye.hasIconData();
                        if (q) {
                            const qt = h.style.map.terrain ? (Ii, Pt) => h.style.map.terrain.getElevation(ge, Ii, Pt) : null, Ht = i.layout.get("text-rotation-alignment") === "map";
                            dt(ye, h, o, mt, Zr, Z, x, Ht, ge.toUnwrapped(), V.width, V.height, Gr, qt);
                        }
                        const xa = o && te || qr, $i = q || xa ? En : Z ? mt : h.transform.clipSpaceToPixelsMatrix, Hr = Ce && i.paint.get(o ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
                        let kr;
                        kr = Ce ? ye.iconsInText ? ws(Ne.kind, At, J, Z, q, xa, h, $i, xr, Gr, kt, Kt, be) : Yl(Ne.kind, At, J, Z, q, xa, h, $i, xr, Gr, o, kt, 0, be) : Oa(Ne.kind, At, J, Z, q, xa, h, $i, xr, Gr, o, kt, be);
                        const Wr = { program: lt, buffers: Ee, uniformValues: kr, projectionData: va, atlasTexture: zt, atlasTextureIcon: ii, atlasInterpolation: wt, atlasInterpolationIcon: ft, isSDF: Ce, hasHalo: Hr };
                        if (Y && ye.canOverlap) {
                            ee = !0;
                            const qt = Ee.segments.get();
                            for (const Ht of qt) he.push({ segments: new c.aJ([Ht]), sortKey: Ht.sortKey, state: Wr, terrainData: xt });
                        } else he.push({ segments: Ee.segments, sortKey: 0, state: Wr, terrainData: xt });
                    }
                    ee && he.sort((ge, _e) => ge.sortKey - _e.sortKey);
                    for (const ge of he) {
                        const _e = ge.state;
                        if (z.activeTexture.set(R.TEXTURE0), _e.atlasTexture.bind(_e.atlasInterpolation, R.CLAMP_TO_EDGE), _e.atlasTextureIcon && (z.activeTexture.set(R.TEXTURE1), _e.atlasTextureIcon && _e.atlasTextureIcon.bind(_e.atlasInterpolationIcon, R.CLAMP_TO_EDGE)), _e.isSDF) {
                            const ye = _e.uniformValues;
                            _e.hasHalo && (ye.u_is_halo = 1, Rn(_e.buffers, ge.segments, i, h, _e.program, ae, w, P, ye, _e.projectionData, ge.terrainData)), ye.u_is_halo = 0;
                        }
                        Rn(_e.buffers, ge.segments, i, h, _e.program, ae, w, P, _e.uniformValues, _e.projectionData, ge.terrainData);
                    }
                }
                function Rn(h, e, i, s, o, u, f, g, y, x, w) {
                    const P = s.context;
                    o.draw(P, P.gl.TRIANGLES, u, f, g, ot.backCCW, y, w, x, i.id, h.layoutVertexBuffer, h.indexBuffer, e, i.paint, s.transform.zoom, h.programConfigurations.get(i.id), h.dynamicLayoutVertexBuffer, h.opacityVertexBuffer);
                }
                function Ls(h, e, i, s, o) {
                    const u = h.context, f = u.gl, g = et.disabled, y = new vt([f.ONE, f.ONE], c.b7.transparent, [!0, !0, !0, !0]), x = e.getBucket(i);
                    if (!x) return;
                    const w = s.key;
                    let P = i.heatmapFbos.get(w);
                    P || (P = Bs(u, e.tileSize, e.tileSize), i.heatmapFbos.set(w, P)), u.bindFramebuffer.set(P.framebuffer), u.viewport.set([0, 0, e.tileSize, e.tileSize]), u.clear({ color: c.b7.transparent });
                    const T = x.programConfigurations.get(i.id), z = h.useProgram("heatmap", T, !o), R = h.transform.getProjectionData({ overscaledTileID: e.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), V = h.style.map.terrain.getTerrainData(s);
                    z.draw(u, f.TRIANGLES, Ke.disabled, g, y, ot.disabled, da(e, h.transform.zoom, i.paint.get("heatmap-intensity"), 1), V, R, i.id, x.layoutVertexBuffer, x.indexBuffer, x.segments, i.paint, h.transform.zoom, T);
                }
                function Fo(h, e, i, s, o) {
                    const u = h.context, f = u.gl, g = h.transform;
                    u.setColorMode(h.colorModeForRenderPass());
                    const y = No(u, e), x = i.key, w = e.heatmapFbos.get(x);
                    if (!w) return;
                    u.activeTexture.set(f.TEXTURE0), f.bindTexture(f.TEXTURE_2D, w.colorAttachment.get()), u.activeTexture.set(f.TEXTURE1), y.bind(f.LINEAR, f.CLAMP_TO_EDGE);
                    const P = g.getProjectionData({ overscaledTileID: i, applyTerrainMatrix: o, applyGlobeMatrix: !s });
                    h.useProgram("heatmapTexture").draw(u, f.TRIANGLES, Ke.disabled, et.disabled, h.colorModeForRenderPass(), ot.disabled, Vl(h, e, 0, 1), null, P, e.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments, e.paint, g.zoom), w.destroy(), e.heatmapFbos.delete(x);
                }
                function Bs(h, e, i) {
                    var s, o;
                    const u = h.gl, f = u.createTexture();
                    u.bindTexture(u.TEXTURE_2D, f), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, u.LINEAR), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, u.LINEAR);
                    const g = (s = h.HALF_FLOAT) !== null && s !== void 0 ? s : u.UNSIGNED_BYTE, y = (o = h.RGBA16F) !== null && o !== void 0 ? o : u.RGBA;
                    u.texImage2D(u.TEXTURE_2D, 0, y, e, i, 0, u.RGBA, g, null);
                    const x = h.createFramebuffer(e, i, !1, !1);
                    return x.colorAttachment.set(f), x;
                }
                function No(h, e) {
                    return e.colorRampTexture || (e.colorRampTexture = new Dt(h, e.colorRamp, h.gl.RGBA)), e.colorRampTexture;
                }
                function Dn(h, e, i, s, o) {
                    if (!i || !s || !s.imageAtlas) return;
                    const u = s.imageAtlas.patternPositions;
                    let f = u[i.to.toString()], g = u[i.from.toString()];
                    if (!f && g && (f = g), !g && f && (g = f), !f || !g) {
                        const y = o.getPaintProperty(e);
                        f = u[y], g = u[y];
                    }
                    f && g && h.setConstantPatternPositions(f, g);
                }
                function Ln(h, e, i, s, o, u, f, g) {
                    const y = h.context.gl, x = "fill-pattern", w = i.paint.get(x), P = w && w.constantOr(1), T = i.getCrossfadeParameters();
                    let z, R, V, U, Z;
                    const q = h.transform, J = i.paint.get("fill-translate"), Y = i.paint.get("fill-translate-anchor");
                    f ? (R = P && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", z = y.LINES) : (R = P ? "fillPattern" : "fill", z = y.TRIANGLES);
                    const ee = w.constantOr(null);
                    for (const ae of s) {
                        const te = e.getTile(ae);
                        if (P && !te.patternsLoaded()) continue;
                        const he = te.getBucket(i);
                        if (!he) continue;
                        const be = he.programConfigurations.get(i.id), ge = h.useProgram(R, be), _e = h.style.map.terrain && h.style.map.terrain.getTerrainData(ae);
                        P && (h.context.activeTexture.set(y.TEXTURE0), te.imageAtlasTexture.bind(y.LINEAR, y.CLAMP_TO_EDGE), be.updatePaintBuffers(T)), Dn(be, x, ee, te, i);
                        const ye = q.getProjectionData({ overscaledTileID: ae, applyGlobeMatrix: !g, applyTerrainMatrix: !0 }), Ee = c.aA(q, te, J, Y);
                        if (f) {
                            U = he.indexBuffer2, Z = he.segments2;
                            const Ce = [y.drawingBufferWidth, y.drawingBufferHeight];
                            V = R === "fillOutlinePattern" && P ? Cn(h, T, te, Ce, Ee) : Po(Ce, Ee);
                        } else U = he.indexBuffer, Z = he.segments, V = P ? $l(h, T, te, Ee) : { u_fill_translate: Ee };
                        const ze = h.stencilModeForClipping(ae);
                        ge.draw(h.context, z, o, ze, u, ot.backCCW, V, _e, ye, i.id, he.layoutVertexBuffer, U, Z, i.paint, h.transform.zoom, be);
                    }
                }
                function Bn(h, e, i, s, o, u, f, g) {
                    const y = h.context, x = y.gl, w = "fill-extrusion-pattern", P = i.paint.get(w), T = P.constantOr(1), z = i.getCrossfadeParameters(), R = i.paint.get("fill-extrusion-opacity"), V = P.constantOr(null), U = h.transform;
                    for (const Z of s) {
                        const q = e.getTile(Z), J = q.getBucket(i);
                        if (!J) continue;
                        const Y = h.style.map.terrain && h.style.map.terrain.getTerrainData(Z), ee = J.programConfigurations.get(i.id), ae = h.useProgram(T ? "fillExtrusionPattern" : "fillExtrusion", ee);
                        T && (h.context.activeTexture.set(x.TEXTURE0), q.imageAtlasTexture.bind(x.LINEAR, x.CLAMP_TO_EDGE), ee.updatePaintBuffers(z));
                        const te = U.getProjectionData({ overscaledTileID: Z, applyGlobeMatrix: !g, applyTerrainMatrix: !0 });
                        Dn(ee, w, V, q, i);
                        const he = c.aA(U, q, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")), be = i.paint.get("fill-extrusion-vertical-gradient"), ge = T ? _r(h, be, R, he, Z, z, q) : xs(h, be, R, he);
                        ae.draw(y, y.gl.TRIANGLES, o, u, f, ot.backCCW, ge, Y, te, i.id, J.layoutVertexBuffer, J.indexBuffer, J.segments, i.paint, h.transform.zoom, ee, h.style.map.terrain && J.centroidVertexBuffer);
                    }
                }
                function Oo(h, e, i, s, o, u, f, g, y) {
                    var x;
                    const w = h.style.projection, P = h.context, T = h.transform, z = P.gl, R = [`#define NUM_ILLUMINATION_SOURCES ${i.paint.get("hillshade-highlight-color").values.length}`], V = h.useProgram("hillshade", null, !1, R), U = !h.options.moving;
                    for (const Z of s) {
                        const q = e.getTile(Z), J = q.fbo;
                        if (!J) continue;
                        const Y = w.getMeshFromTileID(P, Z.canonical, g, !0, "raster"), ee = (x = h.style.map.terrain) === null || x === void 0 ? void 0 : x.getTerrainData(Z);
                        P.activeTexture.set(z.TEXTURE0), z.bindTexture(z.TEXTURE_2D, J.colorAttachment.get());
                        const ae = T.getProjectionData({ overscaledTileID: Z, aligned: U, applyGlobeMatrix: !y, applyTerrainMatrix: !0 });
                        V.draw(P, z.TRIANGLES, u, o[Z.overscaledZ], f, ot.backCCW, Zl(h, q, i), ee, ae, i.id, Y.vertexBuffer, Y.indexBuffer, Y.segments);
                    }
                }
                const Fn = [new c.P(0, 0), new c.P(c.Z, 0), new c.P(c.Z, c.Z), new c.P(0, c.Z)];
                function Fs(h, e, i, s, o, u, f, g, y = !1, x = !1) {
                    const w = s[s.length - 1].overscaledZ, P = h.context, T = P.gl, z = h.useProgram("raster"), R = h.transform, V = h.style.projection, U = h.colorModeForRenderPass(), Z = !h.options.moving;
                    for (const q of s) {
                        const J = h.getDepthModeForSublayer(q.overscaledZ - w, i.paint.get("raster-opacity") === 1 ? Ke.ReadWrite : Ke.ReadOnly, T.LESS), Y = e.getTile(q);
                        Y.registerFadeDuration(i.paint.get("raster-fade-duration"));
                        const ee = e.findLoadedParent(q, 0), ae = e.findLoadedSibling(q), te = lc(Y, ee || ae || null, e, i, h.transform, h.style.map.terrain);
                        let he, be;
                        const ge = i.paint.get("raster-resampling") === "nearest" ? T.NEAREST : T.LINEAR;
                        P.activeTexture.set(T.TEXTURE0), Y.texture.bind(ge, T.CLAMP_TO_EDGE, T.LINEAR_MIPMAP_NEAREST), P.activeTexture.set(T.TEXTURE1), ee ? (ee.texture.bind(ge, T.CLAMP_TO_EDGE, T.LINEAR_MIPMAP_NEAREST), he = Math.pow(2, ee.tileID.overscaledZ - Y.tileID.overscaledZ), be = [Y.tileID.canonical.x * he % 1, Y.tileID.canonical.y * he % 1]) : Y.texture.bind(ge, T.CLAMP_TO_EDGE, T.LINEAR_MIPMAP_NEAREST), Y.texture.useMipmap && P.extTextureFilterAnisotropic && h.transform.pitch > 20 && T.texParameterf(T.TEXTURE_2D, P.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, P.extTextureFilterAnisotropicMax);
                        const _e = h.style.map.terrain && h.style.map.terrain.getTerrainData(q), ye = R.getProjectionData({ overscaledTileID: q, aligned: Z, applyGlobeMatrix: !x, applyTerrainMatrix: !0 }), Ee = Xl(be || [0, 0], he || 1, te, i, g), ze = V.getMeshFromTileID(P, q.canonical, u, f, "raster");
                        z.draw(P, T.TRIANGLES, J, o ? o[q.overscaledZ] : et.disabled, U, y ? ot.frontCCW : ot.backCCW, Ee, _e, ye, i.id, ze.vertexBuffer, ze.indexBuffer, ze.segments);
                    }
                }
                function lc(h, e, i, s, o, u) {
                    const f = s.paint.get("raster-fade-duration");
                    if (!u && f > 0) {
                        const g = Ue.now(), y = (g - h.timeAdded) / f, x = e ? (g - e.timeAdded) / f : -1, w = i.getSource(), P = pe(o, { tileSize: w.tileSize, roundZoom: w.roundZoom }), T = !e || Math.abs(e.tileID.overscaledZ - P) > Math.abs(h.tileID.overscaledZ - P), z = T && h.refreshedUponExpiration ? 1 : c.ae(T ? y : 1 - x, 0, 1);
                        return h.refreshedUponExpiration && y >= 1 && (h.refreshedUponExpiration = !1), e ? { opacity: 1, mix: 1 - z } : { opacity: z, mix: 0 };
                    }
                    return { opacity: 1, mix: 0 };
                }
                const Ns = new c.b7(1, 0, 0, 1), jo = new c.b7(0, 1, 0, 1), cc = new c.b7(0, 0, 1, 1), hc = new c.b7(1, 0, 1, 1), Os = new c.b7(0, 1, 1, 1);
                function js(h, e, i, s) {
                    Nn(h, 0, e + i / 2, h.transform.width, i, s);
                }
                function uc(h, e, i, s) {
                    Nn(h, e - i / 2, 0, i, h.transform.height, s);
                }
                function Nn(h, e, i, s, o, u) {
                    const f = h.context, g = f.gl;
                    g.enable(g.SCISSOR_TEST), g.scissor(e * h.pixelRatio, i * h.pixelRatio, s * h.pixelRatio, o * h.pixelRatio), f.clear({ color: u }), g.disable(g.SCISSOR_TEST);
                }
                function jt(h, e, i) {
                    const s = h.context, o = s.gl, u = h.useProgram("debug"), f = Ke.disabled, g = et.disabled, y = h.colorModeForRenderPass(), x = "$debug", w = h.style.map.terrain && h.style.map.terrain.getTerrainData(i);
                    s.activeTexture.set(o.TEXTURE0);
                    const P = e.getTileByID(i.key).latestRawTileData, T = Math.floor((P && P.byteLength || 0) / 1024), z = e.getTile(i).tileSize, R = 512 / Math.min(z, 512) * (i.overscaledZ / h.transform.zoom) * 0.5;
                    let V = i.canonical.toString();
                    i.overscaledZ !== i.canonical.z && (V += ` => ${i.overscaledZ}`), function (Z, q) {
                        Z.initDebugOverlayCanvas();
                        const J = Z.debugOverlayCanvas, Y = Z.context.gl, ee = Z.debugOverlayCanvas.getContext("2d");
                        ee.clearRect(0, 0, J.width, J.height), ee.shadowColor = "white", ee.shadowBlur = 2, ee.lineWidth = 1.5, ee.strokeStyle = "white", ee.textBaseline = "top", ee.font = "bold 36px Open Sans, sans-serif", ee.fillText(q, 5, 5), ee.strokeText(q, 5, 5), Z.debugOverlayTexture.update(J), Z.debugOverlayTexture.bind(Y.LINEAR, Y.CLAMP_TO_EDGE);
                    }(h, `${V} ${T}kB`);
                    const U = h.transform.getProjectionData({ overscaledTileID: i, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
                    u.draw(s, o.TRIANGLES, f, g, vt.alphaBlended, ot.disabled, Ul(c.b7.transparent, R), null, U, x, h.debugBuffer, h.quadTriangleIndexBuffer, h.debugSegments), u.draw(s, o.LINE_STRIP, f, g, y, ot.disabled, Ul(c.b7.red), w, U, x, h.debugBuffer, h.tileBorderIndexBuffer, h.debugSegments);
                }
                function Vr(h, e, i, s) {
                    const { isRenderingGlobe: o } = s, u = h.context, f = u.gl, g = h.transform, y = h.colorModeForRenderPass(), x = h.getDepthModeFor3D(), w = h.useProgram("terrain");
                    u.bindFramebuffer.set(null), u.viewport.set([0, 0, h.width, h.height]);
                    for (const P of i) {
                        const T = e.getTerrainMesh(P.tileID), z = h.renderToTexture.getTexture(P), R = e.getTerrainData(P.tileID);
                        u.activeTexture.set(f.TEXTURE0), f.bindTexture(f.TEXTURE_2D, z.texture);
                        const V = e.getMeshFrameDelta(g.zoom), U = g.calculateFogMatrix(P.tileID.toUnwrapped()), Z = oh(V, U, h.style.sky, g.pitch, o), q = g.getProjectionData({ overscaledTileID: P.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
                        w.draw(u, f.TRIANGLES, x, et.disabled, y, ot.backCCW, Z, R, q, "terrain", T.vertexBuffer, T.indexBuffer, T.segments);
                    }
                }
                function ji(h, e) {
                    if (!e.mesh) {
                        const i = new c.aI();
                        i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(1, 1), i.emplaceBack(-1, 1);
                        const s = new c.aK();
                        s.emplaceBack(0, 1, 2), s.emplaceBack(0, 2, 3), e.mesh = new Ra(h.createVertexBuffer(i, Ti.members), h.createIndexBuffer(s), c.aJ.simpleSegment(0, 0, i.length, s.length));
                    }
                    return e.mesh;
                }
                class $o {
                    constructor(e, i) {
                        this.context = new Es(e), this.transform = i, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: c.ad(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = ce.maxUnderzooming + ce.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new yn();
                    }
                    resize(e, i, s) {
                        if (this.width = Math.floor(e * s), this.height = Math.floor(i * s), this.pixelRatio = s, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const o of this.style._order) this.style._layers[o].resize();
                    }
                    setup() {
                        const e = this.context, i = new c.aI();
                        i.emplaceBack(0, 0), i.emplaceBack(c.Z, 0), i.emplaceBack(0, c.Z), i.emplaceBack(c.Z, c.Z), this.tileExtentBuffer = e.createVertexBuffer(i, Ti.members), this.tileExtentSegments = c.aJ.simpleSegment(0, 0, 4, 2);
                        const s = new c.aI();
                        s.emplaceBack(0, 0), s.emplaceBack(c.Z, 0), s.emplaceBack(0, c.Z), s.emplaceBack(c.Z, c.Z), this.debugBuffer = e.createVertexBuffer(s, Ti.members), this.debugSegments = c.aJ.simpleSegment(0, 0, 4, 5);
                        const o = new c.b_();
                        o.emplaceBack(0, 0, 0, 0), o.emplaceBack(c.Z, 0, c.Z, 0), o.emplaceBack(0, c.Z, 0, c.Z), o.emplaceBack(c.Z, c.Z, c.Z, c.Z), this.rasterBoundsBuffer = e.createVertexBuffer(o, nh.members), this.rasterBoundsSegments = c.aJ.simpleSegment(0, 0, 4, 2);
                        const u = new c.aI();
                        u.emplaceBack(0, 0), u.emplaceBack(c.Z, 0), u.emplaceBack(0, c.Z), u.emplaceBack(c.Z, c.Z), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(u, Ti.members), this.rasterBoundsSegmentsPosOnly = c.aJ.simpleSegment(0, 0, 4, 5);
                        const f = new c.aI();
                        f.emplaceBack(0, 0), f.emplaceBack(1, 0), f.emplaceBack(0, 1), f.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(f, Ti.members), this.viewportSegments = c.aJ.simpleSegment(0, 0, 4, 2);
                        const g = new c.b$();
                        g.emplaceBack(0), g.emplaceBack(1), g.emplaceBack(3), g.emplaceBack(2), g.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(g);
                        const y = new c.aK();
                        y.emplaceBack(1, 0, 2), y.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(y);
                        const x = this.context.gl;
                        this.stencilClearMode = new et({ func: x.ALWAYS, mask: 0 }, 0, 255, x.ZERO, x.ZERO, x.ZERO), this.tileExtentMesh = new Ra(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
                    }
                    clearStencil() {
                        const e = this.context, i = e.gl;
                        this.nextStencilID = 1, this.currentStencilSource = void 0;
                        const s = c.K();
                        c.bQ(s, 0, this.width, this.height, 0, 0, 1), c.M(s, s, [i.drawingBufferWidth, i.drawingBufferHeight, 0]);
                        const o = { mainMatrix: s, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: s };
                        this.useProgram("clippingMask", null, !0).draw(e, i.TRIANGLES, Ke.disabled, this.stencilClearMode, vt.disabled, ot.disabled, null, null, o, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
                    }
                    _renderTileClippingMasks(e, i, s) {
                        if (this.currentStencilSource === e.source || !e.isTileClipped() || !i || !i.length) return;
                        this.currentStencilSource = e.source, this.nextStencilID + i.length > 256 && this.clearStencil();
                        const o = this.context;
                        o.setColorMode(vt.disabled), o.setDepthMode(Ke.disabled);
                        const u = {};
                        for (const f of i) u[f.key] = this.nextStencilID++;
                        this._renderTileMasks(u, i, s, !0), this._renderTileMasks(u, i, s, !1), this._tileClippingMaskIDs = u;
                    }
                    _renderTileMasks(e, i, s, o) {
                        const u = this.context, f = u.gl, g = this.style.projection, y = this.transform, x = this.useProgram("clippingMask");
                        for (const w of i) {
                            const P = e[w.key], T = this.style.map.terrain && this.style.map.terrain.getTerrainData(w), z = g.getMeshFromTileID(this.context, w.canonical, o, !0, "stencil"), R = y.getProjectionData({ overscaledTileID: w, applyGlobeMatrix: !s, applyTerrainMatrix: !0 });
                            x.draw(u, f.TRIANGLES, Ke.disabled, new et({ func: f.ALWAYS, mask: 0 }, P, 255, f.KEEP, f.KEEP, f.REPLACE), vt.disabled, s ? ot.disabled : ot.backCCW, null, T, R, "$clipping", z.vertexBuffer, z.indexBuffer, z.segments);
                        }
                    }
                    _renderTilesDepthBuffer() {
                        const e = this.context, i = e.gl, s = this.style.projection, o = this.transform, u = this.useProgram("depth"), f = this.getDepthModeFor3D(), g = ne(o, { tileSize: o.tileSize });
                        for (const y of g) {
                            const x = this.style.map.terrain && this.style.map.terrain.getTerrainData(y), w = s.getMeshFromTileID(this.context, y.canonical, !0, !0, "raster"), P = o.getProjectionData({ overscaledTileID: y, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
                            u.draw(e, i.TRIANGLES, f, et.disabled, vt.disabled, ot.backCCW, null, x, P, "$clipping", w.vertexBuffer, w.indexBuffer, w.segments);
                        }
                    }
                    stencilModeFor3D() {
                        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
                        const e = this.nextStencilID++, i = this.context.gl;
                        return new et({ func: i.NOTEQUAL, mask: 255 }, e, 255, i.KEEP, i.KEEP, i.REPLACE);
                    }
                    stencilModeForClipping(e) {
                        const i = this.context.gl;
                        return new et({ func: i.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, i.KEEP, i.KEEP, i.REPLACE);
                    }
                    getStencilConfigForOverlapAndUpdateStencilID(e) {
                        const i = this.context.gl, s = e.sort((f, g) => g.overscaledZ - f.overscaledZ), o = s[s.length - 1].overscaledZ, u = s[0].overscaledZ - o + 1;
                        if (u > 1) {
                            this.currentStencilSource = void 0, this.nextStencilID + u > 256 && this.clearStencil();
                            const f = {};
                            for (let g = 0; g < u; g++) f[g + o] = new et({ func: i.GEQUAL, mask: 255 }, g + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);
                            return this.nextStencilID += u, [f, s];
                        }
                        return [{ [o]: et.disabled }, s];
                    }
                    stencilConfigForOverlapTwoPass(e) {
                        const i = this.context.gl, s = e.sort((f, g) => g.overscaledZ - f.overscaledZ), o = s[s.length - 1].overscaledZ, u = s[0].overscaledZ - o + 1;
                        if (this.clearStencil(), u > 1) {
                            const f = {}, g = {};
                            for (let y = 0; y < u; y++) f[y + o] = new et({ func: i.GREATER, mask: 255 }, u + 1 + y, 255, i.KEEP, i.KEEP, i.REPLACE), g[y + o] = new et({ func: i.GREATER, mask: 255 }, 1 + y, 255, i.KEEP, i.KEEP, i.REPLACE);
                            return this.nextStencilID = 2 * u + 1, [f, g, s];
                        }
                        return this.nextStencilID = 3, [{ [o]: new et({ func: i.GREATER, mask: 255 }, 2, 255, i.KEEP, i.KEEP, i.REPLACE) }, { [o]: new et({ func: i.GREATER, mask: 255 }, 1, 255, i.KEEP, i.KEEP, i.REPLACE) }, s];
                    }
                    colorModeForRenderPass() {
                        const e = this.context.gl;
                        return this._showOverdrawInspector ? new vt([e.CONSTANT_COLOR, e.ONE], new c.b7(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? vt.unblended : vt.alphaBlended;
                    }
                    getDepthModeForSublayer(e, i, s) {
                        if (!this.opaquePassEnabledForLayer()) return Ke.disabled;
                        const o = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
                        return new Ke(s || this.context.gl.LEQUAL, i, [o, o]);
                    }
                    getDepthModeFor3D() {
                        return new Ke(this.context.gl.LEQUAL, Ke.ReadWrite, this.depthRangeFor3D);
                    }
                    opaquePassEnabledForLayer() {
                        return this.currentLayer < this.opaquePassCutoff;
                    }
                    render(e, i) {
                        var s, o;
                        this.style = e, this.options = i, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(Ue.now()), this.imageManager.beginFrame();
                        const u = this.style._order, f = this.style.sourceCaches, g = {}, y = {}, x = {}, w = { isRenderingToTexture: !1, isRenderingGlobe: ((s = e.projection) === null || s === void 0 ? void 0 : s.transitionState) > 0 };
                        for (const T in f) {
                            const z = f[T];
                            z.used && z.prepare(this.context), g[T] = z.getVisibleCoordinates(!1), y[T] = g[T].slice().reverse(), x[T] = z.getVisibleCoordinates(!0).reverse();
                        }
                        this.opaquePassCutoff = 1 / 0;
                        for (let T = 0; T < u.length; T++) if (this.style._layers[u[T]].is3D()) {
                            this.opaquePassCutoff = T;
                            break;
                        }
                        this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
                        for (const T of u) {
                            const z = this.style._layers[T];
                            if (!z.hasOffscreenPass() || z.isHidden(this.transform.zoom)) continue;
                            const R = y[z.source];
                            (z.type === "custom" || R.length) && this.renderLayer(this, f[z.source], z, R, w);
                        }
                        if ((o = this.style.projection) === null || o === void 0 || o.updateGPUdependent({ context: this.context, useProgram: (T) => this.useProgram(T) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: i.showOverdrawInspector ? c.b7.black : c.b7.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function (T, z) {
                            const R = T.context, V = R.gl, U = ((ae, te, he) => {
                                const be = Math.cos(te.rollInRadians), ge = Math.sin(te.rollInRadians), _e = oe(te), ye = te.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition;
                                return { u_sky_color: ae.properties.get("sky-color"), u_horizon_color: ae.properties.get("horizon-color"), u_horizon: [(te.width / 2 - _e * ge) * he, (te.height / 2 + _e * be) * he], u_horizon_normal: [-ge, be], u_sky_horizon_blend: ae.properties.get("sky-horizon-blend") * te.height / 2 * he, u_sky_blend: ye };
                            })(z, T.style.map.transform, T.pixelRatio), Z = new Ke(V.LEQUAL, Ke.ReadWrite, [0, 1]), q = et.disabled, J = T.colorModeForRenderPass(), Y = T.useProgram("sky"), ee = ji(R, z);
                            Y.draw(R, V.TRIANGLES, Z, q, J, ot.disabled, U, null, void 0, "sky", ee.vertexBuffer, ee.indexBuffer, ee.segments);
                        }(this, this.style.sky), this._showOverdrawInspector = i.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = u.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                            const T = this.style._layers[u[this.currentLayer]], z = f[T.source], R = g[T.source];
                            this._renderTileClippingMasks(T, R, !1), this.renderLayer(this, z, T, R, w);
                        }
                        this.renderPass = "translucent";
                        let P = !1;
                        for (this.currentLayer = 0; this.currentLayer < u.length; this.currentLayer++) {
                            const T = this.style._layers[u[this.currentLayer]], z = f[T.source];
                            if (this.renderToTexture && this.renderToTexture.renderLayer(T, w)) continue;
                            this.opaquePassEnabledForLayer() || P || (P = !0, w.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
                            const R = (T.type === "symbol" ? x : y)[T.source];
                            this._renderTileClippingMasks(T, g[T.source], !!this.renderToTexture), this.renderLayer(this, z, T, R, w);
                        }
                        if (w.isRenderingGlobe && function (T, z, R) {
                            const V = T.context, U = V.gl, Z = T.useProgram("atmosphere"), q = new Ke(U.LEQUAL, Ke.ReadOnly, [0, 1]), J = T.transform, Y = function (ye, Ee) {
                                const ze = ye.properties.get("position"), Ce = [-ze.x, -ze.y, -ze.z], Ne = c.ad(new Float64Array(16));
                                return ye.properties.get("anchor") === "map" && (c.a_(Ne, Ne, Ee.rollInRadians), c.a$(Ne, Ne, -Ee.pitchInRadians), c.a_(Ne, Ne, Ee.bearingInRadians), c.a$(Ne, Ne, Ee.center.lat * Math.PI / 180), c.bp(Ne, Ne, -Ee.center.lng * Math.PI / 180)), c.bZ(Ce, Ce, Ne), Ce;
                            }(R, T.transform), ee = J.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), ae = z.properties.get("atmosphere-blend") * ee.projectionTransition;
                            if (ae === 0) return;
                            const te = ha(J.worldSize, J.center.lat), he = J.inverseProjectionMatrix, be = new Float64Array(4);
                            be[3] = 1, c.at(be, be, J.modelViewProjectionMatrix), be[0] /= be[3], be[1] /= be[3], be[2] /= be[3], be[3] = 1, c.at(be, be, he), be[0] /= be[3], be[1] /= be[3], be[2] /= be[3], be[3] = 1;
                            const ge = /* @__PURE__ */ ((ye, Ee, ze, Ce, Ne) => ({ u_sun_pos: ye, u_atmosphere_blend: Ee, u_globe_position: ze, u_globe_radius: Ce, u_inv_proj_matrix: Ne }))(Y, ae, [be[0], be[1], be[2]], te, he), _e = ji(V, z);
                            Z.draw(V, U.TRIANGLES, q, et.disabled, vt.alphaBlended, ot.disabled, ge, null, null, "atmosphere", _e.vertexBuffer, _e.indexBuffer, _e.segments);
                        }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
                            const T = function (z, R) {
                                let V = null;
                                const U = Object.values(z._layers).flatMap((Y) => Y.source && !Y.isHidden(R) ? [z.sourceCaches[Y.source]] : []), Z = U.filter((Y) => Y.getSource().type === "vector"), q = U.filter((Y) => Y.getSource().type !== "vector"), J = (Y) => {
                                    (!V || V.getSource().maxzoom < Y.getSource().maxzoom) && (V = Y);
                                };
                                return Z.forEach((Y) => J(Y)), V || q.forEach((Y) => J(Y)), V;
                            }(this.style, this.transform.zoom);
                            T && function (z, R, V) {
                                for (let U = 0; U < V.length; U++) jt(z, R, V[U]);
                            }(this, T, T.getVisibleCoordinates());
                        }
                        this.options.showPadding && function (T) {
                            const z = T.transform.padding;
                            js(T, T.transform.height - (z.top || 0), 3, Ns), js(T, z.bottom || 0, 3, jo), uc(T, z.left || 0, 3, cc), uc(T, T.transform.width - (z.right || 0), 3, hc);
                            const R = T.transform.centerPoint;
                            (function (V, U, Z, q) {
                                Nn(V, U - 1, Z - 10, 2, 20, q), Nn(V, U - 10, Z - 1, 20, 2, q);
                            })(T, R.x, T.transform.height - R.y, Os);
                        }(this), this.context.setDefault();
                    }
                    maybeDrawDepthAndCoords(e) {
                        if (!this.style || !this.style.map || !this.style.map.terrain) return;
                        const i = this.terrainFacilitator.matrix, s = this.transform.modelViewProjectionMatrix;
                        let o = this.terrainFacilitator.dirty;
                        o || (o = e ? !c.c0(i, s) : !c.c1(i, s)), o || (o = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), o && (c.c2(i, s), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function (u, f) {
                            const g = u.context, y = g.gl, x = u.transform, w = vt.unblended, P = new Ke(y.LEQUAL, Ke.ReadWrite, [0, 1]), T = f.sourceCache.getRenderableTiles(), z = u.useProgram("terrainDepth");
                            g.bindFramebuffer.set(f.getFramebuffer("depth").framebuffer), g.viewport.set([0, 0, u.width / devicePixelRatio, u.height / devicePixelRatio]), g.clear({ color: c.b7.transparent, depth: 1 });
                            for (const R of T) {
                                const V = f.getTerrainMesh(R.tileID), U = f.getTerrainData(R.tileID), Z = x.getProjectionData({ overscaledTileID: R.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), q = { u_ele_delta: f.getMeshFrameDelta(x.zoom) };
                                z.draw(g, y.TRIANGLES, P, et.disabled, w, ot.backCCW, q, U, Z, "terrain", V.vertexBuffer, V.indexBuffer, V.segments);
                            }
                            g.bindFramebuffer.set(null), g.viewport.set([0, 0, u.width, u.height]);
                        }(this, this.style.map.terrain), function (u, f) {
                            const g = u.context, y = g.gl, x = u.transform, w = vt.unblended, P = new Ke(y.LEQUAL, Ke.ReadWrite, [0, 1]), T = f.getCoordsTexture(), z = f.sourceCache.getRenderableTiles(), R = u.useProgram("terrainCoords");
                            g.bindFramebuffer.set(f.getFramebuffer("coords").framebuffer), g.viewport.set([0, 0, u.width / devicePixelRatio, u.height / devicePixelRatio]), g.clear({ color: c.b7.transparent, depth: 1 }), f.coordsIndex = [];
                            for (const V of z) {
                                const U = f.getTerrainMesh(V.tileID), Z = f.getTerrainData(V.tileID);
                                g.activeTexture.set(y.TEXTURE0), y.bindTexture(y.TEXTURE_2D, T.texture);
                                const q = { u_terrain_coords_id: (255 - f.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: f.getMeshFrameDelta(x.zoom) }, J = x.getProjectionData({ overscaledTileID: V.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
                                R.draw(g, y.TRIANGLES, P, et.disabled, w, ot.backCCW, q, Z, J, "terrain", U.vertexBuffer, U.indexBuffer, U.segments), f.coordsIndex.push(V.tileID.key);
                            }
                            g.bindFramebuffer.set(null), g.viewport.set([0, 0, u.width, u.height]);
                        }(this, this.style.map.terrain));
                    }
                    renderLayer(e, i, s, o, u) {
                        s.isHidden(this.transform.zoom) || (s.type === "background" || s.type === "custom" || (o || []).length) && (this.id = s.id, c.c3(s) ? function (f, g, y, x, w, P) {
                            if (f.renderPass !== "translucent") return;
                            const { isRenderingToTexture: T } = P, z = et.disabled, R = f.colorModeForRenderPass();
                            (y._unevaluatedLayout.hasValue("text-variable-anchor") || y._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function (V, U, Z, q, J, Y, ee, ae, te) {
                                const he = U.transform, be = U.style.map.terrain, ge = J === "map", _e = Y === "map";
                                for (const ye of V) {
                                    const Ee = q.getTile(ye), ze = Ee.getBucket(Z);
                                    if (!ze || !ze.text || !ze.text.segments.get().length) continue;
                                    const Ce = c.ak(ze.textSizeData, he.zoom), Ne = c.az(Ee, 1, U.transform.zoom), tt = Ze(ge, U.transform, Ne), lt = Z.layout.get("icon-text-fit") !== "none" && ze.hasIconData();
                                    if (Ce) {
                                        const At = Math.pow(2, he.zoom - Ee.tileID.overscaledZ), xt = be ? (kt, zt) => be.getElevation(ye, kt, zt) : null;
                                        oc(ze, ge, _e, te, he, tt, At, Ce, lt, c.aA(he, Ee, ee, ae), ye.toUnwrapped(), xt);
                                    }
                                }
                            }(x, f, y, g, y.layout.get("text-rotation-alignment"), y.layout.get("text-pitch-alignment"), y.paint.get("text-translate"), y.paint.get("text-translate-anchor"), w), y.paint.get("icon-opacity").constantOr(1) !== 0 && Ds(f, g, y, x, !1, y.paint.get("icon-translate"), y.paint.get("icon-translate-anchor"), y.layout.get("icon-rotation-alignment"), y.layout.get("icon-pitch-alignment"), y.layout.get("icon-keep-upright"), z, R, T), y.paint.get("text-opacity").constantOr(1) !== 0 && Ds(f, g, y, x, !0, y.paint.get("text-translate"), y.paint.get("text-translate-anchor"), y.layout.get("text-rotation-alignment"), y.layout.get("text-pitch-alignment"), y.layout.get("text-keep-upright"), z, R, T), g.map.showCollisionBoxes && (Bo(f, g, y, x, !0), Bo(f, g, y, x, !1));
                        }(e, i, s, o, this.style.placement.variableOffsets, u) : c.c4(s) ? function (f, g, y, x, w) {
                            if (f.renderPass !== "translucent") return;
                            const { isRenderingToTexture: P } = w, T = y.paint.get("circle-opacity"), z = y.paint.get("circle-stroke-width"), R = y.paint.get("circle-stroke-opacity"), V = !y.layout.get("circle-sort-key").isConstant();
                            if (T.constantOr(1) === 0 && (z.constantOr(1) === 0 || R.constantOr(1) === 0)) return;
                            const U = f.context, Z = U.gl, q = f.transform, J = f.getDepthModeForSublayer(0, Ke.ReadOnly), Y = et.disabled, ee = f.colorModeForRenderPass(), ae = [], te = q.getCircleRadiusCorrection();
                            for (let he = 0; he < x.length; he++) {
                                const be = x[he], ge = g.getTile(be), _e = ge.getBucket(y);
                                if (!_e) continue;
                                const ye = y.paint.get("circle-translate"), Ee = y.paint.get("circle-translate-anchor"), ze = c.aA(q, ge, ye, Ee), Ce = _e.programConfigurations.get(y.id), Ne = f.useProgram("circle", Ce), tt = _e.layoutVertexBuffer, lt = _e.indexBuffer, At = f.style.map.terrain && f.style.map.terrain.getTerrainData(be), xt = { programConfiguration: Ce, program: Ne, layoutVertexBuffer: tt, indexBuffer: lt, uniformValues: An(f, ge, y, ze, te), terrainData: At, projectionData: q.getProjectionData({ overscaledTileID: be, applyGlobeMatrix: !P, applyTerrainMatrix: !0 }) };
                                if (V) {
                                    const kt = _e.segments.get();
                                    for (const zt of kt) ae.push({ segments: new c.aJ([zt]), sortKey: zt.sortKey, state: xt });
                                } else ae.push({ segments: _e.segments, sortKey: 0, state: xt });
                            }
                            V && ae.sort((he, be) => he.sortKey - be.sortKey);
                            for (const he of ae) {
                                const { programConfiguration: be, program: ge, layoutVertexBuffer: _e, indexBuffer: ye, uniformValues: Ee, terrainData: ze, projectionData: Ce } = he.state;
                                ge.draw(U, Z.TRIANGLES, J, Y, ee, ot.backCCW, Ee, ze, Ce, y.id, _e, ye, he.segments, y.paint, f.transform.zoom, be);
                            }
                        }(e, i, s, o, u) : c.c5(s) ? function (f, g, y, x, w) {
                            if (y.paint.get("heatmap-opacity") === 0) return;
                            const P = f.context, { isRenderingToTexture: T, isRenderingGlobe: z } = w;
                            if (f.style.map.terrain) {
                                for (const R of x) {
                                    const V = g.getTile(R);
                                    g.hasRenderableParent(R) || (f.renderPass === "offscreen" ? Ls(f, V, y, R, z) : f.renderPass === "translucent" && Fo(f, y, R, T, z));
                                }
                                P.viewport.set([0, 0, f.width, f.height]);
                            } else f.renderPass === "offscreen" ? function (R, V, U, Z) {
                                const q = R.context, J = q.gl, Y = R.transform, ee = et.disabled, ae = new vt([J.ONE, J.ONE], c.b7.transparent, [!0, !0, !0, !0]);
                                (function (te, he, be) {
                                    const ge = te.gl;
                                    te.activeTexture.set(ge.TEXTURE1), te.viewport.set([0, 0, he.width / 4, he.height / 4]);
                                    let _e = be.heatmapFbos.get(c.bW);
                                    _e ? (ge.bindTexture(ge.TEXTURE_2D, _e.colorAttachment.get()), te.bindFramebuffer.set(_e.framebuffer)) : (_e = Bs(te, he.width / 4, he.height / 4), be.heatmapFbos.set(c.bW, _e));
                                })(q, R, U), q.clear({ color: c.b7.transparent });
                                for (let te = 0; te < Z.length; te++) {
                                    const he = Z[te];
                                    if (V.hasRenderableParent(he)) continue;
                                    const be = V.getTile(he), ge = be.getBucket(U);
                                    if (!ge) continue;
                                    const _e = ge.programConfigurations.get(U.id), ye = R.useProgram("heatmap", _e), Ee = Y.getProjectionData({ overscaledTileID: he, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), ze = Y.getCircleRadiusCorrection();
                                    ye.draw(q, J.TRIANGLES, Ke.disabled, ee, ae, ot.backCCW, da(be, Y.zoom, U.paint.get("heatmap-intensity"), ze), null, Ee, U.id, ge.layoutVertexBuffer, ge.indexBuffer, ge.segments, U.paint, Y.zoom, _e);
                                }
                                q.viewport.set([0, 0, R.width, R.height]);
                            }(f, g, y, x) : f.renderPass === "translucent" && function (R, V) {
                                const U = R.context, Z = U.gl;
                                U.setColorMode(R.colorModeForRenderPass());
                                const q = V.heatmapFbos.get(c.bW);
                                q && (U.activeTexture.set(Z.TEXTURE0), Z.bindTexture(Z.TEXTURE_2D, q.colorAttachment.get()), U.activeTexture.set(Z.TEXTURE1), No(U, V).bind(Z.LINEAR, Z.CLAMP_TO_EDGE), R.useProgram("heatmapTexture").draw(U, Z.TRIANGLES, Ke.disabled, et.disabled, R.colorModeForRenderPass(), ot.disabled, Vl(R, V, 0, 1), null, null, V.id, R.viewportBuffer, R.quadTriangleIndexBuffer, R.viewportSegments, V.paint, R.transform.zoom));
                            }(f, y);
                        }(e, i, s, o, u) : c.c6(s) ? function (f, g, y, x, w) {
                            if (f.renderPass !== "translucent") return;
                            const { isRenderingToTexture: P } = w, T = y.paint.get("line-opacity"), z = y.paint.get("line-width");
                            if (T.constantOr(1) === 0 || z.constantOr(1) === 0) return;
                            const R = f.getDepthModeForSublayer(0, Ke.ReadOnly), V = f.colorModeForRenderPass(), U = y.paint.get("line-dasharray"), Z = y.paint.get("line-pattern"), q = Z.constantOr(1), J = y.paint.get("line-gradient"), Y = y.getCrossfadeParameters(), ee = q ? "linePattern" : U ? "lineSDF" : J ? "lineGradient" : "line", ae = f.context, te = ae.gl, he = f.transform;
                            let be = !0;
                            for (const ge of x) {
                                const _e = g.getTile(ge);
                                if (q && !_e.patternsLoaded()) continue;
                                const ye = _e.getBucket(y);
                                if (!ye) continue;
                                const Ee = ye.programConfigurations.get(y.id), ze = f.context.program.get(), Ce = f.useProgram(ee, Ee), Ne = be || Ce.program !== ze, tt = f.style.map.terrain && f.style.map.terrain.getTerrainData(ge), lt = Z.constantOr(null);
                                if (lt && _e.imageAtlas) {
                                    const wt = _e.imageAtlas, ft = wt.patternPositions[lt.to.toString()], Kt = wt.patternPositions[lt.from.toString()];
                                    ft && Kt && Ee.setConstantPatternPositions(ft, Kt);
                                }
                                const At = he.getProjectionData({ overscaledTileID: ge, applyGlobeMatrix: !P, applyTerrainMatrix: !0 }), xt = he.getPixelScale(), kt = q ? Hl(f, _e, y, xt, Y) : U ? Wl(f, _e, y, xt, U, Y) : J ? ql(f, _e, y, xt, ye.lineClipsArray.length) : kn(f, _e, y, xt);
                                if (q) ae.activeTexture.set(te.TEXTURE0), _e.imageAtlasTexture.bind(te.LINEAR, te.CLAMP_TO_EDGE), Ee.updatePaintBuffers(Y);
                                else if (U && (Ne || f.lineAtlas.dirty)) ae.activeTexture.set(te.TEXTURE0), f.lineAtlas.bind(ae);
                                else if (J) {
                                    const wt = ye.gradients[y.id];
                                    let ft = wt.texture;
                                    if (y.gradientVersion !== wt.version) {
                                        let Kt = 256;
                                        if (y.stepInterpolant) {
                                            const ii = g.getSource().maxzoom, ui = ge.canonical.z === ii ? Math.ceil(1 << f.transform.maxZoom - ge.canonical.z) : 1;
                                            Kt = c.ae(c.bX(ye.maxLineLength / c.Z * 1024 * ui), 256, ae.maxTextureSize);
                                        }
                                        wt.gradient = c.bY({ expression: y.gradientExpression(), evaluationKey: "lineProgress", resolution: Kt, image: wt.gradient || void 0, clips: ye.lineClipsArray }), wt.texture ? wt.texture.update(wt.gradient) : wt.texture = new Dt(ae, wt.gradient, te.RGBA), wt.version = y.gradientVersion, ft = wt.texture;
                                    }
                                    ae.activeTexture.set(te.TEXTURE0), ft.bind(y.stepInterpolant ? te.NEAREST : te.LINEAR, te.CLAMP_TO_EDGE);
                                }
                                const zt = f.stencilModeForClipping(ge);
                                Ce.draw(ae, te.TRIANGLES, R, zt, V, ot.disabled, kt, tt, At, y.id, ye.layoutVertexBuffer, ye.indexBuffer, ye.segments, y.paint, f.transform.zoom, Ee, ye.layoutVertexBuffer2), be = !1;
                            }
                        }(e, i, s, o, u) : c.c7(s) ? function (f, g, y, x, w) {
                            const P = y.paint.get("fill-color"), T = y.paint.get("fill-opacity");
                            if (T.constantOr(1) === 0) return;
                            const { isRenderingToTexture: z } = w, R = f.colorModeForRenderPass(), V = y.paint.get("fill-pattern"), U = f.opaquePassEnabledForLayer() && !V.constantOr(1) && P.constantOr(c.b7.transparent).a === 1 && T.constantOr(0) === 1 ? "opaque" : "translucent";
                            if (f.renderPass === U) {
                                const Z = f.getDepthModeForSublayer(1, f.renderPass === "opaque" ? Ke.ReadWrite : Ke.ReadOnly);
                                Ln(f, g, y, x, Z, R, !1, z);
                            }
                            if (f.renderPass === "translucent" && y.paint.get("fill-antialias")) {
                                const Z = f.getDepthModeForSublayer(y.getPaintProperty("fill-outline-color") ? 2 : 0, Ke.ReadOnly);
                                Ln(f, g, y, x, Z, R, !0, z);
                            }
                        }(e, i, s, o, u) : c.c8(s) ? function (f, g, y, x, w) {
                            const P = y.paint.get("fill-extrusion-opacity");
                            if (P === 0) return;
                            const { isRenderingToTexture: T } = w;
                            if (f.renderPass === "translucent") {
                                const z = new Ke(f.context.gl.LEQUAL, Ke.ReadWrite, f.depthRangeFor3D);
                                if (P !== 1 || y.paint.get("fill-extrusion-pattern").constantOr(1)) Bn(f, g, y, x, z, et.disabled, vt.disabled, T), Bn(f, g, y, x, z, f.stencilModeFor3D(), f.colorModeForRenderPass(), T);
                                else {
                                    const R = f.colorModeForRenderPass();
                                    Bn(f, g, y, x, z, et.disabled, R, T);
                                }
                            }
                        }(e, i, s, o, u) : c.c9(s) ? function (f, g, y, x, w) {
                            if (f.renderPass !== "offscreen" && f.renderPass !== "translucent") return;
                            const { isRenderingToTexture: P } = w, T = f.context, z = f.style.projection.useSubdivision, R = f.getDepthModeForSublayer(0, Ke.ReadOnly), V = f.colorModeForRenderPass();
                            if (f.renderPass === "offscreen") (function (U, Z, q, J, Y, ee, ae) {
                                const te = U.context, he = te.gl;
                                for (const be of q) {
                                    const ge = Z.getTile(be), _e = ge.dem;
                                    if (!_e || !_e.data || !ge.needsHillshadePrepare) continue;
                                    const ye = _e.dim, Ee = _e.stride, ze = _e.getPixels();
                                    if (te.activeTexture.set(he.TEXTURE1), te.pixelStoreUnpackPremultiplyAlpha.set(!1), ge.demTexture = ge.demTexture || U.getTileTexture(Ee), ge.demTexture) {
                                        const Ne = ge.demTexture;
                                        Ne.update(ze, { premultiply: !1 }), Ne.bind(he.NEAREST, he.CLAMP_TO_EDGE);
                                    } else ge.demTexture = new Dt(te, ze, he.RGBA, { premultiply: !1 }), ge.demTexture.bind(he.NEAREST, he.CLAMP_TO_EDGE);
                                    te.activeTexture.set(he.TEXTURE0);
                                    let Ce = ge.fbo;
                                    if (!Ce) {
                                        const Ne = new Dt(te, { width: ye, height: ye, data: null }, he.RGBA);
                                        Ne.bind(he.LINEAR, he.CLAMP_TO_EDGE), Ce = ge.fbo = te.createFramebuffer(ye, ye, !0, !1), Ce.colorAttachment.set(Ne.texture);
                                    }
                                    te.bindFramebuffer.set(Ce.framebuffer), te.viewport.set([0, 0, ye, ye]), U.useProgram("hillshadePrepare").draw(te, he.TRIANGLES, Y, ee, ae, ot.disabled, ch(ge.tileID, _e), null, null, J.id, U.rasterBoundsBuffer, U.quadTriangleIndexBuffer, U.rasterBoundsSegments), ge.needsHillshadePrepare = !1;
                                }
                            })(f, g, x, y, R, et.disabled, V), T.viewport.set([0, 0, f.width, f.height]);
                            else if (f.renderPass === "translucent") if (z) {
                                const [U, Z, q] = f.stencilConfigForOverlapTwoPass(x);
                                Oo(f, g, y, q, U, R, V, !1, P), Oo(f, g, y, q, Z, R, V, !0, P);
                            } else {
                                const [U, Z] = f.getStencilConfigForOverlapAndUpdateStencilID(x);
                                Oo(f, g, y, Z, U, R, V, !1, P);
                            }
                        }(e, i, s, o, u) : c.ca(s) ? function (f, g, y, x, w) {
                            if (f.renderPass !== "translucent" || y.paint.get("raster-opacity") === 0 || !x.length) return;
                            const { isRenderingToTexture: P } = w, T = g.getSource(), z = f.style.projection.useSubdivision;
                            if (T instanceof Fi) Fs(f, g, y, x, null, !1, !1, T.tileCoords, T.flippedWindingOrder, P);
                            else if (z) {
                                const [R, V, U] = f.stencilConfigForOverlapTwoPass(x);
                                Fs(f, g, y, U, R, !1, !0, Fn, !1, P), Fs(f, g, y, U, V, !0, !0, Fn, !1, P);
                            } else {
                                const [R, V] = f.getStencilConfigForOverlapAndUpdateStencilID(x);
                                Fs(f, g, y, V, R, !1, !0, Fn, !1, P);
                            }
                        }(e, i, s, o, u) : c.cb(s) ? function (f, g, y, x, w) {
                            const P = y.paint.get("background-color"), T = y.paint.get("background-opacity");
                            if (T === 0) return;
                            const { isRenderingToTexture: z } = w, R = f.context, V = R.gl, U = f.style.projection, Z = f.transform, q = Z.tileSize, J = y.paint.get("background-pattern");
                            if (f.isPatternMissing(J)) return;
                            const Y = !J && P.a === 1 && T === 1 && f.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                            if (f.renderPass !== Y) return;
                            const ee = et.disabled, ae = f.getDepthModeForSublayer(0, Y === "opaque" ? Ke.ReadWrite : Ke.ReadOnly), te = f.colorModeForRenderPass(), he = f.useProgram(J ? "backgroundPattern" : "background"), be = x || ne(Z, { tileSize: q, terrain: f.style.map.terrain });
                            J && (R.activeTexture.set(V.TEXTURE0), f.imageManager.bind(f.context));
                            const ge = y.getCrossfadeParameters();
                            for (const _e of be) {
                                const ye = Z.getProjectionData({ overscaledTileID: _e, applyGlobeMatrix: !z, applyTerrainMatrix: !0 }), Ee = J ? uh(T, f, J, { tileID: _e, tileSize: q }, ge) : hh(T, P), ze = f.style.map.terrain && f.style.map.terrain.getTerrainData(_e), Ce = U.getMeshFromTileID(R, _e.canonical, !1, !0, "raster");
                                he.draw(R, V.TRIANGLES, ae, ee, te, ot.backCCW, Ee, ze, ye, y.id, Ce.vertexBuffer, Ce.indexBuffer, Ce.segments);
                            }
                        }(e, 0, s, o, u) : c.cc(s) && function (f, g, y, x) {
                            const { isRenderingGlobe: w } = x, P = f.context, T = y.implementation, z = f.style.projection, R = f.transform, V = R.getProjectionDataForCustomLayer(w), U = {
                                farZ: R.farZ, nearZ: R.nearZ, fov: R.fov * Math.PI / 180, modelViewProjectionMatrix: R.modelViewProjectionMatrix, projectionMatrix: R.projectionMatrix, shaderData: {
                                    variantName: z.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${z.shaderPreludeCode.vertexSource}`, define: z.shaderDefine
                                }, defaultProjectionData: V
                            }, Z = T.renderingMode ? T.renderingMode : "2d";
                            if (f.renderPass === "offscreen") {
                                const q = T.prerender;
                                q && (f.setCustomLayerDefaults(), P.setColorMode(f.colorModeForRenderPass()), q.call(T, P.gl, U), P.setDirty(), f.setBaseState());
                            } else if (f.renderPass === "translucent") {
                                f.setCustomLayerDefaults(), P.setColorMode(f.colorModeForRenderPass()), P.setStencilMode(et.disabled);
                                const q = Z === "3d" ? f.getDepthModeFor3D() : f.getDepthModeForSublayer(0, Ke.ReadOnly);
                                P.setDepthMode(q), T.render(P.gl, U), P.setDirty(), f.setBaseState(), P.bindFramebuffer.set(null);
                            }
                        }(e, 0, s, u));
                    }
                    saveTileTexture(e) {
                        const i = this._tileTextures[e.size[0]];
                        i ? i.push(e) : this._tileTextures[e.size[0]] = [e];
                    }
                    getTileTexture(e) {
                        const i = this._tileTextures[e];
                        return i && i.length > 0 ? i.pop() : null;
                    }
                    isPatternMissing(e) {
                        if (!e) return !1;
                        if (!e.from || !e.to) return !0;
                        const i = this.imageManager.getPattern(e.from.toString()), s = this.imageManager.getPattern(e.to.toString());
                        return !i || !s;
                    }
                    useProgram(e, i, s = !1, o = []) {
                        this.cache = this.cache || {};
                        const u = !!this.style.map.terrain, f = this.style.projection, g = s ? Si.projectionMercator : f.shaderPreludeCode, y = s ? la : f.shaderDefine, x = e + (i ? i.cacheKey : "") + `/${s ? st : f.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (u ? "/terrain" : "") + (o ? `/${o.join("/")}` : "");
                        return this.cache[x] || (this.cache[x] = new ys(this.context, Si[e], i, Jl[e], this._showOverdrawInspector, u, g, y, o)), this.cache[x];
                    }
                    setCustomLayerDefaults() {
                        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
                    }
                    setBaseState() {
                        const e = this.context.gl;
                        this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
                    }
                    initDebugOverlayCanvas() {
                        this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new Dt(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
                    }
                    destroy() {
                        this.debugOverlayTexture && this.debugOverlayTexture.destroy();
                    }
                    overLimit() {
                        const { drawingBufferWidth: e, drawingBufferHeight: i } = this.context.gl;
                        return this.width !== e || this.height !== i;
                    }
                }
                function On(h, e) {
                    let i, s = !1, o = null, u = null;
                    const f = () => {
                        o = null, s && (h.apply(u, i), o = setTimeout(f, e), s = !1);
                    };
                    return (...g) => (s = !0, u = this, i = g, o || f(), o);
                }
                class Uo {
                    constructor(e) {
                        this._getCurrentHash = () => {
                            const i = window.location.hash.replace("#", "");
                            if (this._hashName) {
                                let s;
                                return i.split("&").map((o) => o.split("=")).forEach((o) => {
                                    o[0] === this._hashName && (s = o);
                                }), (s && s[1] || "").split("/");
                            }
                            return i.split("/");
                        }, this._onHashChange = () => {
                            const i = this._getCurrentHash();
                            if (!this._isValidHash(i)) return !1;
                            const s = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(i[3] || 0) : this._map.getBearing();
                            return this._map.jumpTo({ center: [+i[2], +i[1]], zoom: +i[0], bearing: s, pitch: +(i[4] || 0) }), !0;
                        }, this._updateHashUnthrottled = () => {
                            const i = window.location.href.replace(/(#.*)?$/, this.getHashString());
                            window.history.replaceState(window.history.state, null, i);
                        }, this._removeHash = () => {
                            const i = this._getCurrentHash();
                            if (i.length === 0) return;
                            const s = i.join("/");
                            let o = s;
                            o.split("&").length > 0 && (o = o.split("&")[0]), this._hashName && (o = `${this._hashName}=${s}`);
                            let u = window.location.hash.replace(o, "");
                            u.startsWith("#&") ? u = u.slice(0, 1) + u.slice(2) : u === "#" && (u = "");
                            let f = window.location.href.replace(/(#.+)?$/, u);
                            f = f.replace("&&", "&"), window.history.replaceState(window.history.state, null, f);
                        }, this._updateHash = On(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
                    }
                    addTo(e) {
                        return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
                    }
                    remove() {
                        return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
                    }
                    getHashString(e) {
                        const i = this._map.getCenter(), s = Math.round(100 * this._map.getZoom()) / 100, o = Math.ceil((s * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), u = Math.pow(10, o), f = Math.round(i.lng * u) / u, g = Math.round(i.lat * u) / u, y = this._map.getBearing(), x = this._map.getPitch();
                        let w = "";
                        if (w += e ? `/${f}/${g}/${s}` : `${s}/${g}/${f}`, (y || x) && (w += "/" + Math.round(10 * y) / 10), x && (w += `/${Math.round(x)}`), this._hashName) {
                            const P = this._hashName;
                            let T = !1;
                            const z = window.location.hash.slice(1).split("&").map((R) => {
                                const V = R.split("=")[0];
                                return V === P ? (T = !0, `${V}=${w}`) : R;
                            }).filter((R) => R);
                            return T || z.push(`${P}=${w}`), `#${z.join("&")}`;
                        }
                        return `#${w}`;
                    }
                    _isValidHash(e) {
                        if (e.length < 3 || e.some(isNaN)) return !1;
                        try {
                            new c.Q(+e[2], +e[1]);
                        } catch {
                            return !1;
                        }
                        const i = +e[0], s = +(e[3] || 0), o = +(e[4] || 0);
                        return i >= this._map.getMinZoom() && i <= this._map.getMaxZoom() && s >= -180 && s <= 180 && o >= this._map.getMinPitch() && o <= this._map.getMaxPitch();
                    }
                }
                const yr = { linearity: 0.3, easing: c.cd(0, 0, 0.3, 1) }, Vo = c.e({ deceleration: 2500, maxSpeed: 1400 }, yr), jn = c.e({ deceleration: 20, maxSpeed: 1400 }, yr), Zo = c.e({ deceleration: 1e3, maxSpeed: 360 }, yr), pc = c.e({ deceleration: 1e3, maxSpeed: 90 }, yr), dc = c.e({ deceleration: 1e3, maxSpeed: 360 }, yr);
                class fc {
                    constructor(e) {
                        this._map = e, this.clear();
                    }
                    clear() {
                        this._inertiaBuffer = [];
                    }
                    record(e) {
                        this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: Ue.now(), settings: e });
                    }
                    _drainInertiaBuffer() {
                        const e = this._inertiaBuffer, i = Ue.now();
                        for (; e.length > 0 && i - e[0].time > 160;) e.shift();
                    }
                    _onMoveEnd(e) {
                        if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
                        const i = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new c.P(0, 0), pinchAround: void 0, around: void 0 };
                        for (const { settings: u } of this._inertiaBuffer) i.zoom += u.zoomDelta || 0, i.bearing += u.bearingDelta || 0, i.pitch += u.pitchDelta || 0, i.roll += u.rollDelta || 0, u.panDelta && i.pan._add(u.panDelta), u.around && (i.around = u.around), u.pinchAround && (i.pinchAround = u.pinchAround);
                        const s = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, o = {};
                        if (i.pan.mag()) {
                            const u = Za(i.pan.mag(), s, c.e({}, Vo, e || {})), f = i.pan.mult(u.amount / i.pan.mag()), g = this._map.cameraHelper.handlePanInertia(f, this._map.transform);
                            o.center = g.easingCenter, o.offset = g.easingOffset, Va(o, u);
                        }
                        if (i.zoom) {
                            const u = Za(i.zoom, s, jn);
                            o.zoom = this._map.transform.zoom + u.amount, Va(o, u);
                        }
                        if (i.bearing) {
                            const u = Za(i.bearing, s, Zo);
                            o.bearing = this._map.transform.bearing + c.ae(u.amount, -179, 179), Va(o, u);
                        }
                        if (i.pitch) {
                            const u = Za(i.pitch, s, pc);
                            o.pitch = this._map.transform.pitch + u.amount, Va(o, u);
                        }
                        if (i.roll) {
                            const u = Za(i.roll, s, dc);
                            o.roll = this._map.transform.roll + c.ae(u.amount, -179, 179), Va(o, u);
                        }
                        if (o.zoom || o.bearing) {
                            const u = i.pinchAround === void 0 ? i.around : i.pinchAround;
                            o.around = u ? this._map.unproject(u) : this._map.getCenter();
                        }
                        return this.clear(), c.e(o, { noMoveStart: !0 });
                    }
                }
                function Va(h, e) {
                    (!h.duration || h.duration < e.duration) && (h.duration = e.duration, h.easing = e.easing);
                }
                function Za(h, e, i) {
                    const { maxSpeed: s, linearity: o, deceleration: u } = i, f = c.ae(h * o / (e / 1e3), -s, s), g = Math.abs(f) / (u * o);
                    return { easing: i.easing, duration: 1e3 * g, amount: f * (g / 2) };
                }
                class Xt extends c.l {
                    preventDefault() {
                        this._defaultPrevented = !0;
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented;
                    }
                    constructor(e, i, s, o = {}) {
                        s = s instanceof MouseEvent ? s : new MouseEvent(e, s);
                        const u = de.mousePos(i.getCanvas(), s), f = i.unproject(u);
                        super(e, c.e({ point: u, lngLat: f, originalEvent: s }, o)), this._defaultPrevented = !1, this.target = i;
                    }
                }
                class Ga extends c.l {
                    preventDefault() {
                        this._defaultPrevented = !0;
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented;
                    }
                    constructor(e, i, s) {
                        const o = e === "touchend" ? s.changedTouches : s.touches, u = de.touchPos(i.getCanvasContainer(), o), f = u.map((y) => i.unproject(y)), g = u.reduce((y, x, w, P) => y.add(x.div(P.length)), new c.P(0, 0));
                        super(e, { points: u, point: g, lngLats: f, lngLat: i.unproject(g), originalEvent: s }), this._defaultPrevented = !1;
                    }
                }
                class Go extends c.l {
                    preventDefault() {
                        this._defaultPrevented = !0;
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented;
                    }
                    constructor(e, i, s) {
                        super(e, { originalEvent: s }), this._defaultPrevented = !1;
                    }
                }
                class mc {
                    constructor(e, i) {
                        this._map = e, this._clickTolerance = i.clickTolerance;
                    }
                    reset() {
                        delete this._mousedownPos;
                    }
                    wheel(e) {
                        return this._firePreventable(new Go(e.type, this._map, e));
                    }
                    mousedown(e, i) {
                        return this._mousedownPos = i, this._firePreventable(new Xt(e.type, this._map, e));
                    }
                    mouseup(e) {
                        this._map.fire(new Xt(e.type, this._map, e));
                    }
                    click(e, i) {
                        this._mousedownPos && this._mousedownPos.dist(i) >= this._clickTolerance || this._map.fire(new Xt(e.type, this._map, e));
                    }
                    dblclick(e) {
                        return this._firePreventable(new Xt(e.type, this._map, e));
                    }
                    mouseover(e) {
                        this._map.fire(new Xt(e.type, this._map, e));
                    }
                    mouseout(e) {
                        this._map.fire(new Xt(e.type, this._map, e));
                    }
                    touchstart(e) {
                        return this._firePreventable(new Ga(e.type, this._map, e));
                    }
                    touchmove(e) {
                        this._map.fire(new Ga(e.type, this._map, e));
                    }
                    touchend(e) {
                        this._map.fire(new Ga(e.type, this._map, e));
                    }
                    touchcancel(e) {
                        this._map.fire(new Ga(e.type, this._map, e));
                    }
                    _firePreventable(e) {
                        if (this._map.fire(e), e.defaultPrevented) return {};
                    }
                    isEnabled() {
                        return !0;
                    }
                    isActive() {
                        return !1;
                    }
                    enable() {
                    }
                    disable() {
                    }
                }
                class gc {
                    constructor(e) {
                        this._map = e;
                    }
                    reset() {
                        this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
                    }
                    mousemove(e) {
                        this._map.fire(new Xt(e.type, this._map, e));
                    }
                    mousedown() {
                        this._delayContextMenu = !0, this._ignoreContextMenu = !1;
                    }
                    mouseup() {
                        this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Xt("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
                    }
                    contextmenu(e) {
                        this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Xt(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
                    }
                    isEnabled() {
                        return !0;
                    }
                    isActive() {
                        return !1;
                    }
                    enable() {
                    }
                    disable() {
                    }
                }
                class qa {
                    constructor(e) {
                        this._map = e;
                    }
                    get transform() {
                        return this._map._requestedCameraState || this._map.transform;
                    }
                    get center() {
                        return { lng: this.transform.center.lng, lat: this.transform.center.lat };
                    }
                    get zoom() {
                        return this.transform.zoom;
                    }
                    get pitch() {
                        return this.transform.pitch;
                    }
                    get bearing() {
                        return this.transform.bearing;
                    }
                    unproject(e) {
                        return this.transform.screenPointToLocation(c.P.convert(e), this._map.terrain);
                    }
                }
                class qo {
                    constructor(e, i) {
                        this._map = e, this._tr = new qa(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = i.clickTolerance || 1;
                    }
                    isEnabled() {
                        return !!this._enabled;
                    }
                    isActive() {
                        return !!this._active;
                    }
                    enable() {
                        this.isEnabled() || (this._enabled = !0);
                    }
                    disable() {
                        this.isEnabled() && (this._enabled = !1);
                    }
                    mousedown(e, i) {
                        this.isEnabled() && e.shiftKey && e.button === 0 && (de.disableDrag(), this._startPos = this._lastPos = i, this._active = !0);
                    }
                    mousemoveWindow(e, i) {
                        if (!this._active) return;
                        const s = i;
                        if (this._lastPos.equals(s) || !this._box && s.dist(this._startPos) < this._clickTolerance) return;
                        const o = this._startPos;
                        this._lastPos = s, this._box || (this._box = de.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
                        const u = Math.min(o.x, s.x), f = Math.max(o.x, s.x), g = Math.min(o.y, s.y), y = Math.max(o.y, s.y);
                        de.setTransform(this._box, `translate(${u}px,${g}px)`), this._box.style.width = f - u + "px", this._box.style.height = y - g + "px";
                    }
                    mouseupWindow(e, i) {
                        if (!this._active || e.button !== 0) return;
                        const s = this._startPos, o = i;
                        if (this.reset(), de.suppressClick(), s.x !== o.x || s.y !== o.y) return this._map.fire(new c.l("boxzoomend", { originalEvent: e })), { cameraAnimation: (u) => u.fitScreenCoordinates(s, o, this._tr.bearing, { linear: !0 }) };
                        this._fireEvent("boxzoomcancel", e);
                    }
                    keydown(e) {
                        this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
                    }
                    reset() {
                        this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (de.remove(this._box), this._box = null), de.enableDrag(), delete this._startPos, delete this._lastPos;
                    }
                    _fireEvent(e, i) {
                        return this._map.fire(new c.l(e, { originalEvent: i }));
                    }
                }
                function $s(h, e) {
                    if (h.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${h.length}, points ${e.length}`);
                    const i = {};
                    for (let s = 0; s < h.length; s++) i[h[s].identifier] = e[s];
                    return i;
                }
                class _c {
                    constructor(e) {
                        this.reset(), this.numTouches = e.numTouches;
                    }
                    reset() {
                        delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
                    }
                    touchstart(e, i, s) {
                        (this.centroid || s.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), s.length === this.numTouches && (this.centroid = function (o) {
                            const u = new c.P(0, 0);
                            for (const f of o) u._add(f);
                            return u.div(o.length);
                        }(i), this.touches = $s(s, i)));
                    }
                    touchmove(e, i, s) {
                        if (this.aborted || !this.centroid) return;
                        const o = $s(s, i);
                        for (const u in this.touches) {
                            const f = o[u];
                            (!f || f.dist(this.touches[u]) > 30) && (this.aborted = !0);
                        }
                    }
                    touchend(e, i, s) {
                        if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), s.length === 0) {
                            const o = !this.aborted && this.centroid;
                            if (this.reset(), o) return o;
                        }
                    }
                }
                class Ha {
                    constructor(e) {
                        this.singleTap = new _c(e), this.numTaps = e.numTaps, this.reset();
                    }
                    reset() {
                        this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
                    }
                    touchstart(e, i, s) {
                        this.singleTap.touchstart(e, i, s);
                    }
                    touchmove(e, i, s) {
                        this.singleTap.touchmove(e, i, s);
                    }
                    touchend(e, i, s) {
                        const o = this.singleTap.touchend(e, i, s);
                        if (o) {
                            const u = e.timeStamp - this.lastTime < 500, f = !this.lastTap || this.lastTap.dist(o) < 30;
                            if (u && f || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;
                        }
                    }
                }
                class yc {
                    constructor(e) {
                        this._tr = new qa(e), this._zoomIn = new Ha({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Ha({ numTouches: 2, numTaps: 1 }), this.reset();
                    }
                    reset() {
                        this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
                    }
                    touchstart(e, i, s) {
                        this._zoomIn.touchstart(e, i, s), this._zoomOut.touchstart(e, i, s);
                    }
                    touchmove(e, i, s) {
                        this._zoomIn.touchmove(e, i, s), this._zoomOut.touchmove(e, i, s);
                    }
                    touchend(e, i, s) {
                        const o = this._zoomIn.touchend(e, i, s), u = this._zoomOut.touchend(e, i, s), f = this._tr;
                        return o ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (g) => g.easeTo({ duration: 300, zoom: f.zoom + 1, around: f.unproject(o) }, { originalEvent: e }) }) : u ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (g) => g.easeTo({ duration: 300, zoom: f.zoom - 1, around: f.unproject(u) }, { originalEvent: e }) }) : void 0;
                    }
                    touchcancel() {
                        this.reset();
                    }
                    enable() {
                        this._enabled = !0;
                    }
                    disable() {
                        this._enabled = !1, this.reset();
                    }
                    isEnabled() {
                        return this._enabled;
                    }
                    isActive() {
                        return this._active;
                    }
                }
                class yi {
                    constructor(e) {
                        this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
                    }
                    reset(e) {
                        this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e);
                    }
                    _move(...e) {
                        const i = this._moveFunction(...e);
                        if (i.bearingDelta || i.pitchDelta || i.rollDelta || i.around || i.panDelta) return this._active = !0, i;
                    }
                    dragStart(e, i) {
                        this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(i) ? i[0] : i, this._activateOnStart && this._lastPoint && (this._active = !0));
                    }
                    dragMove(e, i) {
                        if (!this.isEnabled()) return;
                        const s = this._lastPoint;
                        if (!s) return;
                        if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
                        const o = Array.isArray(i) ? i[0] : i;
                        return !this._moved && o.dist(s) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = o, this._move(s, o));
                    }
                    dragEnd(e) {
                        this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && de.suppressClick(), this.reset(e));
                    }
                    enable() {
                        this._enabled = !0;
                    }
                    disable() {
                        this._enabled = !1, this.reset();
                    }
                    isEnabled() {
                        return this._enabled;
                    }
                    isActive() {
                        return this._active;
                    }
                    getClickTolerance() {
                        return this._clickTolerance;
                    }
                }
                const tr = { 0: 1, 2: 2 };
                class Wa {
                    constructor(e) {
                        this._correctEvent = e.checkCorrectEvent;
                    }
                    startMove(e) {
                        const i = de.mouseButton(e);
                        this._eventButton = i;
                    }
                    endMove(e) {
                        delete this._eventButton;
                    }
                    isValidStartEvent(e) {
                        return this._correctEvent(e);
                    }
                    isValidMoveEvent(e) {
                        return !function (i, s) {
                            const o = tr[s];
                            return i.buttons === void 0 || (i.buttons & o) !== o;
                        }(e, this._eventButton);
                    }
                    isValidEndEvent(e) {
                        return de.mouseButton(e) === this._eventButton;
                    }
                }
                class ir {
                    constructor() {
                        this._firstTouch = void 0;
                    }
                    _isOneFingerTouch(e) {
                        return e.targetTouches.length === 1;
                    }
                    _isSameTouchEvent(e) {
                        return e.targetTouches[0].identifier === this._firstTouch;
                    }
                    startMove(e) {
                        this._firstTouch = e.targetTouches[0].identifier;
                    }
                    endMove(e) {
                        delete this._firstTouch;
                    }
                    isValidStartEvent(e) {
                        return this._isOneFingerTouch(e);
                    }
                    isValidMoveEvent(e) {
                        return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
                    }
                    isValidEndEvent(e) {
                        return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
                    }
                }
                class Xa {
                    constructor(e = new Wa({ checkCorrectEvent: () => !0 }), i = new ir()) {
                        this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = i;
                    }
                    _executeRelevantHandler(e, i, s) {
                        return e instanceof MouseEvent ? i(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? s(e) : void 0;
                    }
                    startMove(e) {
                        this._executeRelevantHandler(e, (i) => this.mouseMoveStateManager.startMove(i), (i) => this.oneFingerTouchMoveStateManager.startMove(i));
                    }
                    endMove(e) {
                        this._executeRelevantHandler(e, (i) => this.mouseMoveStateManager.endMove(i), (i) => this.oneFingerTouchMoveStateManager.endMove(i));
                    }
                    isValidStartEvent(e) {
                        return this._executeRelevantHandler(e, (i) => this.mouseMoveStateManager.isValidStartEvent(i), (i) => this.oneFingerTouchMoveStateManager.isValidStartEvent(i));
                    }
                    isValidMoveEvent(e) {
                        return this._executeRelevantHandler(e, (i) => this.mouseMoveStateManager.isValidMoveEvent(i), (i) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(i));
                    }
                    isValidEndEvent(e) {
                        return this._executeRelevantHandler(e, (i) => this.mouseMoveStateManager.isValidEndEvent(i), (i) => this.oneFingerTouchMoveStateManager.isValidEndEvent(i));
                    }
                }
                const Us = (h) => {
                    h.mousedown = h.dragStart, h.mousemoveWindow = h.dragMove, h.mouseup = h.dragEnd, h.contextmenu = (e) => {
                        e.preventDefault();
                    };
                };
                class xh {
                    constructor(e, i) {
                        this._clickTolerance = e.clickTolerance || 1, this._map = i, this.reset();
                    }
                    reset() {
                        this._active = !1, this._touches = {}, this._sum = new c.P(0, 0);
                    }
                    _shouldBePrevented(e) {
                        return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
                    }
                    touchstart(e, i, s) {
                        return this._calculateTransform(e, i, s);
                    }
                    touchmove(e, i, s) {
                        if (this._active) {
                            if (!this._shouldBePrevented(s.length)) return e.preventDefault(), this._calculateTransform(e, i, s);
                            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
                        }
                    }
                    touchend(e, i, s) {
                        this._calculateTransform(e, i, s), this._active && this._shouldBePrevented(s.length) && this.reset();
                    }
                    touchcancel() {
                        this.reset();
                    }
                    _calculateTransform(e, i, s) {
                        s.length > 0 && (this._active = !0);
                        const o = $s(s, i), u = new c.P(0, 0), f = new c.P(0, 0);
                        let g = 0;
                        for (const x in o) {
                            const w = o[x], P = this._touches[x];
                            P && (u._add(w), f._add(w.sub(P)), g++, o[x] = w);
                        }
                        if (this._touches = o, this._shouldBePrevented(g) || !f.mag()) return;
                        const y = f.div(g);
                        return this._sum._add(y), this._sum.mag() < this._clickTolerance ? void 0 : { around: u.div(g), panDelta: y };
                    }
                    enable() {
                        this._enabled = !0;
                    }
                    disable() {
                        this._enabled = !1, this.reset();
                    }
                    isEnabled() {
                        return this._enabled;
                    }
                    isActive() {
                        return this._active;
                    }
                }
                class Ho {
                    constructor() {
                        this.reset();
                    }
                    reset() {
                        this._active = !1, delete this._firstTwoTouches;
                    }
                    touchstart(e, i, s) {
                        this._firstTwoTouches || s.length < 2 || (this._firstTwoTouches = [s[0].identifier, s[1].identifier], this._start([i[0], i[1]]));
                    }
                    touchmove(e, i, s) {
                        if (!this._firstTwoTouches) return;
                        e.preventDefault();
                        const [o, u] = this._firstTwoTouches, f = Vs(s, i, o), g = Vs(s, i, u);
                        if (!f || !g) return;
                        const y = this._aroundCenter ? null : f.add(g).div(2);
                        return this._move([f, g], y, e);
                    }
                    touchend(e, i, s) {
                        if (!this._firstTwoTouches) return;
                        const [o, u] = this._firstTwoTouches, f = Vs(s, i, o), g = Vs(s, i, u);
                        f && g || (this._active && de.suppressClick(), this.reset());
                    }
                    touchcancel() {
                        this.reset();
                    }
                    enable(e) {
                        this._enabled = !0, this._aroundCenter = !!e && e.around === "center";
                    }
                    disable() {
                        this._enabled = !1, this.reset();
                    }
                    isEnabled() {
                        return !!this._enabled;
                    }
                    isActive() {
                        return !!this._active;
                    }
                }
                function Vs(h, e, i) {
                    for (let s = 0; s < h.length; s++) if (h[s].identifier === i) return e[s];
                }
                function Wo(h, e) {
                    return Math.log(h / e) / Math.LN2;
                }
                class Ka extends Ho {
                    reset() {
                        super.reset(), delete this._distance, delete this._startDistance;
                    }
                    _start(e) {
                        this._startDistance = this._distance = e[0].dist(e[1]);
                    }
                    _move(e, i) {
                        const s = this._distance;
                        if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Wo(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: Wo(this._distance, s), pinchAround: i };
                    }
                }
                function vr(h, e) {
                    return 180 * h.angleWith(e) / Math.PI;
                }
                class Le extends Ho {
                    reset() {
                        super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
                    }
                    _start(e) {
                        this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
                    }
                    _move(e, i, s) {
                        const o = this._vector;
                        if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: vr(this._vector, o), pinchAround: i };
                    }
                    _isBelowThreshold(e) {
                        this._minDiameter = Math.min(this._minDiameter, e.mag());
                        const i = 25 / (Math.PI * this._minDiameter) * 360, s = vr(e, this._startVector);
                        return Math.abs(s) < i;
                    }
                }
                function Zs(h) {
                    return Math.abs(h.y) > Math.abs(h.x);
                }
                class Gs extends Ho {
                    constructor(e) {
                        super(), this._currentTouchCount = 0, this._map = e;
                    }
                    reset() {
                        super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
                    }
                    touchstart(e, i, s) {
                        super.touchstart(e, i, s), this._currentTouchCount = s.length;
                    }
                    _start(e) {
                        this._lastPoints = e, Zs(e[0].sub(e[1])) && (this._valid = !1);
                    }
                    _move(e, i, s) {
                        if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
                        const o = e[0].sub(this._lastPoints[0]), u = e[1].sub(this._lastPoints[1]);
                        return this._valid = this.gestureBeginsVertically(o, u, s.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, { pitchDelta: (o.y + u.y) / 2 * -0.5 }) : void 0;
                    }
                    gestureBeginsVertically(e, i, s) {
                        if (this._valid !== void 0) return this._valid;
                        const o = e.mag() >= 2, u = i.mag() >= 2;
                        if (!o && !u) return;
                        if (!o || !u) return this._firstMove === void 0 && (this._firstMove = s), s - this._firstMove < 100 && void 0;
                        const f = e.y > 0 == i.y > 0;
                        return Zs(e) && Zs(i) && f;
                    }
                }
                const vc = { panStep: 100, bearingStep: 15, pitchStep: 10 };
                class Ya {
                    constructor(e) {
                        this._tr = new qa(e);
                        const i = vc;
                        this._panStep = i.panStep, this._bearingStep = i.bearingStep, this._pitchStep = i.pitchStep, this._rotationDisabled = !1;
                    }
                    reset() {
                        this._active = !1;
                    }
                    keydown(e) {
                        if (e.altKey || e.ctrlKey || e.metaKey) return;
                        let i = 0, s = 0, o = 0, u = 0, f = 0;
                        switch (e.keyCode) {
                            case 61:
                            case 107:
                            case 171:
                            case 187:
                                i = 1;
                                break;
                            case 189:
                            case 109:
                            case 173:
                                i = -1;
                                break;
                            case 37:
                                e.shiftKey ? s = -1 : (e.preventDefault(), u = -1);
                                break;
                            case 39:
                                e.shiftKey ? s = 1 : (e.preventDefault(), u = 1);
                                break;
                            case 38:
                                e.shiftKey ? o = 1 : (e.preventDefault(), f = -1);
                                break;
                            case 40:
                                e.shiftKey ? o = -1 : (e.preventDefault(), f = 1);
                                break;
                            default:
                                return;
                        }
                        return this._rotationDisabled && (s = 0, o = 0), {
                            cameraAnimation: (g) => {
                                const y = this._tr;
                                g.easeTo({ duration: 300, easeId: "keyboardHandler", easing: $n, zoom: i ? Math.round(y.zoom) + i * (e.shiftKey ? 2 : 1) : y.zoom, bearing: y.bearing + s * this._bearingStep, pitch: y.pitch + o * this._pitchStep, offset: [-u * this._panStep, -f * this._panStep], center: y.center }, { originalEvent: e });
                            }
                        };
                    }
                    enable() {
                        this._enabled = !0;
                    }
                    disable() {
                        this._enabled = !1, this.reset();
                    }
                    isEnabled() {
                        return this._enabled;
                    }
                    isActive() {
                        return this._active;
                    }
                    disableRotation() {
                        this._rotationDisabled = !0;
                    }
                    enableRotation() {
                        this._rotationDisabled = !1;
                    }
                }
                function $n(h) {
                    return h * (2 - h);
                }
                const Xo = 4.000244140625;
                class rt {
                    constructor(e, i) {
                        this._onTimeout = (s) => {
                            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(s);
                        }, this._map = e, this._tr = new qa(e), this._triggerRenderFrame = i, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
                    }
                    setZoomRate(e) {
                        this._defaultZoomRate = e;
                    }
                    setWheelZoomRate(e) {
                        this._wheelZoomRate = e;
                    }
                    isEnabled() {
                        return !!this._enabled;
                    }
                    isActive() {
                        return !!this._active || this._finishTimeout !== void 0;
                    }
                    isZooming() {
                        return !!this._zooming;
                    }
                    enable(e) {
                        this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center");
                    }
                    disable() {
                        this.isEnabled() && (this._enabled = !1);
                    }
                    _shouldBePrevented(e) {
                        return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e));
                    }
                    wheel(e) {
                        if (!this.isEnabled()) return;
                        if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
                        let i = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
                        const s = Ue.now(), o = s - (this._lastWheelEventTime || 0);
                        this._lastWheelEventTime = s, i !== 0 && i % Xo == 0 ? this._type = "wheel" : i !== 0 && Math.abs(i) < 4 ? this._type = "trackpad" : o > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(o * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), e.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = e, this._delta -= i, this._active || this._start(e)), e.preventDefault();
                    }
                    _start(e) {
                        if (!this._delta) return;
                        this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
                        const i = de.mousePos(this._map.getCanvas(), e), s = this._tr;
                        this._aroundPoint = this._aroundCenter ? s.transform.locationToScreenPoint(c.Q.convert(s.center)) : i, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
                    }
                    renderFrame() {
                        if (!this._frameId || (this._frameId = null, !this.isActive())) return;
                        const e = this._tr.transform;
                        if (typeof this._lastExpectedZoom == "number") {
                            const g = e.zoom - this._lastExpectedZoom;
                            typeof this._startZoom == "number" && (this._startZoom += g), typeof this._targetZoom == "number" && (this._targetZoom += g);
                        }
                        if (this._delta !== 0) {
                            const g = this._type === "wheel" && Math.abs(this._delta) > Xo ? this._wheelZoomRate : this._defaultZoomRate;
                            let y = 2 / (1 + Math.exp(-Math.abs(this._delta * g)));
                            this._delta < 0 && y !== 0 && (y = 1 / y);
                            const x = typeof this._targetZoom != "number" ? e.scale : c.ac(this._targetZoom);
                            this._targetZoom = e.getConstrained(e.getCameraLngLat(), c.ah(x * y)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
                        }
                        const i = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom, s = this._startZoom, o = this._easing;
                        let u, f = !1;
                        if (this._type === "wheel" && s && o) {
                            const g = Ue.now() - this._lastWheelEventTime, y = Math.min((g + 5) / 200, 1), x = o(y);
                            u = c.B.number(s, i, x), y < 1 ? this._frameId || (this._frameId = !0) : f = !0;
                        } else u = i, f = !0;
                        return this._active = !0, f && (this._active = !1, this._finishTimeout = setTimeout(() => {
                            this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
                        }, 200)), this._lastExpectedZoom = u, { noInertia: !0, needsRenderFrame: !f, zoomDelta: u - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
                    }
                    _smoothOutEasing(e) {
                        let i = c.cf;
                        if (this._prevEase) {
                            const s = this._prevEase, o = (Ue.now() - s.start) / s.duration, u = s.easing(o + 0.01) - s.easing(o), f = 0.27 / Math.sqrt(u * u + 1e-4) * 0.01, g = Math.sqrt(0.0729 - f * f);
                            i = c.cd(f, g, 0.25, 1);
                        }
                        return this._prevEase = { start: Ue.now(), duration: e, easing: i }, i;
                    }
                    reset() {
                        this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
                    }
                }
                class qs {
                    constructor(e, i) {
                        this._clickZoom = e, this._tapZoom = i;
                    }
                    enable() {
                        this._clickZoom.enable(), this._tapZoom.enable();
                    }
                    disable() {
                        this._clickZoom.disable(), this._tapZoom.disable();
                    }
                    isEnabled() {
                        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
                    }
                    isActive() {
                        return this._clickZoom.isActive() || this._tapZoom.isActive();
                    }
                }
                class bh {
                    constructor(e) {
                        this._tr = new qa(e), this.reset();
                    }
                    reset() {
                        this._active = !1;
                    }
                    dblclick(e, i) {
                        return e.preventDefault(), {
                            cameraAnimation: (s) => {
                                s.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(i) }, { originalEvent: e });
                            }
                        };
                    }
                    enable() {
                        this._enabled = !0;
                    }
                    disable() {
                        this._enabled = !1, this.reset();
                    }
                    isEnabled() {
                        return this._enabled;
                    }
                    isActive() {
                        return this._active;
                    }
                }
                class Ko {
                    constructor() {
                        this._tap = new Ha({ numTouches: 1, numTaps: 1 }), this.reset();
                    }
                    reset() {
                        this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
                    }
                    touchstart(e, i, s) {
                        if (!this._swipePoint) if (this._tapTime) {
                            const o = i[0], u = e.timeStamp - this._tapTime < 500, f = this._tapPoint.dist(o) < 30;
                            u && f ? s.length > 0 && (this._swipePoint = o, this._swipeTouch = s[0].identifier) : this.reset();
                        } else this._tap.touchstart(e, i, s);
                    }
                    touchmove(e, i, s) {
                        if (this._tapTime) {
                            if (this._swipePoint) {
                                if (s[0].identifier !== this._swipeTouch) return;
                                const o = i[0], u = o.y - this._swipePoint.y;
                                return this._swipePoint = o, e.preventDefault(), this._active = !0, { zoomDelta: u / 128 };
                            }
                        } else this._tap.touchmove(e, i, s);
                    }
                    touchend(e, i, s) {
                        if (this._tapTime) this._swipePoint && s.length === 0 && this.reset();
                        else {
                            const o = this._tap.touchend(e, i, s);
                            o && (this._tapTime = e.timeStamp, this._tapPoint = o);
                        }
                    }
                    touchcancel() {
                        this.reset();
                    }
                    enable() {
                        this._enabled = !0;
                    }
                    disable() {
                        this._enabled = !1, this.reset();
                    }
                    isEnabled() {
                        return this._enabled;
                    }
                    isActive() {
                        return this._active;
                    }
                }
                class xc {
                    constructor(e, i, s) {
                        this._el = e, this._mousePan = i, this._touchPan = s;
                    }
                    enable(e) {
                        this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
                    }
                    disable() {
                        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
                    }
                    isEnabled() {
                        return this._mousePan.isEnabled() && this._touchPan.isEnabled();
                    }
                    isActive() {
                        return this._mousePan.isActive() || this._touchPan.isActive();
                    }
                }
                class bc {
                    constructor(e, i, s, o) {
                        this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = i, this._mousePitch = s, this._mouseRoll = o;
                    }
                    enable() {
                        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
                    }
                    disable() {
                        this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
                    }
                    isEnabled() {
                        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
                    }
                    isActive() {
                        return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
                    }
                }
                class Yo {
                    constructor(e, i, s, o) {
                        this._el = e, this._touchZoom = i, this._touchRotate = s, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;
                    }
                    enable(e) {
                        this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
                    }
                    disable() {
                        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
                    }
                    isEnabled() {
                        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
                    }
                    isActive() {
                        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
                    }
                    disableRotation() {
                        this._rotationDisabled = !0, this._touchRotate.disable();
                    }
                    enableRotation() {
                        this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
                    }
                }
                class Hs {
                    constructor(e, i) {
                        this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = i, this._enabled = !1;
                    }
                    isActive() {
                        return !1;
                    }
                    reset() {
                    }
                    _setupUI() {
                        if (this._container) return;
                        const e = this._map.getCanvasContainer();
                        e.classList.add("maplibregl-cooperative-gestures"), this._container = de.create("div", "maplibregl-cooperative-gesture-screen", e);
                        let i = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
                        this._bypassKey === "metaKey" && (i = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
                        const s = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), o = document.createElement("div");
                        o.className = "maplibregl-desktop-message", o.textContent = i, this._container.appendChild(o);
                        const u = document.createElement("div");
                        u.className = "maplibregl-mobile-message", u.textContent = s, this._container.appendChild(u), this._container.setAttribute("aria-hidden", "true");
                    }
                    _destroyUI() {
                        this._container && (de.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
                    }
                    enable() {
                        this._setupUI(), this._enabled = !0;
                    }
                    disable() {
                        this._enabled = !1, this._destroyUI();
                    }
                    isEnabled() {
                        return this._enabled;
                    }
                    isBypassed(e) {
                        return e[this._bypassKey];
                    }
                    notifyGestureBlocked(e, i) {
                        this._enabled && (this._map.fire(new c.l("cooperativegestureprevented", { gestureType: e, originalEvent: i })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
                            this._container.classList.remove("maplibregl-show");
                        }, 100));
                    }
                }
                const Un = (h) => h.zoom || h.drag || h.roll || h.pitch || h.rotate;
                class wh extends c.l {
                }
                function Ws(h) {
                    return h.panDelta && h.panDelta.mag() || h.zoomDelta || h.bearingDelta || h.pitchDelta || h.rollDelta;
                }
                class Sh {
                    constructor(e, i) {
                        this.handleWindowEvent = (o) => {
                            this.handleEvent(o, `${o.type}Window`);
                        }, this.handleEvent = (o, u) => {
                            if (o.type === "blur") return void this.stop(!0);
                            this._updatingCamera = !0;
                            const f = o.type === "renderFrame" ? void 0 : o, g = { needsRenderFrame: !1 }, y = {}, x = {};
                            for (const { handlerName: T, handler: z, allowed: R } of this._handlers) {
                                if (!z.isEnabled()) continue;
                                let V;
                                if (this._blockedByActive(x, R, T)) z.reset();
                                else if (z[u || o.type]) {
                                    if (c.cg(o, u || o.type)) {
                                        const U = de.mousePos(this._map.getCanvas(), o);
                                        V = z[u || o.type](o, U);
                                    } else if (c.ch(o, u || o.type)) {
                                        const U = this._getMapTouches(o.touches), Z = de.touchPos(this._map.getCanvas(), U);
                                        V = z[u || o.type](o, Z, U);
                                    } else c.ci(u || o.type) || (V = z[u || o.type](o));
                                    this.mergeHandlerResult(g, y, V, T, f), V && V.needsRenderFrame && this._triggerRenderFrame();
                                }
                                (V || z.isActive()) && (x[T] = z);
                            }
                            const w = {};
                            for (const T in this._previousActiveHandlers) x[T] || (w[T] = f);
                            this._previousActiveHandlers = x, (Object.keys(w).length || Ws(g)) && (this._changes.push([g, y, w]), this._triggerRenderFrame()), (Object.keys(x).length || Ws(g)) && this._map._stop(!0), this._updatingCamera = !1;
                            const { cameraAnimation: P } = g;
                            P && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], P(this._map));
                        }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new fc(e), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i);
                        const s = this._el;
                        this._listeners = [[s, "touchstart", { passive: !0 }], [s, "touchmove", { passive: !1 }], [s, "touchend", void 0], [s, "touchcancel", void 0], [s, "mousedown", void 0], [s, "mousemove", void 0], [s, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [s, "mouseover", void 0], [s, "mouseout", void 0], [s, "dblclick", void 0], [s, "click", void 0], [s, "keydown", { capture: !1 }], [s, "keyup", void 0], [s, "wheel", { passive: !1 }], [s, "contextmenu", void 0], [window, "blur", void 0]];
                        for (const [o, u, f] of this._listeners) de.addEventListener(o, u, o === document ? this.handleWindowEvent : this.handleEvent, f);
                    }
                    destroy() {
                        for (const [e, i, s] of this._listeners) de.removeEventListener(e, i, e === document ? this.handleWindowEvent : this.handleEvent, s);
                    }
                    _addDefaultHandlers(e) {
                        const i = this._map, s = i.getCanvasContainer();
                        this._add("mapEvent", new mc(i, e));
                        const o = i.boxZoom = new qo(i, e);
                        this._add("boxZoom", o), e.interactive && e.boxZoom && o.enable();
                        const u = i.cooperativeGestures = new Hs(i, e.cooperativeGestures);
                        this._add("cooperativeGestures", u), e.cooperativeGestures && u.enable();
                        const f = new yc(i), g = new bh(i);
                        i.doubleClickZoom = new qs(g, f), this._add("tapZoom", f), this._add("clickZoom", g), e.interactive && e.doubleClickZoom && i.doubleClickZoom.enable();
                        const y = new Ko();
                        this._add("tapDragZoom", y);
                        const x = i.touchPitch = new Gs(i);
                        this._add("touchPitch", x), e.interactive && e.touchPitch && i.touchPitch.enable(e.touchPitch);
                        const w = () => i.project(i.getCenter()), P = function ({ enable: Y, clickTolerance: ee, aroundCenter: ae = !0, minPixelCenterThreshold: te = 100, rotateDegreesPerPixelMoved: he = 0.8 }, be) {
                            const ge = new Wa({ checkCorrectEvent: (_e) => de.mouseButton(_e) === 0 && _e.ctrlKey || de.mouseButton(_e) === 2 && !_e.ctrlKey });
                            return new yi({
                                clickTolerance: ee, move: (_e, ye) => {
                                    const Ee = be();
                                    if (ae && Math.abs(Ee.y - _e.y) > te) return { bearingDelta: c.ce(new c.P(_e.x, ye.y), ye, Ee) };
                                    let ze = (ye.x - _e.x) * he;
                                    return ae && ye.y < Ee.y && (ze = -ze), { bearingDelta: ze };
                                }, moveStateManager: ge, enable: Y, assignEvents: Us
                            });
                        }(e, w), T = function ({ enable: Y, clickTolerance: ee, pitchDegreesPerPixelMoved: ae = -0.5 }) {
                            const te = new Wa({ checkCorrectEvent: (he) => de.mouseButton(he) === 0 && he.ctrlKey || de.mouseButton(he) === 2 });
                            return new yi({ clickTolerance: ee, move: (he, be) => ({ pitchDelta: (be.y - he.y) * ae }), moveStateManager: te, enable: Y, assignEvents: Us });
                        }(e), z = function ({ enable: Y, clickTolerance: ee, rollDegreesPerPixelMoved: ae = 0.3 }, te) {
                            const he = new Wa({ checkCorrectEvent: (be) => de.mouseButton(be) === 2 && be.ctrlKey });
                            return new yi({
                                clickTolerance: ee, move: (be, ge) => {
                                    const _e = te();
                                    let ye = (ge.x - be.x) * ae;
                                    return ge.y < _e.y && (ye = -ye), { rollDelta: ye };
                                }, moveStateManager: he, enable: Y, assignEvents: Us
                            });
                        }(e, w);
                        i.dragRotate = new bc(e, P, T, z), this._add("mouseRotate", P, ["mousePitch"]), this._add("mousePitch", T, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", z, ["mousePitch"]), e.interactive && e.dragRotate && i.dragRotate.enable();
                        const R = function ({ enable: Y, clickTolerance: ee }) {
                            const ae = new Wa({ checkCorrectEvent: (te) => de.mouseButton(te) === 0 && !te.ctrlKey });
                            return new yi({ clickTolerance: ee, move: (te, he) => ({ around: he, panDelta: he.sub(te) }), activateOnStart: !0, moveStateManager: ae, enable: Y, assignEvents: Us });
                        }(e), V = new xh(e, i);
                        i.dragPan = new xc(s, R, V), this._add("mousePan", R), this._add("touchPan", V, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && i.dragPan.enable(e.dragPan);
                        const U = new Le(), Z = new Ka();
                        i.touchZoomRotate = new Yo(s, Z, U, y), this._add("touchRotate", U, ["touchPan", "touchZoom"]), this._add("touchZoom", Z, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && i.touchZoomRotate.enable(e.touchZoomRotate);
                        const q = i.scrollZoom = new rt(i, () => this._triggerRenderFrame());
                        this._add("scrollZoom", q, ["mousePan"]), e.interactive && e.scrollZoom && i.scrollZoom.enable(e.scrollZoom);
                        const J = i.keyboard = new Ya(i);
                        this._add("keyboard", J), e.interactive && e.keyboard && i.keyboard.enable(), this._add("blockableMapEvent", new gc(i));
                    }
                    _add(e, i, s) {
                        this._handlers.push({ handlerName: e, handler: i, allowed: s }), this._handlersById[e] = i;
                    }
                    stop(e) {
                        if (!this._updatingCamera) {
                            for (const { handler: i } of this._handlers) i.reset();
                            this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
                        }
                    }
                    isActive() {
                        for (const { handler: e } of this._handlers) if (e.isActive()) return !0;
                        return !1;
                    }
                    isZooming() {
                        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
                    }
                    isRotating() {
                        return !!this._eventsInProgress.rotate;
                    }
                    isMoving() {
                        return !!Un(this._eventsInProgress) || this.isZooming();
                    }
                    _blockedByActive(e, i, s) {
                        for (const o in e) if (o !== s && (!i || i.indexOf(o) < 0)) return !0;
                        return !1;
                    }
                    _getMapTouches(e) {
                        const i = [];
                        for (const s of e) this._el.contains(s.target) && i.push(s);
                        return i;
                    }
                    mergeHandlerResult(e, i, s, o, u) {
                        if (!s) return;
                        c.e(e, s);
                        const f = { handlerName: o, originalEvent: s.originalEvent || u };
                        s.zoomDelta !== void 0 && (i.zoom = f), s.panDelta !== void 0 && (i.drag = f), s.rollDelta !== void 0 && (i.roll = f), s.pitchDelta !== void 0 && (i.pitch = f), s.bearingDelta !== void 0 && (i.rotate = f);
                    }
                    _applyChanges() {
                        const e = {}, i = {}, s = {};
                        for (const [o, u, f] of this._changes) o.panDelta && (e.panDelta = (e.panDelta || new c.P(0, 0))._add(o.panDelta)), o.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + o.zoomDelta), o.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + o.bearingDelta), o.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + o.pitchDelta), o.rollDelta && (e.rollDelta = (e.rollDelta || 0) + o.rollDelta), o.around !== void 0 && (e.around = o.around), o.pinchAround !== void 0 && (e.pinchAround = o.pinchAround), o.noInertia && (e.noInertia = o.noInertia), c.e(i, u), c.e(s, f);
                        this._updateMapTransform(e, i, s), this._changes = [];
                    }
                    _updateMapTransform(e, i, s) {
                        const o = this._map, u = o._getTransformForUpdate(), f = o.terrain;
                        if (!(Ws(e) || f && this._terrainMovement)) return this._fireEvents(i, s, !0);
                        o._stop(!0);
                        let { panDelta: g, zoomDelta: y, bearingDelta: x, pitchDelta: w, rollDelta: P, around: T, pinchAround: z } = e;
                        z !== void 0 && (T = z), T = T || o.transform.centerPoint, f && !u.isPointOnMapSurface(T) && (T = u.centerPoint);
                        const R = { panDelta: g, zoomDelta: y, rollDelta: P, pitchDelta: w, bearingDelta: x, around: T };
                        this._map.cameraHelper.useGlobeControls && !u.isPointOnMapSurface(T) && (T = u.centerPoint);
                        const V = T.distSqr(u.centerPoint) < 0.01 ? u.center : u.screenPointToLocation(g ? T.sub(g) : T);
                        f ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(R, u), this._terrainMovement || !i.drag && !i.zoom ? i.drag && this._terrainMovement ? u.setCenter(u.screenPointToLocation(u.centerPoint.sub(g))) : this._map.cameraHelper.handleMapControlsPan(R, u, V) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan(R, u, V))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(R, u), this._map.cameraHelper.handleMapControlsPan(R, u, V)), o._applyUpdatedTransform(u), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(i, s, !0);
                    }
                    _fireEvents(e, i, s) {
                        const o = Un(this._eventsInProgress), u = Un(e), f = {};
                        for (const P in e) {
                            const { originalEvent: T } = e[P];
                            this._eventsInProgress[P] || (f[`${P}start`] = T), this._eventsInProgress[P] = e[P];
                        }
                        !o && u && this._fireEvent("movestart", u.originalEvent);
                        for (const P in f) this._fireEvent(P, f[P]);
                        u && this._fireEvent("move", u.originalEvent);
                        for (const P in e) {
                            const { originalEvent: T } = e[P];
                            this._fireEvent(P, T);
                        }
                        const g = {};
                        let y;
                        for (const P in this._eventsInProgress) {
                            const { handlerName: T, originalEvent: z } = this._eventsInProgress[P];
                            this._handlersById[T].isActive() || (delete this._eventsInProgress[P], y = i[T] || z, g[`${P}end`] = y);
                        }
                        for (const P in g) this._fireEvent(P, g[P]);
                        const x = Un(this._eventsInProgress), w = (o || u) && !x;
                        if (w && this._terrainMovement) {
                            this._map._elevationFreeze = !1, this._terrainMovement = !1;
                            const P = this._map._getTransformForUpdate();
                            this._map.getCenterClampedToGround() && P.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(P);
                        }
                        if (s && w) {
                            this._updatingCamera = !0;
                            const P = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), T = (z) => z !== 0 && -this._bearingSnap < z && z < this._bearingSnap;
                            !P || !P.essential && Ue.prefersReducedMotion ? (this._map.fire(new c.l("moveend", { originalEvent: y })), T(this._map.getBearing()) && this._map.resetNorth()) : (T(P.bearing || this._map.getBearing()) && (P.bearing = 0), P.freezeElevation = !0, this._map.easeTo(P, { originalEvent: y })), this._updatingCamera = !1;
                        }
                    }
                    _fireEvent(e, i) {
                        this._map.fire(new c.l(e, i ? { originalEvent: i } : {}));
                    }
                    _requestFrame() {
                        return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e) => {
                            delete this._frameId, this.handleEvent(new wh("renderFrame", { timeStamp: e })), this._applyChanges();
                        });
                    }
                    _triggerRenderFrame() {
                        this._frameId === void 0 && (this._frameId = this._requestFrame());
                    }
                }
                class Th extends c.E {
                    constructor(e, i, s) {
                        super(), this._renderFrameCallback = () => {
                            const o = Math.min((Ue.now() - this._easeStart) / this._easeOptions.duration, 1);
                            this._onEaseFrame(this._easeOptions.easing(o)), o < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
                        }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = s.bearingSnap, this.cameraHelper = i, this.on("moveend", () => {
                            delete this._requestedCameraState;
                        });
                    }
                    migrateProjection(e, i) {
                        e.apply(this.transform), this.transform = e, this.cameraHelper = i;
                    }
                    getCenter() {
                        return new c.Q(this.transform.center.lng, this.transform.center.lat);
                    }
                    setCenter(e, i) {
                        return this.jumpTo({ center: e }, i);
                    }
                    getCenterElevation() {
                        return this.transform.elevation;
                    }
                    setCenterElevation(e, i) {
                        return this.jumpTo({ elevation: e }, i), this;
                    }
                    getCenterClampedToGround() {
                        return this._centerClampedToGround;
                    }
                    setCenterClampedToGround(e) {
                        this._centerClampedToGround = e;
                    }
                    panBy(e, i, s) {
                        return e = c.P.convert(e).mult(-1), this.panTo(this.transform.center, c.e({ offset: e }, i), s);
                    }
                    panTo(e, i, s) {
                        return this.easeTo(c.e({ center: e }, i), s);
                    }
                    getZoom() {
                        return this.transform.zoom;
                    }
                    setZoom(e, i) {
                        return this.jumpTo({ zoom: e }, i), this;
                    }
                    zoomTo(e, i, s) {
                        return this.easeTo(c.e({ zoom: e }, i), s);
                    }
                    zoomIn(e, i) {
                        return this.zoomTo(this.getZoom() + 1, e, i), this;
                    }
                    zoomOut(e, i) {
                        return this.zoomTo(this.getZoom() - 1, e, i), this;
                    }
                    getVerticalFieldOfView() {
                        return this.transform.fov;
                    }
                    setVerticalFieldOfView(e, i) {
                        return e != this.transform.fov && (this.transform.setFov(e), this.fire(new c.l("movestart", i)).fire(new c.l("move", i)).fire(new c.l("moveend", i))), this;
                    }
                    getBearing() {
                        return this.transform.bearing;
                    }
                    setBearing(e, i) {
                        return this.jumpTo({ bearing: e }, i), this;
                    }
                    getPadding() {
                        return this.transform.padding;
                    }
                    setPadding(e, i) {
                        return this.jumpTo({ padding: e }, i), this;
                    }
                    rotateTo(e, i, s) {
                        return this.easeTo(c.e({ bearing: e }, i), s);
                    }
                    resetNorth(e, i) {
                        return this.rotateTo(0, c.e({ duration: 1e3 }, e), i), this;
                    }
                    resetNorthPitch(e, i) {
                        return this.easeTo(c.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e), i), this;
                    }
                    snapToNorth(e, i) {
                        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, i) : this;
                    }
                    getPitch() {
                        return this.transform.pitch;
                    }
                    setPitch(e, i) {
                        return this.jumpTo({ pitch: e }, i), this;
                    }
                    getRoll() {
                        return this.transform.roll;
                    }
                    setRoll(e, i) {
                        return this.jumpTo({ roll: e }, i), this;
                    }
                    cameraForBounds(e, i) {
                        e = bt.convert(e).adjustAntiMeridian();
                        const s = i && i.bearing || 0;
                        return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), s, i);
                    }
                    _cameraForBoxAndBearing(e, i, s, o) {
                        const u = { top: 0, bottom: 0, right: 0, left: 0 };
                        if (typeof (o = c.e({ padding: u, offset: [0, 0], maxZoom: this.transform.maxZoom }, o)).padding == "number") {
                            const x = o.padding;
                            o.padding = { top: x, bottom: x, right: x, left: x };
                        }
                        const f = c.e(u, o.padding);
                        o.padding = f;
                        const g = this.transform, y = new bt(e, i);
                        return this.cameraHelper.cameraForBoxAndBearing(o, f, y, s, g);
                    }
                    fitBounds(e, i, s) {
                        return this._fitInternal(this.cameraForBounds(e, i), i, s);
                    }
                    fitScreenCoordinates(e, i, s, o, u) {
                        return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(c.P.convert(e)), this.transform.screenPointToLocation(c.P.convert(i)), s, o), o, u);
                    }
                    _fitInternal(e, i, s) {
                        return e ? (delete (i = c.e(e, i)).padding, i.linear ? this.easeTo(i, s) : this.flyTo(i, s)) : this;
                    }
                    jumpTo(e, i) {
                        this.stop();
                        const s = this._getTransformForUpdate();
                        let o = !1, u = !1, f = !1;
                        const g = s.zoom;
                        this.cameraHelper.handleJumpToCenterZoom(s, e);
                        const y = s.zoom !== g;
                        return "elevation" in e && s.elevation !== +e.elevation && s.setElevation(+e.elevation), "bearing" in e && s.bearing !== +e.bearing && (o = !0, s.setBearing(+e.bearing)), "pitch" in e && s.pitch !== +e.pitch && (u = !0, s.setPitch(+e.pitch)), "roll" in e && s.roll !== +e.roll && (f = !0, s.setRoll(+e.roll)), e.padding == null || s.isPaddingEqual(e.padding) || s.setPadding(e.padding), this._applyUpdatedTransform(s), this.fire(new c.l("movestart", i)).fire(new c.l("move", i)), y && this.fire(new c.l("zoomstart", i)).fire(new c.l("zoom", i)).fire(new c.l("zoomend", i)), o && this.fire(new c.l("rotatestart", i)).fire(new c.l("rotate", i)).fire(new c.l("rotateend", i)), u && this.fire(new c.l("pitchstart", i)).fire(new c.l("pitch", i)).fire(new c.l("pitchend", i)), f && this.fire(new c.l("rollstart", i)).fire(new c.l("roll", i)).fire(new c.l("rollend", i)), this.fire(new c.l("moveend", i));
                    }
                    calculateCameraOptionsFromTo(e, i, s, o = 0) {
                        const u = c.$.fromLngLat(e, i), f = c.$.fromLngLat(s, o), g = f.x - u.x, y = f.y - u.y, x = f.z - u.z, w = Math.hypot(g, y, x);
                        if (w === 0) throw new Error("Can't calculate camera options with same From and To");
                        const P = Math.hypot(g, y), T = c.ah(this.transform.cameraToCenterDistance / w / this.transform.tileSize), z = 180 * Math.atan2(g, -y) / Math.PI;
                        let R = 180 * Math.acos(P / w) / Math.PI;
                        return R = x < 0 ? 90 - R : 90 + R, { center: f.toLngLat(), elevation: o, zoom: T, pitch: R, bearing: z };
                    }
                    calculateCameraOptionsFromCameraLngLatAltRotation(e, i, s, o, u) {
                        const f = this.transform.calculateCenterFromCameraLngLatAlt(e, i, s, o);
                        return { center: f.center, elevation: f.elevation, zoom: f.zoom, bearing: s, pitch: o, roll: u };
                    }
                    easeTo(e, i) {
                        this._stop(!1, e.easeId), ((e = c.e({ offset: [0, 0], duration: 500, easing: c.cf }, e)).animate === !1 || !e.essential && Ue.prefersReducedMotion) && (e.duration = 0);
                        const s = this._getTransformForUpdate(), o = this.getBearing(), u = s.pitch, f = s.roll, g = "bearing" in e ? this._normalizeBearing(e.bearing, o) : o, y = "pitch" in e ? +e.pitch : u, x = "roll" in e ? this._normalizeBearing(e.roll, f) : f, w = "padding" in e ? e.padding : s.padding, P = c.P.convert(e.offset);
                        let T, z;
                        e.around && (T = c.Q.convert(e.around), z = s.locationToScreenPoint(T));
                        const R = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, V = this.cameraHelper.handleEaseTo(s, { bearing: g, pitch: y, roll: x, padding: w, around: T, aroundPoint: z, offsetAsPoint: P, offset: e.offset, zoom: e.zoom, center: e.center });
                        return this._rotating = this._rotating || o !== g, this._pitching = this._pitching || y !== u, this._rolling = this._rolling || x !== f, this._padding = !s.isPaddingEqual(w), this._zooming = this._zooming || V.isZooming, this._easeId = e.easeId, this._prepareEase(i, e.noMoveStart, R), this.terrain && this._prepareElevation(V.elevationCenter), this._ease((U) => {
                            V.easeFunc(U), this.terrain && !e.freezeElevation && this._updateElevation(U), this._applyUpdatedTransform(s), this._fireMoveEvents(i);
                        }, (U) => {
                            this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i, U);
                        }, e), this;
                    }
                    _prepareEase(e, i, s = {}) {
                        this._moving = !0, i || s.moving || this.fire(new c.l("movestart", e)), this._zooming && !s.zooming && this.fire(new c.l("zoomstart", e)), this._rotating && !s.rotating && this.fire(new c.l("rotatestart", e)), this._pitching && !s.pitching && this.fire(new c.l("pitchstart", e)), this._rolling && !s.rolling && this.fire(new c.l("rollstart", e));
                    }
                    _prepareElevation(e) {
                        this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0;
                    }
                    _updateElevation(e) {
                        this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
                        const i = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
                        if (e < 1 && i !== this._elevationTarget) {
                            const s = this._elevationTarget - this._elevationStart;
                            this._elevationStart += e * (s - (i - (s * e + this._elevationStart)) / (1 - e)), this._elevationTarget = i;
                        }
                        this.transform.setElevation(c.B.number(this._elevationStart, this._elevationTarget, e));
                    }
                    _finalizeElevation() {
                        this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
                    }
                    _getTransformForUpdate() {
                        return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
                    }
                    _elevateCameraIfInsideTerrain(e) {
                        if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
                        const i = e.getCameraLngLat(), s = e.getCameraAltitude(), o = this.terrain ? this.terrain.getElevationForLngLatZoom(i, e.zoom) : 0;
                        if (s < o) {
                            const u = this.calculateCameraOptionsFromTo(i, o, e.center, e.elevation);
                            return { pitch: u.pitch, zoom: u.zoom };
                        }
                        return {};
                    }
                    _applyUpdatedTransform(e) {
                        const i = [];
                        if (i.push((o) => this._elevateCameraIfInsideTerrain(o)), this.transformCameraUpdate && i.push((o) => this.transformCameraUpdate(o)), !i.length) return;
                        const s = e.clone();
                        for (const o of i) {
                            const u = s.clone(), { center: f, zoom: g, roll: y, pitch: x, bearing: w, elevation: P } = o(u);
                            f && u.setCenter(f), P !== void 0 && u.setElevation(P), g !== void 0 && u.setZoom(g), y !== void 0 && u.setRoll(y), x !== void 0 && u.setPitch(x), w !== void 0 && u.setBearing(w), s.apply(u);
                        }
                        this.transform.apply(s);
                    }
                    _fireMoveEvents(e) {
                        this.fire(new c.l("move", e)), this._zooming && this.fire(new c.l("zoom", e)), this._rotating && this.fire(new c.l("rotate", e)), this._pitching && this.fire(new c.l("pitch", e)), this._rolling && this.fire(new c.l("roll", e));
                    }
                    _afterEase(e, i) {
                        if (this._easeId && i && this._easeId === i) return;
                        delete this._easeId;
                        const s = this._zooming, o = this._rotating, u = this._pitching, f = this._rolling;
                        this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, s && this.fire(new c.l("zoomend", e)), o && this.fire(new c.l("rotateend", e)), u && this.fire(new c.l("pitchend", e)), f && this.fire(new c.l("rollend", e)), this.fire(new c.l("moveend", e));
                    }
                    flyTo(e, i) {
                        if (!e.essential && Ue.prefersReducedMotion) {
                            const ye = c.O(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
                            return this.jumpTo(ye, i);
                        }
                        this.stop(), e = c.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: c.cf }, e);
                        const s = this._getTransformForUpdate(), o = s.bearing, u = s.pitch, f = s.roll, g = s.padding, y = "bearing" in e ? this._normalizeBearing(e.bearing, o) : o, x = "pitch" in e ? +e.pitch : u, w = "roll" in e ? this._normalizeBearing(e.roll, f) : f, P = "padding" in e ? e.padding : s.padding, T = c.P.convert(e.offset);
                        let z = s.centerPoint.add(T);
                        const R = s.screenPointToLocation(z), V = this.cameraHelper.handleFlyTo(s, { bearing: y, pitch: x, roll: w, padding: P, locationAtOffset: R, offsetAsPoint: T, center: e.center, minZoom: e.minZoom, zoom: e.zoom });
                        let U = e.curve;
                        const Z = Math.max(s.width, s.height), q = Z / V.scaleOfZoom, J = V.pixelPathLength;
                        typeof V.scaleOfMinZoom == "number" && (U = Math.sqrt(Z / V.scaleOfMinZoom / J * 2));
                        const Y = U * U;
                        function ee(ye) {
                            const Ee = (q * q - Z * Z + (ye ? -1 : 1) * Y * Y * J * J) / (2 * (ye ? q : Z) * Y * J);
                            return Math.log(Math.sqrt(Ee * Ee + 1) - Ee);
                        }
                        function ae(ye) {
                            return (Math.exp(ye) - Math.exp(-ye)) / 2;
                        }
                        function te(ye) {
                            return (Math.exp(ye) + Math.exp(-ye)) / 2;
                        }
                        const he = ee(!1);
                        let be = function (ye) {
                            return te(he) / te(he + U * ye);
                        }, ge = function (ye) {
                            return Z * ((te(he) * (ae(Ee = he + U * ye) / te(Ee)) - ae(he)) / Y) / J;
                            var Ee;
                        }, _e = (ee(!0) - he) / U;
                        if (Math.abs(J) < 2e-6 || !isFinite(_e)) {
                            if (Math.abs(Z - q) < 1e-6) return this.easeTo(e, i);
                            const ye = q < Z ? -1 : 1;
                            _e = Math.abs(Math.log(q / Z)) / U, ge = () => 0, be = (Ee) => Math.exp(ye * U * Ee);
                        }
                        return e.duration = "duration" in e ? +e.duration : 1e3 * _e / ("screenSpeed" in e ? +e.screenSpeed / U : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = o !== y, this._pitching = x !== u, this._rolling = w !== f, this._padding = !s.isPaddingEqual(P), this._prepareEase(i, !1), this.terrain && this._prepareElevation(V.targetCenter), this._ease((ye) => {
                            const Ee = ye * _e, ze = 1 / be(Ee), Ce = ge(Ee);
                            this._rotating && s.setBearing(c.B.number(o, y, ye)), this._pitching && s.setPitch(c.B.number(u, x, ye)), this._rolling && s.setRoll(c.B.number(f, w, ye)), this._padding && (s.interpolatePadding(g, P, ye), z = s.centerPoint.add(T)), V.easeFunc(ye, ze, Ce, z), this.terrain && !e.freezeElevation && this._updateElevation(ye), this._applyUpdatedTransform(s), this._fireMoveEvents(i);
                        }, () => {
                            this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i);
                        }, e), this;
                    }
                    isEasing() {
                        return !!this._easeFrameId;
                    }
                    stop() {
                        return this._stop();
                    }
                    _stop(e, i) {
                        var s;
                        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
                            const o = this._onEaseEnd;
                            delete this._onEaseEnd, o.call(this, i);
                        }
                        return e || (s = this.handlers) === null || s === void 0 || s.stop(!1), this;
                    }
                    _ease(e, i, s) {
                        s.animate === !1 || s.duration === 0 ? (e(1), i()) : (this._easeStart = Ue.now(), this._easeOptions = s, this._onEaseFrame = e, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
                    }
                    _normalizeBearing(e, i) {
                        e = c.aL(e, -180, 180);
                        const s = Math.abs(e - i);
                        return Math.abs(e - 360 - i) < s && (e -= 360), Math.abs(e + 360 - i) < s && (e += 360), e;
                    }
                    queryTerrainElevation(e) {
                        return this.terrain ? this.terrain.getElevationForLngLatZoom(c.Q.convert(e), this.transform.tileZoom) : null;
                    }
                }
                const Ar = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
                class Tt {
                    constructor(e = Ar) {
                        this._toggleAttribution = () => {
                            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
                        }, this._updateData = (i) => {
                            !i || i.sourceDataType !== "metadata" && i.sourceDataType !== "visibility" && i.dataType !== "style" && i.type !== "terrain" || this._updateAttributions();
                        }, this._updateCompact = () => {
                            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
                        }, this._updateCompactMinimize = () => {
                            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
                        }, this.options = e;
                    }
                    getDefaultPosition() {
                        return "bottom-right";
                    }
                    onAdd(e) {
                        return this._map = e, this._compact = this.options.compact, this._container = de.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = de.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = de.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
                    }
                    onRemove() {
                        de.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
                    }
                    _setElementTitle(e, i) {
                        const s = this._map._getUIString(`AttributionControl.${i}`);
                        e.title = s, e.setAttribute("aria-label", s);
                    }
                    _updateAttributions() {
                        if (!this._map.style) return;
                        let e = [];
                        if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((o) => typeof o != "string" ? "" : o)) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
                            const o = this._map.style.stylesheet;
                            this.styleOwner = o.owner, this.styleId = o.id;
                        }
                        const i = this._map.style.sourceCaches;
                        for (const o in i) {
                            const u = i[o];
                            if (u.used || u.usedForTerrain) {
                                const f = u.getSource();
                                f.attribution && e.indexOf(f.attribution) < 0 && e.push(f.attribution);
                            }
                        }
                        e = e.filter((o) => String(o).trim()), e.sort((o, u) => o.length - u.length), e = e.filter((o, u) => {
                            for (let f = u + 1; f < e.length; f++) if (e[f].indexOf(o) >= 0) return !1;
                            return !0;
                        });
                        const s = e.join(" | ");
                        s !== this._attribHTML && (this._attribHTML = s, e.length ? (this._innerContainer.innerHTML = de.sanitize(s), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
                    }
                }
                class Vn {
                    constructor(e = {}) {
                        this._updateCompact = () => {
                            const i = this._container.children;
                            if (i.length) {
                                const s = i[0];
                                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && s.classList.add("maplibregl-compact") : s.classList.remove("maplibregl-compact");
                            }
                        }, this.options = e;
                    }
                    getDefaultPosition() {
                        return "bottom-left";
                    }
                    onAdd(e) {
                        this._map = e, this._compact = this.options && this.options.compact, this._container = de.create("div", "maplibregl-ctrl");
                        const i = de.create("a", "maplibregl-ctrl-logo");
                        return i.target = "_blank", i.rel = "noopener nofollow", i.href = "https://maplibre.org/", i.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), i.setAttribute("rel", "noopener nofollow"), this._container.appendChild(i), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
                    }
                    onRemove() {
                        de.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
                    }
                }
                class Jo {
                    constructor() {
                        this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
                    }
                    add(e) {
                        const i = ++this._id;
                        return this._queue.push({ callback: e, id: i, cancelled: !1 }), i;
                    }
                    remove(e) {
                        const i = this._currentlyRunning, s = i ? this._queue.concat(i) : this._queue;
                        for (const o of s) if (o.id === e) return void (o.cancelled = !0);
                    }
                    run(e = 0) {
                        if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
                        const i = this._currentlyRunning = this._queue;
                        this._queue = [];
                        for (const s of i) if (!s.cancelled && (s.callback(e), this._cleared)) break;
                        this._cleared = !1, this._currentlyRunning = !1;
                    }
                    clear() {
                        this._currentlyRunning && (this._cleared = !0), this._queue = [];
                    }
                }
                var wc = c.aG([{ name: "a_pos3d", type: "Int16", components: 3 }]);
                class Sc extends c.E {
                    constructor(e) {
                        super(), this._lastTilesetChange = Ue.now(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize;
                    }
                    destruct() {
                        this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
                    }
                    update(e, i) {
                        this.sourceCache.update(e, i), this._renderableTilesKeys = [];
                        const s = {};
                        for (const o of ne(e, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: i, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) s[o.key] = !0, this._renderableTilesKeys.push(o.key), this._tiles[o.key] || (o.terrainRttPosMatrix32f = new Float64Array(16), c.bQ(o.terrainRttPosMatrix32f, 0, c.Z, c.Z, 0, 0, 1), this._tiles[o.key] = new Pr(o, this.tileSize), this._lastTilesetChange = Ue.now());
                        for (const o in this._tiles) s[o] || delete this._tiles[o];
                    }
                    freeRtt(e) {
                        for (const i in this._tiles) {
                            const s = this._tiles[i];
                            (!e || s.tileID.equals(e) || s.tileID.isChildOf(e) || e.isChildOf(s.tileID)) && (s.rtt = []);
                        }
                    }
                    getRenderableTiles() {
                        return this._renderableTilesKeys.map((e) => this.getTileByID(e));
                    }
                    getTileByID(e) {
                        return this._tiles[e];
                    }
                    getTerrainCoords(e, i) {
                        return i ? this._getTerrainCoordsForTileRanges(e, i) : this._getTerrainCoordsForRegularTile(e);
                    }
                    _getTerrainCoordsForRegularTile(e) {
                        const i = {};
                        for (const s of this._renderableTilesKeys) {
                            const o = this._tiles[s].tileID, u = e.clone(), f = c.b2();
                            if (o.canonical.equals(e.canonical)) c.bQ(f, 0, c.Z, c.Z, 0, 0, 1);
                            else if (o.canonical.isChildOf(e.canonical)) {
                                const g = o.canonical.z - e.canonical.z, y = o.canonical.x - (o.canonical.x >> g << g), x = o.canonical.y - (o.canonical.y >> g << g), w = c.Z >> g;
                                c.bQ(f, 0, w, w, 0, 0, 1), c.L(f, f, [-y * w, -x * w, 0]);
                            } else {
                                if (!e.canonical.isChildOf(o.canonical)) continue;
                                {
                                    const g = e.canonical.z - o.canonical.z, y = e.canonical.x - (e.canonical.x >> g << g), x = e.canonical.y - (e.canonical.y >> g << g), w = c.Z >> g;
                                    c.bQ(f, 0, c.Z, c.Z, 0, 0, 1), c.L(f, f, [y * w, x * w, 0]), c.M(f, f, [1 / 2 ** g, 1 / 2 ** g, 0]);
                                }
                            }
                            u.terrainRttPosMatrix32f = new Float32Array(f), i[s] = u;
                        }
                        return i;
                    }
                    _getTerrainCoordsForTileRanges(e, i) {
                        const s = {};
                        for (const o of this._renderableTilesKeys) {
                            const u = this._tiles[o].tileID;
                            if (!this._isWithinTileRanges(u, i)) continue;
                            const f = e.clone(), g = c.b2();
                            if (u.canonical.z === e.canonical.z) {
                                const y = e.canonical.x - u.canonical.x, x = e.canonical.y - u.canonical.y;
                                c.bQ(g, 0, c.Z, c.Z, 0, 0, 1), c.L(g, g, [y * c.Z, x * c.Z, 0]);
                            } else if (u.canonical.z > e.canonical.z) {
                                const y = u.canonical.z - e.canonical.z, x = u.canonical.x - (u.canonical.x >> y << y), w = u.canonical.y - (u.canonical.y >> y << y), P = e.canonical.x - (u.canonical.x >> y), T = e.canonical.y - (u.canonical.y >> y), z = c.Z >> y;
                                c.bQ(g, 0, z, z, 0, 0, 1), c.L(g, g, [-x * z + P * c.Z, -w * z + T * c.Z, 0]);
                            } else {
                                const y = e.canonical.z - u.canonical.z, x = e.canonical.x - (e.canonical.x >> y << y), w = e.canonical.y - (e.canonical.y >> y << y), P = (e.canonical.x >> y) - u.canonical.x, T = (e.canonical.y >> y) - u.canonical.y, z = c.Z << y;
                                c.bQ(g, 0, z, z, 0, 0, 1), c.L(g, g, [x * c.Z + P * z, w * c.Z + T * z, 0]);
                            }
                            f.terrainRttPosMatrix32f = new Float32Array(g), s[o] = f;
                        }
                        return s;
                    }
                    getSourceTile(e, i) {
                        const s = this.sourceCache._source;
                        let o = e.overscaledZ - this.deltaZoom;
                        if (o > s.maxzoom && (o = s.maxzoom), o < s.minzoom) return null;
                        this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(o).key);
                        let u = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
                        if ((!u || !u.dem) && i) for (; o >= s.minzoom && (!u || !u.dem);) u = this.sourceCache.getTileByID(e.scaledTo(o--).key);
                        return u;
                    }
                    anyTilesAfterTime(e = Date.now()) {
                        return this._lastTilesetChange >= e;
                    }
                    _isWithinTileRanges(e, i) {
                        return i[e.canonical.z] && e.canonical.x >= i[e.canonical.z].minTileX && e.canonical.x <= i[e.canonical.z].maxTileX && e.canonical.y >= i[e.canonical.z].minTileY && e.canonical.y <= i[e.canonical.z].maxTileY;
                    }
                }
                class Tc {
                    constructor(e, i, s) {
                        this._meshCache = {}, this.painter = e, this.sourceCache = new Sc(i), this.options = s, this.exaggeration = typeof s.exaggeration == "number" ? s.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
                    }
                    getDEMElevation(e, i, s, o = c.Z) {
                        var u;
                        if (!(i >= 0 && i < o && s >= 0 && s < o)) return 0;
                        const f = this.getTerrainData(e), g = (u = f.tile) === null || u === void 0 ? void 0 : u.dem;
                        if (!g) return 0;
                        const y = c.cj([], [i / o * c.Z, s / o * c.Z], f.u_terrain_matrix), x = [y[0] * g.dim, y[1] * g.dim], w = Math.floor(x[0]), P = Math.floor(x[1]), T = x[0] - w, z = x[1] - P;
                        return g.get(w, P) * (1 - T) * (1 - z) + g.get(w + 1, P) * T * (1 - z) + g.get(w, P + 1) * (1 - T) * z + g.get(w + 1, P + 1) * T * z;
                    }
                    getElevationForLngLatZoom(e, i) {
                        if (!c.ck(i, e.wrap())) return 0;
                        const { tileID: s, mercatorX: o, mercatorY: u } = this._getOverscaledTileIDFromLngLatZoom(e, i);
                        return this.getElevation(s, o % c.Z, u % c.Z, c.Z);
                    }
                    getElevation(e, i, s, o = c.Z) {
                        return this.getDEMElevation(e, i, s, o) * this.exaggeration;
                    }
                    getTerrainData(e) {
                        if (!this._emptyDemTexture) {
                            const o = this.painter.context, u = new c.R({ width: 1, height: 1 }, new Uint8Array(4));
                            this._emptyDepthTexture = new Dt(o, u, o.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new Dt(o, new c.R({ width: 1, height: 1 }), o.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(o.gl.NEAREST, o.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = c.ad([]);
                        }
                        const i = this.sourceCache.getSourceTile(e, !0);
                        if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) {
                            const o = this.painter.context;
                            i.demTexture = this.painter.getTileTexture(i.dem.stride), i.demTexture ? i.demTexture.update(i.dem.getPixels(), { premultiply: !1 }) : i.demTexture = new Dt(o, i.dem.getPixels(), o.gl.RGBA, { premultiply: !1 }), i.demTexture.bind(o.gl.NEAREST, o.gl.CLAMP_TO_EDGE), i.needsTerrainPrepare = !1;
                        }
                        const s = i && i + i.tileID.key + e.key;
                        if (s && !this._demMatrixCache[s]) {
                            const o = this.sourceCache.sourceCache._source.maxzoom;
                            let u = e.canonical.z - i.tileID.canonical.z;
                            e.overscaledZ > e.canonical.z && (e.canonical.z >= o ? u = e.canonical.z - o : c.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
                            const f = e.canonical.x - (e.canonical.x >> u << u), g = e.canonical.y - (e.canonical.y >> u << u), y = c.cl(new Float64Array(16), [1 / (c.Z << u), 1 / (c.Z << u), 0]);
                            c.L(y, y, [f * c.Z, g * c.Z, 0]), this._demMatrixCache[e.key] = { matrix: y, coord: e };
                        }
                        return { u_depth: 2, u_terrain: 3, u_terrain_dim: i && i.dem && i.dem.dim || 1, u_terrain_matrix: s ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i && i.dem && i.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i && i.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i };
                    }
                    getFramebuffer(e) {
                        const i = this.painter, s = i.width / devicePixelRatio, o = i.height / devicePixelRatio;
                        return !this._fbo || this._fbo.width === s && this._fbo.height === o || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new Dt(i.context, { width: s, height: o, data: null }, i.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new Dt(i.context, { width: s, height: o, data: null }, i.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = i.context.createFramebuffer(s, o, !0, !1), this._fbo.depthAttachment.set(i.context.createRenderbuffer(i.context.gl.DEPTH_COMPONENT16, s, o))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
                    }
                    getCoordsTexture() {
                        const e = this.painter.context;
                        if (this._coordsTexture) return this._coordsTexture;
                        const i = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
                        for (let u = 0, f = 0; u < this._coordsTextureSize; u++) for (let g = 0; g < this._coordsTextureSize; g++, f += 4) i[f + 0] = 255 & g, i[f + 1] = 255 & u, i[f + 2] = g >> 8 << 4 | u >> 8, i[f + 3] = 0;
                        const s = new c.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i.buffer)), o = new Dt(e, s, e.gl.RGBA, { premultiply: !1 });
                        return o.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = o, o;
                    }
                    pointCoordinate(e) {
                        this.painter.maybeDrawDepthAndCoords(!0);
                        const i = new Uint8Array(4), s = this.painter.context, o = s.gl, u = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), f = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), g = Math.round(this.painter.height / devicePixelRatio);
                        s.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), o.readPixels(u, g - f - 1, 1, 1, o.RGBA, o.UNSIGNED_BYTE, i), s.bindFramebuffer.set(null);
                        const y = i[0] + (i[2] >> 4 << 8), x = i[1] + ((15 & i[2]) << 8), w = this.coordsIndex[255 - i[3]], P = w && this.sourceCache.getTileByID(w);
                        if (!P) return null;
                        const T = this._coordsTextureSize, z = (1 << P.tileID.canonical.z) * T;
                        return new c.$((P.tileID.canonical.x * T + y) / z + P.tileID.wrap, (P.tileID.canonical.y * T + x) / z, this.getElevation(P.tileID, y, x, T));
                    }
                    depthAtPoint(e) {
                        const i = new Uint8Array(4), s = this.painter.context, o = s.gl;
                        return s.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), o.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, o.RGBA, o.UNSIGNED_BYTE, i), s.bindFramebuffer.set(null), (i[0] / 16777216 + i[1] / 65536 + i[2] / 256 + i[3]) / 256;
                    }
                    getTerrainMesh(e) {
                        var i;
                        const s = ((i = this.painter.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0, o = s && e.canonical.y === 0, u = s && e.canonical.y === (1 << e.canonical.z) - 1, f = `m_${o ? "n" : ""}_${u ? "s" : ""}`;
                        if (this._meshCache[f]) return this._meshCache[f];
                        const g = this.painter.context, y = new c.cm(), x = new c.aK(), w = this.meshSize, P = c.Z / w, T = w * w;
                        for (let te = 0; te <= w; te++) for (let he = 0; he <= w; he++) y.emplaceBack(he * P, te * P, 0);
                        for (let te = 0; te < T; te += w + 1) for (let he = 0; he < w; he++) x.emplaceBack(he + te, w + he + te + 1, w + he + te + 2), x.emplaceBack(he + te, w + he + te + 2, he + te + 1);
                        const z = y.length, R = z + (w + 1), V = (w + 1) * w, U = o ? c.b9 : 0, Z = o ? 0 : 1, q = u ? c.ba : c.Z, J = u ? 0 : 1;
                        for (let te = 0; te <= w; te++) y.emplaceBack(te * P, U, Z);
                        for (let te = 0; te <= w; te++) y.emplaceBack(te * P, q, J);
                        for (let te = 0; te < w; te++) x.emplaceBack(V + te, R + te, R + te + 1), x.emplaceBack(V + te, R + te + 1, V + te + 1), x.emplaceBack(0 + te, z + te + 1, z + te), x.emplaceBack(0 + te, 0 + te + 1, z + te + 1);
                        const Y = y.length, ee = Y + 2 * (w + 1);
                        for (const te of [0, 1]) for (let he = 0; he <= w; he++) for (const be of [0, 1]) y.emplaceBack(te * c.Z, he * P, be);
                        for (let te = 0; te < 2 * w; te += 2) x.emplaceBack(Y + te, Y + te + 1, Y + te + 3), x.emplaceBack(Y + te, Y + te + 3, Y + te + 2), x.emplaceBack(ee + te, ee + te + 3, ee + te + 1), x.emplaceBack(ee + te, ee + te + 2, ee + te + 3);
                        const ae = new Ra(g.createVertexBuffer(y, wc.members), g.createIndexBuffer(x), c.aJ.simpleSegment(0, 0, y.length, x.length));
                        return this._meshCache[f] = ae, ae;
                    }
                    getMeshFrameDelta(e) {
                        return 2 * Math.PI * c.bu / Math.pow(2, Math.max(e, 0)) / 5;
                    }
                    getMinTileElevationForLngLatZoom(e, i) {
                        var s;
                        const { tileID: o } = this._getOverscaledTileIDFromLngLatZoom(e, i);
                        return (s = this.getMinMaxElevation(o).minElevation) !== null && s !== void 0 ? s : 0;
                    }
                    getMinMaxElevation(e) {
                        const i = this.getTerrainData(e).tile, s = { minElevation: null, maxElevation: null };
                        return i && i.dem && (s.minElevation = i.dem.min * this.exaggeration, s.maxElevation = i.dem.max * this.exaggeration), s;
                    }
                    _getOverscaledTileIDFromLngLatZoom(e, i) {
                        const s = c.$.fromLngLat(e.wrap()), o = (1 << i) * c.Z, u = s.x * o, f = s.y * o, g = Math.floor(u / c.Z), y = Math.floor(f / c.Z);
                        return { tileID: new c.Y(i, 0, i, g, y), mercatorX: u, mercatorY: f };
                    }
                }
                class Ph {
                    constructor(e, i, s) {
                        this._context = e, this._size = i, this._tileSize = s, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
                    }
                    destruct() {
                        for (const e of this._objects) e.texture.destroy(), e.fbo.destroy();
                    }
                    _createObject(e) {
                        const i = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), s = new Dt(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
                        return s.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), i.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), i.colorAttachment.set(s.texture), { id: e, fbo: i, texture: s, stamp: -1, inUse: !1 };
                    }
                    getObjectForId(e) {
                        return this._objects[e];
                    }
                    useObject(e) {
                        e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((i) => e.id !== i), this._recentlyUsed.push(e.id);
                    }
                    stampObject(e) {
                        e.stamp = ++this._stamp;
                    }
                    getOrCreateFreeObject() {
                        for (const i of this._recentlyUsed) if (!this._objects[i].inUse) return this._objects[i];
                        if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
                        const e = this._createObject(this._objects.length);
                        return this._objects.push(e), e;
                    }
                    freeObject(e) {
                        e.inUse = !1;
                    }
                    freeAllObjects() {
                        for (const e of this._objects) this.freeObject(e);
                    }
                    isFull() {
                        return !(this._objects.length < this._size) && this._objects.some((e) => !e.inUse) === !1;
                    }
                }
                const Mi = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 };
                class Xs {
                    constructor(e, i) {
                        this.painter = e, this.terrain = i, this.pool = new Ph(e.context, 30, i.sourceCache.tileSize * i.qualityFactor);
                    }
                    destruct() {
                        this.pool.destruct();
                    }
                    getTexture(e) {
                        return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
                    }
                    prepareForRender(e, i) {
                        this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((s) => !e._layers[s].isHidden(i)), this._coordsAscending = {};
                        for (const s in e.sourceCaches) {
                            this._coordsAscending[s] = {};
                            const o = e.sourceCaches[s].getVisibleCoordinates(), u = e.sourceCaches[s].getSource(), f = u instanceof Fi ? u.terrainTileRanges : null;
                            for (const g of o) {
                                const y = this.terrain.sourceCache.getTerrainCoords(g, f);
                                for (const x in y) this._coordsAscending[s][x] || (this._coordsAscending[s][x] = []), this._coordsAscending[s][x].push(y[x]);
                            }
                        }
                        this._coordsAscendingStr = {};
                        for (const s of e._order) {
                            const o = e._layers[s], u = o.source;
                            if (Mi[o.type] && !this._coordsAscendingStr[u]) {
                                this._coordsAscendingStr[u] = {};
                                for (const f in this._coordsAscending[u]) this._coordsAscendingStr[u][f] = this._coordsAscending[u][f].map((g) => g.key).sort().join();
                            }
                        }
                        for (const s of this._renderableTiles) for (const o in this._coordsAscendingStr) {
                            const u = this._coordsAscendingStr[o][s.tileID.key];
                            u && u !== s.rttCoords[o] && (s.rtt = []);
                        }
                    }
                    renderLayer(e, i) {
                        if (e.isHidden(this.painter.transform.zoom)) return !1;
                        const s = Object.assign(Object.assign({}, i), { isRenderingToTexture: !0 }), o = e.type, u = this.painter, f = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
                        if (Mi[o] && (this._prevType && Mi[this._prevType] || this._stacks.push([]), this._prevType = o, this._stacks[this._stacks.length - 1].push(e.id), !f)) return !0;
                        if (Mi[this._prevType] || Mi[o] && f) {
                            this._prevType = o;
                            const g = this._stacks.length - 1, y = this._stacks[g] || [];
                            for (const x of this._renderableTiles) {
                                if (this.pool.isFull() && (Vr(this.painter, this.terrain, this._rttTiles, s), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(x), x.rtt[g]) {
                                    const P = this.pool.getObjectForId(x.rtt[g].id);
                                    if (P.stamp === x.rtt[g].stamp) {
                                        this.pool.useObject(P);
                                        continue;
                                    }
                                }
                                const w = this.pool.getOrCreateFreeObject();
                                this.pool.useObject(w), this.pool.stampObject(w), x.rtt[g] = { id: w.id, stamp: w.stamp }, u.context.bindFramebuffer.set(w.fbo.framebuffer), u.context.clear({ color: c.b7.transparent, stencil: 0 }), u.currentStencilSource = void 0;
                                for (let P = 0; P < y.length; P++) {
                                    const T = u.style._layers[y[P]], z = T.source ? this._coordsAscending[T.source][x.tileID.key] : [x.tileID];
                                    u.context.viewport.set([0, 0, w.fbo.width, w.fbo.height]), u._renderTileClippingMasks(T, z, !0), u.renderLayer(u, u.style.sourceCaches[T.source], T, z, s), T.source && (x.rttCoords[T.source] = this._coordsAscendingStr[T.source][x.tileID.key]);
                                }
                            }
                            return Vr(this.painter, this.terrain, this._rttTiles, s), this._rttTiles = [], this.pool.freeAllObjects(), Mi[o];
                        }
                        return !1;
                    }
                }
                const je = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use âŒ˜ + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, He = Fe, Zn = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: Ar, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: c.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0 }, Qo = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 };
                class el {
                    constructor(e, i, s = !1) {
                        this.mousedown = (u) => {
                            this.startMove(u, de.mousePos(this.element, u)), de.addEventListener(window, "mousemove", this.mousemove), de.addEventListener(window, "mouseup", this.mouseup);
                        }, this.mousemove = (u) => {
                            this.move(u, de.mousePos(this.element, u));
                        }, this.mouseup = (u) => {
                            this._rotatePitchHanlder.dragEnd(u), this.offTemp();
                        }, this.touchstart = (u) => {
                            u.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = de.touchPos(this.element, u.targetTouches)[0], this.startMove(u, this._startPos), de.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), de.addEventListener(window, "touchend", this.touchend));
                        }, this.touchmove = (u) => {
                            u.targetTouches.length !== 1 ? this.reset() : (this._lastPos = de.touchPos(this.element, u.targetTouches)[0], this.move(u, this._lastPos));
                        }, this.touchend = (u) => {
                            u.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
                        }, this.reset = () => {
                            this._rotatePitchHanlder.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
                        }, this._clickTolerance = 10, this.element = i;
                        const o = new Xa();
                        this._rotatePitchHanlder = new yi({
                            clickTolerance: 3, move: (u, f) => {
                                const g = i.getBoundingClientRect(), y = new c.P((g.bottom - g.top) / 2, (g.right - g.left) / 2);
                                return { bearingDelta: c.ce(new c.P(u.x, f.y), f, y), pitchDelta: s ? -0.5 * (f.y - u.y) : void 0 };
                            }, moveStateManager: o, enable: !0, assignEvents: () => {
                            }
                        }), this.map = e, de.addEventListener(i, "mousedown", this.mousedown), de.addEventListener(i, "touchstart", this.touchstart, { passive: !1 }), de.addEventListener(i, "touchcancel", this.reset);
                    }
                    startMove(e, i) {
                        this._rotatePitchHanlder.dragStart(e, i), de.disableDrag();
                    }
                    move(e, i) {
                        const s = this.map, { bearingDelta: o, pitchDelta: u } = this._rotatePitchHanlder.dragMove(e, i) || {};
                        o && s.setBearing(s.getBearing() + o), u && s.setPitch(s.getPitch() + u);
                    }
                    off() {
                        const e = this.element;
                        de.removeEventListener(e, "mousedown", this.mousedown), de.removeEventListener(e, "touchstart", this.touchstart, { passive: !1 }), de.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), de.removeEventListener(window, "touchend", this.touchend), de.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
                    }
                    offTemp() {
                        de.enableDrag(), de.removeEventListener(window, "mousemove", this.mousemove), de.removeEventListener(window, "mouseup", this.mouseup), de.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), de.removeEventListener(window, "touchend", this.touchend);
                    }
                }
                let Gt;
                function tl(h, e, i, s = !1) {
                    if (s || !i.getCoveringTilesDetailsProvider().allowWorldCopies()) return h == null ? void 0 : h.wrap();
                    const o = new c.Q(h.lng, h.lat);
                    if (h = new c.Q(h.lng, h.lat), e) {
                        const u = new c.Q(h.lng - 360, h.lat), f = new c.Q(h.lng + 360, h.lat), g = i.locationToScreenPoint(h).distSqr(e);
                        i.locationToScreenPoint(u).distSqr(e) < g ? h = u : i.locationToScreenPoint(f).distSqr(e) < g && (h = f);
                    }
                    for (; Math.abs(h.lng - i.center.lng) > 180;) {
                        const u = i.locationToScreenPoint(h);
                        if (u.x >= 0 && u.y >= 0 && u.x <= i.width && u.y <= i.height) break;
                        h.lng > i.center.lng ? h.lng -= 360 : h.lng += 360;
                    }
                    return h.lng !== o.lng && i.isPointOnMapSurface(i.locationToScreenPoint(h)) ? h : o;
                }
                const Xi = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
                function Pc(h, e, i) {
                    const s = h.classList;
                    for (const o in Xi) s.remove(`maplibregl-${i}-anchor-${o}`);
                    s.add(`maplibregl-${i}-anchor-${e}`);
                }
                class _a extends c.E {
                    constructor(e) {
                        if (super(), this._onKeyPress = (i) => {
                            const s = i.code, o = i.charCode || i.keyCode;
                            s !== "Space" && s !== "Enter" && o !== 32 && o !== 13 || this.togglePopup();
                        }, this._onMapClick = (i) => {
                            const s = i.originalEvent.target, o = this._element;
                            this._popup && (s === o || o.contains(s)) && this.togglePopup();
                        }, this._update = (i) => {
                            if (!this._map) return;
                            const s = this._map.loaded() && !this._map.isMoving();
                            ((i == null ? void 0 : i.type) === "terrain" || (i == null ? void 0 : i.type) === "render" && !s) && this._map.once("render", this._update), this._lngLat = tl(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                            let o = "";
                            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? o = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (o = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
                            let u = "";
                            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? u = "rotateX(0deg)" : this._pitchAlignment === "map" && (u = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || i && i.type !== "moveend" || (this._pos = this._pos.round()), de.setTransform(this._element, `${Xi[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${u} ${o}`), Ue.frameAsync(new AbortController()).then(() => {
                                this._updateOpacity(i && i.type === "moveend");
                            }).catch(() => {
                            });
                        }, this._onMove = (i) => {
                            if (!this._isDragging) {
                                const s = this._clickTolerance || this._map._clickTolerance;
                                this._isDragging = i.point.dist(this._pointerdownPos) >= s;
                            }
                            this._isDragging && (this._pos = i.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new c.l("dragstart"))), this.fire(new c.l("drag")));
                        }, this._onUp = () => {
                            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new c.l("dragend")), this._state = "inactive";
                        }, this._addDragHandler = (i) => {
                            this._element.contains(i.originalEvent.target) && (i.preventDefault(), this._positionDelta = i.point.sub(this._pos).add(this._offset), this._pointerdownPos = i.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
                        }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = c.P.convert(e && e.offset || [0, 0]);
                        else {
                            this._defaultMarker = !0, this._element = de.create("div");
                            const i = de.createNS("http://www.w3.org/2000/svg", "svg"), s = 41, o = 27;
                            i.setAttributeNS(null, "display", "block"), i.setAttributeNS(null, "height", `${s}px`), i.setAttributeNS(null, "width", `${o}px`), i.setAttributeNS(null, "viewBox", `0 0 ${o} ${s}`);
                            const u = de.createNS("http://www.w3.org/2000/svg", "g");
                            u.setAttributeNS(null, "stroke", "none"), u.setAttributeNS(null, "stroke-width", "1"), u.setAttributeNS(null, "fill", "none"), u.setAttributeNS(null, "fill-rule", "evenodd");
                            const f = de.createNS("http://www.w3.org/2000/svg", "g");
                            f.setAttributeNS(null, "fill-rule", "nonzero");
                            const g = de.createNS("http://www.w3.org/2000/svg", "g");
                            g.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), g.setAttributeNS(null, "fill", "#000000");
                            const y = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
                            for (const Z of y) {
                                const q = de.createNS("http://www.w3.org/2000/svg", "ellipse");
                                q.setAttributeNS(null, "opacity", "0.04"), q.setAttributeNS(null, "cx", "10.5"), q.setAttributeNS(null, "cy", "5.80029008"), q.setAttributeNS(null, "rx", Z.rx), q.setAttributeNS(null, "ry", Z.ry), g.appendChild(q);
                            }
                            const x = de.createNS("http://www.w3.org/2000/svg", "g");
                            x.setAttributeNS(null, "fill", this._color);
                            const w = de.createNS("http://www.w3.org/2000/svg", "path");
                            w.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), x.appendChild(w);
                            const P = de.createNS("http://www.w3.org/2000/svg", "g");
                            P.setAttributeNS(null, "opacity", "0.25"), P.setAttributeNS(null, "fill", "#000000");
                            const T = de.createNS("http://www.w3.org/2000/svg", "path");
                            T.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), P.appendChild(T);
                            const z = de.createNS("http://www.w3.org/2000/svg", "g");
                            z.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), z.setAttributeNS(null, "fill", "#FFFFFF");
                            const R = de.createNS("http://www.w3.org/2000/svg", "g");
                            R.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                            const V = de.createNS("http://www.w3.org/2000/svg", "circle");
                            V.setAttributeNS(null, "fill", "#000000"), V.setAttributeNS(null, "opacity", "0.25"), V.setAttributeNS(null, "cx", "5.5"), V.setAttributeNS(null, "cy", "5.5"), V.setAttributeNS(null, "r", "5.4999962");
                            const U = de.createNS("http://www.w3.org/2000/svg", "circle");
                            U.setAttributeNS(null, "fill", "#FFFFFF"), U.setAttributeNS(null, "cx", "5.5"), U.setAttributeNS(null, "cy", "5.5"), U.setAttributeNS(null, "r", "5.4999962"), R.appendChild(V), R.appendChild(U), f.appendChild(g), f.appendChild(x), f.appendChild(P), f.appendChild(z), f.appendChild(R), i.appendChild(f), i.setAttributeNS(null, "height", s * this._scale + "px"), i.setAttributeNS(null, "width", o * this._scale + "px"), this._element.appendChild(i), this._offset = c.P.convert(e && e.offset || [0, -14]);
                        }
                        if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (i) => {
                            i.preventDefault();
                        }), this._element.addEventListener("mousedown", (i) => {
                            i.preventDefault();
                        }), Pc(this._element, this._anchor, "marker"), e && e.className) for (const i of e.className.split(" ")) this._element.classList.add(i);
                        this._popup = null;
                    }
                    addTo(e) {
                        return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
                    }
                    remove() {
                        return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), de.remove(this._element), this._popup && this._popup.remove(), this;
                    }
                    getLngLat() {
                        return this._lngLat;
                    }
                    setLngLat(e) {
                        return this._lngLat = c.Q.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
                    }
                    getElement() {
                        return this._element;
                    }
                    setPopup(e) {
                        if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
                            if (!("offset" in e.options)) {
                                const o = Math.abs(13.5) / Math.SQRT2;
                                e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [o, -1 * (38.1 - 13.5 + o)], "bottom-right": [-o, -1 * (38.1 - 13.5 + o)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
                            }
                            this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
                        }
                        return this;
                    }
                    setSubpixelPositioning(e) {
                        return this._subpixelPositioning = e, this;
                    }
                    getPopup() {
                        return this._popup;
                    }
                    togglePopup() {
                        const e = this._popup;
                        return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this;
                    }
                    _updateOpacity(e = !1) {
                        var i, s;
                        const o = (i = this._map) === null || i === void 0 ? void 0 : i.terrain, u = this._map.transform.isLocationOccluded(this._lngLat);
                        if (!o || u) {
                            const z = u ? this._opacityWhenCovered : this._opacity;
                            return void (this._element.style.opacity !== z && (this._element.style.opacity = z));
                        }
                        if (e) this._opacityTimeout = null;
                        else {
                            if (this._opacityTimeout) return;
                            this._opacityTimeout = setTimeout(() => {
                                this._opacityTimeout = null;
                            }, 100);
                        }
                        const f = this._map, g = f.terrain.depthAtPoint(this._pos), y = f.terrain.getElevationForLngLatZoom(this._lngLat, f.transform.tileZoom);
                        if (f.transform.lngLatToCameraDepth(this._lngLat, y) - g < 6e-3) return void (this._element.style.opacity = this._opacity);
                        const x = -this._offset.y / f.transform.pixelsPerMeter, w = Math.sin(f.getPitch() * Math.PI / 180) * x, P = f.terrain.depthAtPoint(new c.P(this._pos.x, this._pos.y - this._offset.y)), T = f.transform.lngLatToCameraDepth(this._lngLat, y + w) - P > 6e-3;
                        !((s = this._popup) === null || s === void 0) && s.isOpen() && T && this._popup.remove(), this._element.style.opacity = T ? this._opacityWhenCovered : this._opacity;
                    }
                    getOffset() {
                        return this._offset;
                    }
                    setOffset(e) {
                        return this._offset = c.P.convert(e), this._update(), this;
                    }
                    addClassName(e) {
                        this._element.classList.add(e);
                    }
                    removeClassName(e) {
                        this._element.classList.remove(e);
                    }
                    toggleClassName(e) {
                        return this._element.classList.toggle(e);
                    }
                    setDraggable(e) {
                        return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
                    }
                    isDraggable() {
                        return this._draggable;
                    }
                    setRotation(e) {
                        return this._rotation = e || 0, this._update(), this;
                    }
                    getRotation() {
                        return this._rotation;
                    }
                    setRotationAlignment(e) {
                        return this._rotationAlignment = e || "auto", this._update(), this;
                    }
                    getRotationAlignment() {
                        return this._rotationAlignment;
                    }
                    setPitchAlignment(e) {
                        return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this;
                    }
                    getPitchAlignment() {
                        return this._pitchAlignment;
                    }
                    setOpacity(e, i) {
                        return (this._opacity === void 0 || e === void 0 && i === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), i !== void 0 && (this._opacityWhenCovered = i), this._map && this._updateOpacity(!0), this;
                    }
                }
                const Nt = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
                let Ct = 0, Ja = !1;
                const Gn = { maxWidth: 100, unit: "metric" };
                function qn(h, e, i) {
                    const s = i && i.maxWidth || 100, o = h._container.clientHeight / 2, u = h._container.clientWidth / 2, f = h.unproject([u - s / 2, o]), g = h.unproject([u + s / 2, o]), y = Math.round(h.project(g).x - h.project(f).x), x = Math.min(s, y, h._container.clientWidth), w = f.distanceTo(g);
                    if (i && i.unit === "imperial") {
                        const P = 3.2808 * w;
                        P > 5280 ? ya(e, x, P / 5280, h._getUIString("ScaleControl.Miles")) : ya(e, x, P, h._getUIString("ScaleControl.Feet"));
                    } else i && i.unit === "nautical" ? ya(e, x, w / 1852, h._getUIString("ScaleControl.NauticalMiles")) : w >= 1e3 ? ya(e, x, w / 1e3, h._getUIString("ScaleControl.Kilometers")) : ya(e, x, w, h._getUIString("ScaleControl.Meters"));
                }
                function ya(h, e, i, s) {
                    const o = function (u) {
                        const f = Math.pow(10, `${Math.floor(u)}`.length - 1);
                        let g = u / f;
                        return g = g >= 10 ? 10 : g >= 5 ? 5 : g >= 3 ? 3 : g >= 2 ? 2 : g >= 1 ? 1 : function (y) {
                            const x = Math.pow(10, Math.ceil(-Math.log(y) / Math.LN10));
                            return Math.round(y * x) / x;
                        }(g), f * g;
                    }(i);
                    h.style.width = e * (o / i) + "px", h.innerHTML = `${o}&nbsp;${s}`;
                }
                const il = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1, locationOccludedOpacity: void 0 }, rl = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
                function Qa(h) {
                    if (h) {
                        if (typeof h == "number") {
                            const e = Math.round(Math.abs(h) / Math.SQRT2);
                            return { center: new c.P(0, 0), top: new c.P(0, h), "top-left": new c.P(e, e), "top-right": new c.P(-e, e), bottom: new c.P(0, -h), "bottom-left": new c.P(e, -e), "bottom-right": new c.P(-e, -e), left: new c.P(h, 0), right: new c.P(-h, 0) };
                        }
                        if (h instanceof c.P || Array.isArray(h)) {
                            const e = c.P.convert(h);
                            return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
                        }
                        return { center: c.P.convert(h.center || [0, 0]), top: c.P.convert(h.top || [0, 0]), "top-left": c.P.convert(h["top-left"] || [0, 0]), "top-right": c.P.convert(h["top-right"] || [0, 0]), bottom: c.P.convert(h.bottom || [0, 0]), "bottom-left": c.P.convert(h["bottom-left"] || [0, 0]), "bottom-right": c.P.convert(h["bottom-right"] || [0, 0]), left: c.P.convert(h.left || [0, 0]), right: c.P.convert(h.right || [0, 0]) };
                    }
                    return Qa(new c.P(0, 0));
                }
                const al = Fe;
                M.AJAXError = c.cq, M.Event = c.l, M.Evented = c.E, M.LngLat = c.Q, M.MercatorCoordinate = c.$, M.Point = c.P, M.addProtocol = c.cr, M.config = c.a, M.removeProtocol = c.cs, M.AttributionControl = Tt, M.BoxZoomHandler = qo, M.CanvasSource = ta, M.CooperativeGesturesHandler = Hs, M.DoubleClickZoomHandler = qs, M.DragPanHandler = xc, M.DragRotateHandler = bc, M.EdgeInsets = xn, M.FullscreenControl = class extends c.E {
                    constructor(h = {}) {
                        super(), this._onFullscreenChange = () => {
                            var e;
                            let i = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
                            for (; !((e = i == null ? void 0 : i.shadowRoot) === null || e === void 0) && e.fullscreenElement;) i = i.shadowRoot.fullscreenElement;
                            i === this._container !== this._fullscreen && this._handleFullscreenChange();
                        }, this._onClickFullscreen = () => {
                            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
                        }, this._fullscreen = !1, h && h.container && (h.container instanceof HTMLElement ? this._container = h.container : c.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
                    }
                    onAdd(h) {
                        return this._map = h, this._container || (this._container = this._map.getContainer()), this._controlContainer = de.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
                    }
                    onRemove() {
                        de.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
                    }
                    _setupUI() {
                        const h = this._fullscreenButton = de.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
                        de.create("span", "maplibregl-ctrl-icon", h).setAttribute("aria-hidden", "true"), h.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
                    }
                    _updateTitle() {
                        const h = this._getTitle();
                        this._fullscreenButton.setAttribute("aria-label", h), this._fullscreenButton.title = h;
                    }
                    _getTitle() {
                        return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
                    }
                    _isFullscreen() {
                        return this._fullscreen;
                    }
                    _handleFullscreenChange() {
                        this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new c.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new c.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
                    }
                    _exitFullscreen() {
                        window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
                    }
                    _requestFullscreen() {
                        this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
                    }
                    _togglePseudoFullScreen() {
                        this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
                    }
                }, M.GeoJSONSource = dn, M.GeolocateControl = class extends c.E {
                    constructor(h) {
                        super(), this._onSuccess = (e) => {
                            if (this._map) {
                                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new c.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                                    case "WAITING_ACTIVE":
                                    case "ACTIVE_LOCK":
                                    case "ACTIVE_ERROR":
                                        this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                        break;
                                    case "BACKGROUND":
                                    case "BACKGROUND_ERROR":
                                        this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                                        break;
                                    default:
                                        throw new Error(`Unexpected watchState ${this._watchState}`);
                                }
                                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new c.l("geolocate", e)), this._finish();
                            }
                        }, this._updateCamera = (e) => {
                            const i = new c.Q(e.coords.longitude, e.coords.latitude), s = e.coords.accuracy, o = this._map.getBearing(), u = c.e({ bearing: o }, this.options.fitBoundsOptions), f = bt.fromLngLat(i, s);
                            this._map.fitBounds(f, u, { geolocateSource: !0 });
                        }, this._updateMarker = (e) => {
                            if (e) {
                                const i = new c.Q(e.coords.longitude, e.coords.latitude);
                                this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
                        }, this._onZoom = () => {
                            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                        }, this._onError = (e) => {
                            if (this._map) {
                                if (e.code === 1) {
                                    this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                                    const i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                    this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i), this._geolocationWatchID !== void 0 && this._clearWatch();
                                } else {
                                    if (e.code === 3 && Ja) return;
                                    this.options.trackUserLocation && this._setErrorState();
                                }
                                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new c.l("error", e)), this._finish();
                            }
                        }, this._finish = () => {
                            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
                        }, this._setupUI = () => {
                            this._map && (this._container.addEventListener("contextmenu", (e) => e.preventDefault()), this._geolocateButton = de.create("button", "maplibregl-ctrl-geolocate", this._container), de.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
                        }, this._finishSetupUI = (e) => {
                            if (this._map) {
                                if (e === !1) {
                                    c.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                                    const i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                    this._geolocateButton.disabled = !0, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i);
                                } else {
                                    const i = this._map._getUIString("GeolocateControl.FindMyLocation");
                                    this._geolocateButton.disabled = !1, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i);
                                }
                                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = de.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new _a({ element: this._dotElement }), this._circleElement = de.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new _a({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (i) => {
                                    i.geolocateSource || this._watchState !== "ACTIVE_LOCK" || i.originalEvent && i.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new c.l("trackuserlocationend")), this.fire(new c.l("userlocationlostfocus")));
                                });
                            }
                        }, this.options = c.e({}, Nt, h);
                    }
                    onAdd(h) {
                        return this._map = h, this._container = de.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function () {
                            return c._(this, arguments, void 0, function* (e = !1) {
                                if (Gt !== void 0 && !e) return Gt;
                                if (window.navigator.permissions === void 0) return Gt = !!window.navigator.geolocation, Gt;
                                try {
                                    Gt = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                                } catch {
                                    Gt = !!window.navigator.geolocation;
                                }
                                return Gt;
                            });
                        }().then((e) => this._finishSetupUI(e)), this._container;
                    }
                    onRemove() {
                        this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), de.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ct = 0, Ja = !1;
                    }
                    _isOutOfMapMaxBounds(h) {
                        const e = this._map.getMaxBounds(), i = h.coords;
                        return e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth());
                    }
                    _setErrorState() {
                        switch (this._watchState) {
                            case "WAITING_ACTIVE":
                                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                                break;
                            case "ACTIVE_LOCK":
                                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                                break;
                            case "BACKGROUND":
                                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                                break;
                            case "ACTIVE_ERROR":
                                break;
                            default:
                                throw new Error(`Unexpected watchState ${this._watchState}`);
                        }
                    }
                    _updateCircleRadius() {
                        const h = this._map.getBounds(), e = h.getSouthEast(), i = h.getNorthEast(), s = e.distanceTo(i), o = Math.ceil(this._accuracy / (s / this._map._container.clientHeight) * 2);
                        this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`;
                    }
                    trigger() {
                        if (!this._setup) return c.w("Geolocate control triggered before added to a map"), !1;
                        if (this.options.trackUserLocation) {
                            switch (this._watchState) {
                                case "OFF":
                                    this._watchState = "WAITING_ACTIVE", this.fire(new c.l("trackuserlocationstart"));
                                    break;
                                case "WAITING_ACTIVE":
                                case "ACTIVE_LOCK":
                                case "ACTIVE_ERROR":
                                case "BACKGROUND_ERROR":
                                    Ct--, Ja = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new c.l("trackuserlocationend"));
                                    break;
                                case "BACKGROUND":
                                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new c.l("trackuserlocationstart")), this.fire(new c.l("userlocationfocus"));
                                    break;
                                default:
                                    throw new Error(`Unexpected watchState ${this._watchState}`);
                            }
                            switch (this._watchState) {
                                case "WAITING_ACTIVE":
                                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                    break;
                                case "ACTIVE_LOCK":
                                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                    break;
                                case "OFF":
                                    break;
                                default:
                                    throw new Error(`Unexpected watchState ${this._watchState}`);
                            }
                            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
                            else if (this._geolocationWatchID === void 0) {
                                let h;
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ct++, Ct > 1 ? (h = { maximumAge: 6e5, timeout: 0 }, Ja = !0) : (h = this.options.positionOptions, Ja = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, h);
                            }
                        } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
                        return !0;
                    }
                    _clearWatch() {
                        window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
                    }
                }, M.GlobeControl = class {
                    constructor() {
                        this._toggleProjection = () => {
                            var h;
                            const e = (h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type;
                            this._map.setProjection(e !== "mercator" && e ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
                        }, this._updateGlobeIcon = () => {
                            var h;
                            this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
                        };
                    }
                    onAdd(h) {
                        return this._map = h, this._container = de.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = de.create("button", "maplibregl-ctrl-globe", this._container), de.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
                    }
                    onRemove() {
                        de.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
                    }
                }, M.Hash = Uo, M.ImageSource = Fi, M.KeyboardHandler = Ya, M.LngLatBounds = bt, M.LogoControl = Vn, M.Map = class extends Th {
                    constructor(h) {
                        var e, i;
                        c.cn.mark(c.co.create);
                        const s = Object.assign(Object.assign(Object.assign({}, Zn), h), { canvasContextAttributes: Object.assign(Object.assign({}, Zn.canvasContextAttributes), h.canvasContextAttributes) });
                        if (s.minZoom != null && s.maxZoom != null && s.minZoom > s.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
                        if (s.minPitch != null && s.maxPitch != null && s.minPitch > s.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
                        if (s.minPitch != null && s.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
                        if (s.maxPitch != null && s.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
                        const o = new La(), u = new bn();
                        if (s.minZoom !== void 0 && o.setMinZoom(s.minZoom), s.maxZoom !== void 0 && o.setMaxZoom(s.maxZoom), s.minPitch !== void 0 && o.setMinPitch(s.minPitch), s.maxPitch !== void 0 && o.setMaxPitch(s.maxPitch), s.renderWorldCopies !== void 0 && o.setRenderWorldCopies(s.renderWorldCopies), super(o, u, { bearingSnap: s.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Jo(), this._controls = [], this._mapId = c.a4(), this._contextLost = (g) => {
                            g.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new c.l("webglcontextlost", { originalEvent: g }));
                        }, this._contextRestored = (g) => {
                            this._setupPainter(), this.resize(), this._update(), this.fire(new c.l("webglcontextrestored", { originalEvent: g }));
                        }, this._onMapScroll = (g) => {
                            if (g.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
                        }, this._onWindowOnline = () => {
                            this._update();
                        }, this._interactive = s.interactive, this._maxTileCacheSize = s.maxTileCacheSize, this._maxTileCacheZoomLevels = s.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, s.canvasContextAttributes), this._trackResize = s.trackResize === !0, this._bearingSnap = s.bearingSnap, this._centerClampedToGround = s.centerClampedToGround, this._refreshExpiredTiles = s.refreshExpiredTiles === !0, this._fadeDuration = s.fadeDuration, this._crossSourceCollisions = s.crossSourceCollisions === !0, this._collectResourceTiming = s.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, je), s.locale), this._clickTolerance = s.clickTolerance, this._overridePixelRatio = s.pixelRatio, this._maxCanvasSize = s.maxCanvasSize, this.transformCameraUpdate = s.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = s.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = bi.addThrottleControl(() => this.isMoving()), this._requestManager = new Zt(s.transformRequest), typeof s.container == "string") {
                            if (this._container = document.getElementById(s.container), !this._container) throw new Error(`Container '${s.container}' not found.`);
                        } else {
                            if (!(s.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                            this._container = s.container;
                        }
                        if (s.maxBounds && this.setMaxBounds(s.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this.on("terrain", () => {
                            this.painter.terrainFacilitator.dirty = !0, this._update(!0);
                        }), this.once("idle", () => {
                            this._idleTriggered = !0;
                        }), typeof window < "u") {
                            addEventListener("online", this._onWindowOnline, !1);
                            let g = !1;
                            const y = On((x) => {
                                this._trackResize && !this._removed && (this.resize(x), this.redraw());
                            }, 50);
                            this._resizeObserver = new ResizeObserver((x) => {
                                g ? y(x) : g = !0;
                            }), this._resizeObserver.observe(this._container);
                        }
                        this.handlers = new Sh(this, s), this._hash = s.hash && new Uo(typeof s.hash == "string" && s.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: s.center, elevation: s.elevation, zoom: s.zoom, bearing: s.bearing, pitch: s.pitch, roll: s.roll }), s.bounds && (this.resize(), this.fitBounds(s.bounds, c.e({}, s.fitBoundsOptions, { duration: 0 }))));
                        const f = typeof s.style == "string" || ((i = (e = s.style) === null || e === void 0 ? void 0 : e.projection) === null || i === void 0 ? void 0 : i.type) !== "globe";
                        this.resize(null, f), this._localIdeographFontFamily = s.localIdeographFontFamily, this._validateStyle = s.validateStyle, s.style && this.setStyle(s.style, { localIdeographFontFamily: s.localIdeographFontFamily }), s.attributionControl && this.addControl(new Tt(typeof s.attributionControl == "boolean" ? void 0 : s.attributionControl)), s.maplibreLogo && this.addControl(new Vn(), s.logoPosition), this.on("style.load", () => {
                            if (f || this._resizeTransform(), this.transform.unmodified) {
                                const g = c.O(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                                this.jumpTo(g);
                            }
                        }), this.on("data", (g) => {
                            this._update(g.dataType === "style"), this.fire(new c.l(`${g.dataType}data`, g));
                        }), this.on("dataloading", (g) => {
                            this.fire(new c.l(`${g.dataType}dataloading`, g));
                        }), this.on("dataabort", (g) => {
                            this.fire(new c.l("sourcedataabort", g));
                        });
                    }
                    _getMapId() {
                        return this._mapId;
                    }
                    addControl(h, e) {
                        if (e === void 0 && (e = h.getDefaultPosition ? h.getDefaultPosition() : "top-right"), !h || !h.onAdd) return this.fire(new c.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                        const i = h.onAdd(this);
                        this._controls.push(h);
                        const s = this._controlPositions[e];
                        return e.indexOf("bottom") !== -1 ? s.insertBefore(i, s.firstChild) : s.appendChild(i), this;
                    }
                    removeControl(h) {
                        if (!h || !h.onRemove) return this.fire(new c.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                        const e = this._controls.indexOf(h);
                        return e > -1 && this._controls.splice(e, 1), h.onRemove(this), this;
                    }
                    hasControl(h) {
                        return this._controls.indexOf(h) > -1;
                    }
                    calculateCameraOptionsFromTo(h, e, i, s) {
                        return s == null && this.terrain && (s = this.terrain.getElevationForLngLatZoom(i, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(h, e, i, s);
                    }
                    resize(h, e = !0) {
                        const [i, s] = this._containerDimensions(), o = this._getClampedPixelRatio(i, s);
                        if (this._resizeCanvas(i, s, o), this.painter.resize(i, s, o), this.painter.overLimit()) {
                            const f = this.painter.context.gl;
                            this._maxCanvasSize = [f.drawingBufferWidth, f.drawingBufferHeight];
                            const g = this._getClampedPixelRatio(i, s);
                            this._resizeCanvas(i, s, g), this.painter.resize(i, s, g);
                        }
                        this._resizeTransform(e);
                        const u = !this._moving;
                        return u && (this.stop(), this.fire(new c.l("movestart", h)).fire(new c.l("move", h))), this.fire(new c.l("resize", h)), u && this.fire(new c.l("moveend", h)), this;
                    }
                    _resizeTransform(h = !0) {
                        var e;
                        const [i, s] = this._containerDimensions();
                        this.transform.resize(i, s, h), (e = this._requestedCameraState) === null || e === void 0 || e.resize(i, s, h);
                    }
                    _getClampedPixelRatio(h, e) {
                        const { 0: i, 1: s } = this._maxCanvasSize, o = this.getPixelRatio(), u = h * o, f = e * o;
                        return Math.min(u > i ? i / u : 1, f > s ? s / f : 1) * o;
                    }
                    getPixelRatio() {
                        var h;
                        return (h = this._overridePixelRatio) !== null && h !== void 0 ? h : devicePixelRatio;
                    }
                    setPixelRatio(h) {
                        this._overridePixelRatio = h, this.resize();
                    }
                    getBounds() {
                        return this.transform.getBounds();
                    }
                    getMaxBounds() {
                        return this.transform.getMaxBounds();
                    }
                    setMaxBounds(h) {
                        return this.transform.setMaxBounds(bt.convert(h)), this._update();
                    }
                    setMinZoom(h) {
                        if ((h = h ?? -2) >= -2 && h <= this.transform.maxZoom) return this.transform.setMinZoom(h), this._update(), this.getZoom() < h && this.setZoom(h), this;
                        throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
                    }
                    getMinZoom() {
                        return this.transform.minZoom;
                    }
                    setMaxZoom(h) {
                        if ((h = h ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(h), this._update(), this.getZoom() > h && this.setZoom(h), this;
                        throw new Error("maxZoom must be greater than the current minZoom");
                    }
                    getMaxZoom() {
                        return this.transform.maxZoom;
                    }
                    setMinPitch(h) {
                        if ((h = h ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
                        if (h >= 0 && h <= this.transform.maxPitch) return this.transform.setMinPitch(h), this._update(), this.getPitch() < h && this.setPitch(h), this;
                        throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
                    }
                    getMinPitch() {
                        return this.transform.minPitch;
                    }
                    setMaxPitch(h) {
                        if ((h = h ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
                        if (h >= this.transform.minPitch) return this.transform.setMaxPitch(h), this._update(), this.getPitch() > h && this.setPitch(h), this;
                        throw new Error("maxPitch must be greater than the current minPitch");
                    }
                    getMaxPitch() {
                        return this.transform.maxPitch;
                    }
                    getRenderWorldCopies() {
                        return this.transform.renderWorldCopies;
                    }
                    setRenderWorldCopies(h) {
                        return this.transform.setRenderWorldCopies(h), this._update();
                    }
                    project(h) {
                        return this.transform.locationToScreenPoint(c.Q.convert(h), this.style && this.terrain);
                    }
                    unproject(h) {
                        return this.transform.screenPointToLocation(c.P.convert(h), this.terrain);
                    }
                    isMoving() {
                        var h;
                        return this._moving || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isMoving());
                    }
                    isZooming() {
                        var h;
                        return this._zooming || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isZooming());
                    }
                    isRotating() {
                        var h;
                        return this._rotating || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isRotating());
                    }
                    _createDelegatedListener(h, e, i) {
                        if (h === "mouseenter" || h === "mouseover") {
                            let s = !1;
                            return {
                                layers: e, listener: i, delegates: {
                                    mousemove: (u) => {
                                        const f = e.filter((y) => this.getLayer(y)), g = f.length !== 0 ? this.queryRenderedFeatures(u.point, { layers: f }) : [];
                                        g.length ? s || (s = !0, i.call(this, new Xt(h, this, u.originalEvent, { features: g }))) : s = !1;
                                    }, mouseout: () => {
                                        s = !1;
                                    }
                                }
                            };
                        }
                        if (h === "mouseleave" || h === "mouseout") {
                            let s = !1;
                            return {
                                layers: e, listener: i, delegates: {
                                    mousemove: (f) => {
                                        const g = e.filter((y) => this.getLayer(y));
                                        (g.length !== 0 ? this.queryRenderedFeatures(f.point, { layers: g }) : []).length ? s = !0 : s && (s = !1, i.call(this, new Xt(h, this, f.originalEvent)));
                                    }, mouseout: (f) => {
                                        s && (s = !1, i.call(this, new Xt(h, this, f.originalEvent)));
                                    }
                                }
                            };
                        }
                        {
                            const s = (o) => {
                                const u = e.filter((g) => this.getLayer(g)), f = u.length !== 0 ? this.queryRenderedFeatures(o.point, { layers: u }) : [];
                                f.length && (o.features = f, i.call(this, o), delete o.features);
                            };
                            return { layers: e, listener: i, delegates: { [h]: s } };
                        }
                    }
                    _saveDelegatedListener(h, e) {
                        this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[h] = this._delegatedListeners[h] || [], this._delegatedListeners[h].push(e);
                    }
                    _removeDelegatedListener(h, e, i) {
                        if (!this._delegatedListeners || !this._delegatedListeners[h]) return;
                        const s = this._delegatedListeners[h];
                        for (let o = 0; o < s.length; o++) {
                            const u = s[o];
                            if (u.listener === i && u.layers.length === e.length && u.layers.every((f) => e.includes(f))) {
                                for (const f in u.delegates) this.off(f, u.delegates[f]);
                                return void s.splice(o, 1);
                            }
                        }
                    }
                    on(h, e, i) {
                        if (i === void 0) return super.on(h, e);
                        const s = typeof e == "string" ? [e] : e, o = this._createDelegatedListener(h, s, i);
                        this._saveDelegatedListener(h, o);
                        for (const u in o.delegates) this.on(u, o.delegates[u]);
                        return {
                            unsubscribe: () => {
                                this._removeDelegatedListener(h, s, i);
                            }
                        };
                    }
                    once(h, e, i) {
                        if (i === void 0) return super.once(h, e);
                        const s = typeof e == "string" ? [e] : e, o = this._createDelegatedListener(h, s, i);
                        for (const u in o.delegates) {
                            const f = o.delegates[u];
                            o.delegates[u] = (...g) => {
                                this._removeDelegatedListener(h, s, i), f(...g);
                            };
                        }
                        this._saveDelegatedListener(h, o);
                        for (const u in o.delegates) this.once(u, o.delegates[u]);
                        return this;
                    }
                    off(h, e, i) {
                        return i === void 0 ? super.off(h, e) : (this._removeDelegatedListener(h, typeof e == "string" ? [e] : e, i), this);
                    }
                    queryRenderedFeatures(h, e) {
                        if (!this.style) return [];
                        let i;
                        const s = h instanceof c.P || Array.isArray(h), o = s ? h : [[0, 0], [this.transform.width, this.transform.height]];
                        if (e = e || (s ? {} : h) || {}, o instanceof c.P || typeof o[0] == "number") i = [c.P.convert(o)];
                        else {
                            const u = c.P.convert(o[0]), f = c.P.convert(o[1]);
                            i = [u, new c.P(f.x, u.y), f, new c.P(u.x, f.y), u];
                        }
                        return this.style.queryRenderedFeatures(i, e, this.transform);
                    }
                    querySourceFeatures(h, e) {
                        return this.style.querySourceFeatures(h, e);
                    }
                    setStyle(h, e) {
                        return (e = c.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && h ? (this._diffStyle(h, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(h, e));
                    }
                    setTransformRequest(h) {
                        return this._requestManager.setTransformRequest(h), this;
                    }
                    _getUIString(h) {
                        const e = this._locale[h];
                        if (e == null) throw new Error(`Missing UI string '${h}'`);
                        return e;
                    }
                    _updateStyle(h, e) {
                        var i, s;
                        if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(h, e));
                        const o = this.style && e.transformStyle ? this.style.serialize() : void 0;
                        return this.style && (this.style.setEventedParent(null), this.style._remove(!h)), h ? (this.style = new To(this, e || {}), this.style.setEventedParent(this, { style: this.style }), typeof h == "string" ? this.style.loadURL(h, e, o) : this.style.loadJSON(h, e, o), this) : ((s = (i = this.style) === null || i === void 0 ? void 0 : i.projection) === null || s === void 0 || s.destroy(), delete this.style, this);
                    }
                    _lazyInitEmptyStyle() {
                        this.style || (this.style = new To(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
                    }
                    _diffStyle(h, e) {
                        if (typeof h == "string") {
                            const i = this._requestManager.transformRequest(h, "Style");
                            c.j(i, new AbortController()).then((s) => {
                                this._updateDiff(s.data, e);
                            }).catch((s) => {
                                s && this.fire(new c.k(s));
                            });
                        } else typeof h == "object" && this._updateDiff(h, e);
                    }
                    _updateDiff(h, e) {
                        try {
                            this.style.setState(h, e) && this._update(!0);
                        } catch (i) {
                            c.w(`Unable to perform style diff: ${i.message || i.error || i}.  Rebuilding the style from scratch.`), this._updateStyle(h, e);
                        }
                    }
                    getStyle() {
                        if (this.style) return this.style.serialize();
                    }
                    isStyleLoaded() {
                        return this.style ? this.style.loaded() : c.w("There is no style added to the map.");
                    }
                    addSource(h, e) {
                        return this._lazyInitEmptyStyle(), this.style.addSource(h, e), this._update(!0);
                    }
                    isSourceLoaded(h) {
                        const e = this.style && this.style.sourceCaches[h];
                        if (e !== void 0) return e.loaded();
                        this.fire(new c.k(new Error(`There is no source with ID '${h}'`)));
                    }
                    setTerrain(h) {
                        if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), h) {
                            const e = this.style.sourceCaches[h.source];
                            if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${h.source}`);
                            this.terrain === null && e.reload();
                            for (const i in this.style._layers) {
                                const s = this.style._layers[i];
                                s.type === "hillshade" && s.source === h.source && c.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
                            }
                            this.terrain = new Tc(this.painter, e, h), this.painter.renderToTexture = new Xs(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (i) => {
                                var s;
                                i.dataType === "style" ? this.terrain.sourceCache.freeRtt() : i.dataType === "source" && i.tile && (i.sourceId !== h.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((s = i.source) === null || s === void 0 ? void 0 : s.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(i.tile.tileID));
                            }, this.style.on("data", this._terrainDataCallback);
                        } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
                        return this.fire(new c.l("terrain", { terrain: h })), this;
                    }
                    getTerrain() {
                        var h, e;
                        return (e = (h = this.terrain) === null || h === void 0 ? void 0 : h.options) !== null && e !== void 0 ? e : null;
                    }
                    areTilesLoaded() {
                        const h = this.style && this.style.sourceCaches;
                        for (const e in h) {
                            const i = h[e]._tiles;
                            for (const s in i) {
                                const o = i[s];
                                if (o.state !== "loaded" && o.state !== "errored") return !1;
                            }
                        }
                        return !0;
                    }
                    removeSource(h) {
                        return this.style.removeSource(h), this._update(!0);
                    }
                    getSource(h) {
                        return this.style.getSource(h);
                    }
                    setSourceTileLodParams(h, e, i) {
                        if (i) {
                            const s = this.getSource(i);
                            if (!s) throw new Error(`There is no source with ID "${i}", cannot set LOD parameters`);
                            s.calculateTileZoom = re(Math.max(1, h), Math.max(1, e));
                        } else for (const s in this.style.sourceCaches) this.style.sourceCaches[s].getSource().calculateTileZoom = re(Math.max(1, h), Math.max(1, e));
                        return this._update(!0), this;
                    }
                    refreshTiles(h, e) {
                        const i = this.style.sourceCaches[h];
                        if (!i) throw new Error(`There is no source cache with ID "${h}", cannot refresh tile`);
                        e === void 0 ? i.reload() : i.refreshTiles(e.map((s) => new c.a1(s.z, s.x, s.y)));
                    }
                    addImage(h, e, i = {}) {
                        const { pixelRatio: s = 1, sdf: o = !1, stretchX: u, stretchY: f, content: g, textFitWidth: y, textFitHeight: x } = i;
                        if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || c.b(e))) {
                            if (e.width === void 0 || e.height === void 0) return this.fire(new c.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                            {
                                const { width: w, height: P, data: T } = e, z = e;
                                return this.style.addImage(h, { data: new c.R({ width: w, height: P }, new Uint8Array(T)), pixelRatio: s, stretchX: u, stretchY: f, content: g, textFitWidth: y, textFitHeight: x, sdf: o, version: 0, userImage: z }), z.onAdd && z.onAdd(this, h), this;
                            }
                        }
                        {
                            const { width: w, height: P, data: T } = Ue.getImageData(e);
                            this.style.addImage(h, { data: new c.R({ width: w, height: P }, T), pixelRatio: s, stretchX: u, stretchY: f, content: g, textFitWidth: y, textFitHeight: x, sdf: o, version: 0 });
                        }
                    }
                    updateImage(h, e) {
                        const i = this.style.getImage(h);
                        if (!i) return this.fire(new c.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                        const s = e instanceof HTMLImageElement || c.b(e) ? Ue.getImageData(e) : e, { width: o, height: u, data: f } = s;
                        if (o === void 0 || u === void 0) return this.fire(new c.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                        if (o !== i.data.width || u !== i.data.height) return this.fire(new c.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
                        const g = !(e instanceof HTMLImageElement || c.b(e));
                        return i.data.replace(f, g), this.style.updateImage(h, i), this;
                    }
                    getImage(h) {
                        return this.style.getImage(h);
                    }
                    hasImage(h) {
                        return h ? !!this.style.getImage(h) : (this.fire(new c.k(new Error("Missing required image id"))), !1);
                    }
                    removeImage(h) {
                        this.style.removeImage(h);
                    }
                    loadImage(h) {
                        return bi.getImage(this._requestManager.transformRequest(h, "Image"), new AbortController());
                    }
                    listImages() {
                        return this.style.listImages();
                    }
                    addLayer(h, e) {
                        return this._lazyInitEmptyStyle(), this.style.addLayer(h, e), this._update(!0);
                    }
                    moveLayer(h, e) {
                        return this.style.moveLayer(h, e), this._update(!0);
                    }
                    removeLayer(h) {
                        return this.style.removeLayer(h), this._update(!0);
                    }
                    getLayer(h) {
                        return this.style.getLayer(h);
                    }
                    getLayersOrder() {
                        return this.style.getLayersOrder();
                    }
                    setLayerZoomRange(h, e, i) {
                        return this.style.setLayerZoomRange(h, e, i), this._update(!0);
                    }
                    setFilter(h, e, i = {}) {
                        return this.style.setFilter(h, e, i), this._update(!0);
                    }
                    getFilter(h) {
                        return this.style.getFilter(h);
                    }
                    setPaintProperty(h, e, i, s = {}) {
                        return this.style.setPaintProperty(h, e, i, s), this._update(!0);
                    }
                    getPaintProperty(h, e) {
                        return this.style.getPaintProperty(h, e);
                    }
                    setLayoutProperty(h, e, i, s = {}) {
                        return this.style.setLayoutProperty(h, e, i, s), this._update(!0);
                    }
                    getLayoutProperty(h, e) {
                        return this.style.getLayoutProperty(h, e);
                    }
                    setGlyphs(h, e = {}) {
                        return this._lazyInitEmptyStyle(), this.style.setGlyphs(h, e), this._update(!0);
                    }
                    getGlyphs() {
                        return this.style.getGlyphsUrl();
                    }
                    addSprite(h, e, i = {}) {
                        return this._lazyInitEmptyStyle(), this.style.addSprite(h, e, i, (s) => {
                            s || this._update(!0);
                        }), this;
                    }
                    removeSprite(h) {
                        return this._lazyInitEmptyStyle(), this.style.removeSprite(h), this._update(!0);
                    }
                    getSprite() {
                        return this.style.getSprite();
                    }
                    setSprite(h, e = {}) {
                        return this._lazyInitEmptyStyle(), this.style.setSprite(h, e, (i) => {
                            i || this._update(!0);
                        }), this;
                    }
                    setLight(h, e = {}) {
                        return this._lazyInitEmptyStyle(), this.style.setLight(h, e), this._update(!0);
                    }
                    getLight() {
                        return this.style.getLight();
                    }
                    setSky(h, e = {}) {
                        return this._lazyInitEmptyStyle(), this.style.setSky(h, e), this._update(!0);
                    }
                    getSky() {
                        return this.style.getSky();
                    }
                    setFeatureState(h, e) {
                        return this.style.setFeatureState(h, e), this._update();
                    }
                    removeFeatureState(h, e) {
                        return this.style.removeFeatureState(h, e), this._update();
                    }
                    getFeatureState(h) {
                        return this.style.getFeatureState(h);
                    }
                    getContainer() {
                        return this._container;
                    }
                    getCanvasContainer() {
                        return this._canvasContainer;
                    }
                    getCanvas() {
                        return this._canvas;
                    }
                    _containerDimensions() {
                        let h = 0, e = 0;
                        return this._container && (h = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [h, e];
                    }
                    _setupContainer() {
                        const h = this._container;
                        h.classList.add("maplibregl-map");
                        const e = this._canvasContainer = de.create("div", "maplibregl-canvas-container", h);
                        this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = de.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
                        const i = this._containerDimensions(), s = this._getClampedPixelRatio(i[0], i[1]);
                        this._resizeCanvas(i[0], i[1], s);
                        const o = this._controlContainer = de.create("div", "maplibregl-control-container", h), u = this._controlPositions = {};
                        ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((f) => {
                            u[f] = de.create("div", `maplibregl-ctrl-${f} `, o);
                        }), this._container.addEventListener("scroll", this._onMapScroll, !1);
                    }
                    _resizeCanvas(h, e, i) {
                        this._canvas.width = Math.floor(i * h), this._canvas.height = Math.floor(i * e), this._canvas.style.width = `${h}px`, this._canvas.style.height = `${e}px`;
                    }
                    _setupPainter() {
                        const h = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 });
                        let e = null;
                        this._canvas.addEventListener("webglcontextcreationerror", (s) => {
                            e = { requestedAttributes: h }, s && (e.statusMessage = s.statusMessage, e.type = s.type);
                        }, { once: !0 });
                        let i = null;
                        if (i = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, h) : this._canvas.getContext("webgl2", h) || this._canvas.getContext("webgl", h), !i) {
                            const s = "Failed to initialize WebGL";
                            throw e ? (e.message = s, new Error(JSON.stringify(e))) : new Error(s);
                        }
                        this.painter = new $o(i, this.transform), $e.testSupport(i);
                    }
                    migrateProjection(h, e) {
                        super.migrateProjection(h, e), this.painter.transform = h, this.fire(new c.l("projectiontransition", { newProjection: this.style.projection.name }));
                    }
                    loaded() {
                        return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
                    }
                    _update(h) {
                        return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || h, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
                    }
                    _requestRenderFrame(h) {
                        return this._update(), this._renderTaskQueue.add(h);
                    }
                    _cancelRenderFrame(h) {
                        this._renderTaskQueue.remove(h);
                    }
                    _render(h) {
                        var e, i, s, o, u;
                        const f = this._idleTriggered ? this._fadeDuration : 0, g = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
                        if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(h), this._removed) return;
                        let y = !1;
                        if (this.style && this._styleDirty) {
                            this._styleDirty = !1;
                            const P = this.transform.zoom, T = Ue.now();
                            this.style.zoomHistory.update(P, T);
                            const z = new c.C(P, { now: T, fadeDuration: f, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), R = z.crossFadingFactor();
                            R === 1 && R === this._crossFadingFactor || (y = !0, this._crossFadingFactor = R), this.style.update(z);
                        }
                        const x = ((i = this.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0 !== g;
                        (s = this.style.projection) === null || s === void 0 || s.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((o = this.style.projection) === null || o === void 0 ? void 0 : o.transitionState, (u = this.style.projection) === null || u === void 0 ? void 0 : u.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || x) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, f, this._crossSourceCollisions, x), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: f, showPadding: this.showPadding }), this.fire(new c.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, c.cn.mark(c.co.load), this.fire(new c.l("load"))), this.style && (this.style.hasTransitions() || y) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
                        const w = this._sourcesDirty || this._styleDirty || this._placementDirty;
                        return w || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new c.l("idle")), !this._loaded || this._fullyLoaded || w || (this._fullyLoaded = !0, c.cn.mark(c.co.fullLoad)), this;
                    }
                    redraw() {
                        return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
                    }
                    remove() {
                        var h;
                        this._hash && this._hash.remove();
                        for (const i of this._controls) i.onRemove(this);
                        this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), bi.removeThrottleControl(this._imageQueueHandle), (h = this._resizeObserver) === null || h === void 0 || h.disconnect();
                        const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
                        e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), de.remove(this._canvasContainer), de.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), c.cn.clearMetrics(), this._removed = !0, this.fire(new c.l("remove"));
                    }
                    triggerRepaint() {
                        this.style && !this._frameRequest && (this._frameRequest = new AbortController(), Ue.frame(this._frameRequest, (h) => {
                            c.cn.frame(h), this._frameRequest = null;
                            try {
                                this._render(h);
                            } catch (e) {
                                if (!c.cp(e) && !function (i) {
                                    return i.message === zs;
                                }(e)) throw e;
                            }
                        }, () => {
                        }));
                    }
                    get showTileBoundaries() {
                        return !!this._showTileBoundaries;
                    }
                    set showTileBoundaries(h) {
                        this._showTileBoundaries !== h && (this._showTileBoundaries = h, this._update());
                    }
                    get showPadding() {
                        return !!this._showPadding;
                    }
                    set showPadding(h) {
                        this._showPadding !== h && (this._showPadding = h, this._update());
                    }
                    get showCollisionBoxes() {
                        return !!this._showCollisionBoxes;
                    }
                    set showCollisionBoxes(h) {
                        this._showCollisionBoxes !== h && (this._showCollisionBoxes = h, h ? this.style._generateCollisionBoxes() : this._update());
                    }
                    get showOverdrawInspector() {
                        return !!this._showOverdrawInspector;
                    }
                    set showOverdrawInspector(h) {
                        this._showOverdrawInspector !== h && (this._showOverdrawInspector = h, this._update());
                    }
                    get repaint() {
                        return !!this._repaint;
                    }
                    set repaint(h) {
                        this._repaint !== h && (this._repaint = h, this.triggerRepaint());
                    }
                    get vertices() {
                        return !!this._vertices;
                    }
                    set vertices(h) {
                        this._vertices = h, this._update();
                    }
                    get version() {
                        return He;
                    }
                    getCameraTargetElevation() {
                        return this.transform.elevation;
                    }
                    getProjection() {
                        return this.style.getProjection();
                    }
                    setProjection(h) {
                        return this._lazyInitEmptyStyle(), this.style.setProjection(h), this._update(!0);
                    }
                }, M.MapMouseEvent = Xt, M.MapTouchEvent = Ga, M.MapWheelEvent = Go, M.Marker = _a, M.NavigationControl = class {
                    constructor(h) {
                        this._updateZoomButtons = () => {
                            const e = this._map.getZoom(), i = e === this._map.getMaxZoom(), s = e === this._map.getMinZoom();
                            this._zoomInButton.disabled = i, this._zoomOutButton.disabled = s, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", s.toString());
                        }, this._rotateCompassArrow = () => {
                            this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
                        }, this._setButtonTitle = (e, i) => {
                            const s = this._map._getUIString(`NavigationControl.${i}`);
                            e.title = s, e.setAttribute("aria-label", s);
                        }, this.options = c.e({}, Qo, h), this._container = de.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e) => e.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e) => this._map.zoomIn({}, { originalEvent: e })), de.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e) => this._map.zoomOut({}, { originalEvent: e })), de.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e) => {
                            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e });
                        }), this._compassIcon = de.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
                    }
                    onAdd(h) {
                        return this._map = h, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new el(this._map, this._compass, this.options.visualizePitch)), this._container;
                    }
                    onRemove() {
                        de.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
                    }
                    _createButton(h, e) {
                        const i = de.create("button", h, this._container);
                        return i.type = "button", i.addEventListener("click", e), i;
                    }
                }, M.Popup = class extends c.E {
                    constructor(h) {
                        super(), this._updateOpacity = () => {
                            this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : void 0);
                        }, this.remove = () => (this._content && de.remove(this._content), this._container && (de.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new c.l("close"))), this), this._onMouseUp = (e) => {
                            this._update(e.point);
                        }, this._onMouseMove = (e) => {
                            this._update(e.point);
                        }, this._onDrag = (e) => {
                            this._update(e.point);
                        }, this._update = (e) => {
                            if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
                            if (!this._container) {
                                if (this._container = de.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = de.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const f of this.options.className.split(" ")) this._container.classList.add(f);
                                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
                            }
                            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = tl(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
                            const i = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
                            this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
                            let s = this.options.anchor;
                            const o = Qa(this.options.offset);
                            if (!s) {
                                const f = this._container.offsetWidth, g = this._container.offsetHeight;
                                let y;
                                y = i.y + o.bottom.y < g ? ["top"] : i.y > this._map.transform.height - g ? ["bottom"] : [], i.x < f / 2 ? y.push("left") : i.x > this._map.transform.width - f / 2 && y.push("right"), s = y.length === 0 ? "bottom" : y.join("-");
                            }
                            let u = i.add(o[s]);
                            this.options.subpixelPositioning || (u = u.round()), de.setTransform(this._container, `${Xi[s]} translate(${u.x}px,${u.y}px)`), Pc(this._container, s, "popup"), this._updateOpacity();
                        }, this._onClose = () => {
                            this.remove();
                        }, this.options = c.e(Object.create(il), h);
                    }
                    addTo(h) {
                        return this._map && this.remove(), this._map = h, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new c.l("open")), this;
                    }
                    isOpen() {
                        return !!this._map;
                    }
                    getLngLat() {
                        return this._lngLat;
                    }
                    setLngLat(h) {
                        return this._lngLat = c.Q.convert(h), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
                    }
                    trackPointer() {
                        return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
                    }
                    getElement() {
                        return this._container;
                    }
                    setText(h) {
                        return this.setDOMContent(document.createTextNode(h));
                    }
                    setHTML(h) {
                        const e = document.createDocumentFragment(), i = document.createElement("body");
                        let s;
                        for (i.innerHTML = h; s = i.firstChild, s;) e.appendChild(s);
                        return this.setDOMContent(e);
                    }
                    getMaxWidth() {
                        var h;
                        return (h = this._container) === null || h === void 0 ? void 0 : h.style.maxWidth;
                    }
                    setMaxWidth(h) {
                        return this.options.maxWidth = h, this._update(), this;
                    }
                    setDOMContent(h) {
                        if (this._content) for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
                        else this._content = de.create("div", "maplibregl-popup-content", this._container);
                        return this._content.appendChild(h), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
                    }
                    addClassName(h) {
                        return this._container && this._container.classList.add(h), this;
                    }
                    removeClassName(h) {
                        return this._container && this._container.classList.remove(h), this;
                    }
                    setOffset(h) {
                        return this.options.offset = h, this._update(), this;
                    }
                    toggleClassName(h) {
                        if (this._container) return this._container.classList.toggle(h);
                    }
                    setSubpixelPositioning(h) {
                        this.options.subpixelPositioning = h;
                    }
                    _createCloseButton() {
                        this.options.closeButton && (this._closeButton = de.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
                    }
                    _focusFirstElement() {
                        if (!this.options.focusAfterOpen || !this._container) return;
                        const h = this._container.querySelector(rl);
                        h && h.focus();
                    }
                }, M.RasterDEMTileSource = pn, M.RasterTileSource = Gi, M.ScaleControl = class {
                    constructor(h) {
                        this._onMove = () => {
                            qn(this._map, this._container, this.options);
                        }, this.setUnit = (e) => {
                            this.options.unit = e, qn(this._map, this._container, this.options);
                        }, this.options = Object.assign(Object.assign({}, Gn), h);
                    }
                    getDefaultPosition() {
                        return "bottom-left";
                    }
                    onAdd(h) {
                        return this._map = h, this._container = de.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", h.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
                    }
                    onRemove() {
                        de.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
                    }
                }, M.ScrollZoomHandler = rt, M.Style = To, M.TerrainControl = class {
                    constructor(h) {
                        this._toggleTerrain = () => {
                            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
                        }, this._updateTerrainIcon = () => {
                            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
                        }, this.options = h;
                    }
                    onAdd(h) {
                        return this._map = h, this._container = de.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = de.create("button", "maplibregl-ctrl-terrain", this._container), de.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
                    }
                    onRemove() {
                        de.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
                    }
                }, M.TwoFingersTouchPitchHandler = Gs, M.TwoFingersTouchRotateHandler = Le, M.TwoFingersTouchZoomHandler = Ka, M.TwoFingersTouchZoomRotateHandler = Yo, M.VectorTileSource = Or, M.VideoSource = fr, M.addSourceType = (h, e) => c._(void 0, void 0, void 0, function* () {
                    if (Sr(h)) throw new Error(`A source type called "${h}" already exists.`);
                    ((i, s) => {
                        ia[i] = s;
                    })(h, e);
                }), M.clearPrewarmedResources = function () {
                    const h = er;
                    h && (h.isPreloaded() && h.numActive() === 1 ? (h.release(Ta), er = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
                }, M.createTileMesh = wn, M.getMaxParallelImageRequests = function () {
                    return c.a.MAX_PARALLEL_IMAGE_REQUESTS;
                }, M.getRTLTextPluginStatus = function () {
                    return Tr().getRTLTextPluginStatus();
                }, M.getVersion = function () {
                    return al;
                }, M.getWorkerCount = function () {
                    return Qi.workerCount;
                }, M.getWorkerUrl = function () {
                    return c.a.WORKER_URL;
                }, M.importScriptInWorkers = function (h) {
                    return Pa().broadcast("IS", h);
                }, M.prewarm = function () {
                    Nr().acquire(Ta);
                }, M.setMaxParallelImageRequests = function (h) {
                    c.a.MAX_PARALLEL_IMAGE_REQUESTS = h;
                }, M.setRTLTextPlugin = function (h, e) {
                    return Tr().setRTLTextPlugin(h, e);
                }, M.setWorkerCount = function (h) {
                    Qi.workerCount = h;
                }, M.setWorkerUrl = function (h) {
                    c.a.WORKER_URL = h;
                };
            });
            var Te = j;
            return Te;
        });
    }(Hc)), Hc.exports;
}
var qm = Gm();
const Sd = /* @__PURE__ */ Vm(qm), Rl = (Q) => {
    const E = Q.match(/\/([^/]+)\/([^/]*$)/);
    if (E && E.length >= 3) {
        let j;
        switch (E[1]) {
            case "time": {
                j = "a";
                break;
            }
            case "geolunit": {
                j = "g";
                break;
            }
            case "tect": {
                j = "t";
                break;
            }
            case "lith": {
                j = "l";
                break;
            }
            case "fault": {
                j = "f";
                break;
            }
            case "minres": {
                j = "m";
                break;
            }
            case "mineral": {
                j = "i";
                break;
            }
            default:
                j = "";
        }
        return j + E[2];
    } else
        return null;
}, Hm = (Q) => {
    const E = [];
    for (const j of Q) {
        const K = Rl(j);
        K && E.push(K);
    }
    return E;
}, Wm = (Q) => {
    const E = Q.match(/\/([^/]+)\/([^/]*$)/);
    if (E && E.length >= 3)
        switch (E[1]) {
            case "geolunit":
            case "tect":
            case "lith":
            case "time":
                return "geologic-units";
            case "fault":
                return "tectonic-lines";
            case "minres":
                return "mineral-resources";
            case "mineral":
                return "minerals";
            default:
                return null;
        }
    else
        return null;
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Xm = (Q) => Q.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Km = { CHILD: 2 }, Ym = (Q) => (...E) => ({ _$litDirective$: Q, values: E });
class Jm {
    constructor(E) {
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AT(E, j, K) {
        this._$Ct = E, this._$AM = j, this._$Ci = K;
    }
    _$AS(E, j) {
        return this.update(E, j);
    }
    update(E, j) {
        return this.render(...j);
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Al = (Q, E) => {
    var K;
    const j = Q._$AN;
    if (j === void 0) return !1;
    for (const se of j) (K = se._$AO) == null || K.call(se, E, !1), Al(se, E);
    return !0;
}, Kc = (Q) => {
    let E, j;
    do {
        if ((E = Q._$AM) === void 0) break;
        j = E._$AN, j.delete(Q), Q = E;
    } while ((j == null ? void 0 : j.size) === 0);
}, Rd = (Q) => {
    for (let E; E = Q._$AM; Q = E) {
        let j = E._$AN;
        if (j === void 0) E._$AN = j = /* @__PURE__ */ new Set();
        else if (j.has(Q)) break;
        j.add(Q), tg(E);
    }
};
function Qm(Q) {
    this._$AN !== void 0 ? (Kc(this), this._$AM = Q, Rd(this)) : this._$AM = Q;
}
function eg(Q, E = !1, j = 0) {
    const K = this._$AH, se = this._$AN;
    if (se !== void 0 && se.size !== 0) if (E) if (Array.isArray(K)) for (let Te = j; Te < K.length; Te++) Al(K[Te], !1), Kc(K[Te]);
    else K != null && (Al(K, !1), Kc(K));
    else Al(this, Q);
}
const tg = (Q) => {
    Q.type == Km.CHILD && (Q._$AP ?? (Q._$AP = eg), Q._$AQ ?? (Q._$AQ = Qm));
};
class ig extends Jm {
    constructor() {
        super(...arguments), this._$AN = void 0;
    }
    _$AT(E, j, K) {
        super._$AT(E, j, K), Rd(this), this.isConnected = E._$AU;
    }
    _$AO(E, j = !0) {
        var K, se;
        E !== this.isConnected && (this.isConnected = E, E ? (K = this.reconnected) == null || K.call(this) : (se = this.disconnected) == null || se.call(this)), j && (Al(this, E), Kc(this));
    }
    setValue(E) {
        if (Xm(this._$Ct)) this._$Ct._$AI(E, this);
        else {
            const j = [...this._$Ct._$AH];
            j[this._$Ci] = E, this._$Ct._$AI(j, this, 0);
        }
    }
    disconnected() {
    }
    reconnected() {
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const rg = () => new ag();
class ag {
}
const bu = /* @__PURE__ */ new WeakMap(), ng = Ym(class extends ig {
    render(Q) {
        return oi;
    }
    update(Q, [E]) {
        var K;
        const j = E !== this.G;
        return j && this.G !== void 0 && this.rt(void 0), (j || this.lt !== this.ct) && (this.G = E, this.ht = (K = Q.options) == null ? void 0 : K.host, this.rt(this.ct = Q.element)), oi;
    }
    rt(Q) {
        if (this.isConnected || (Q = void 0), typeof this.G == "function") {
            const E = this.ht ?? globalThis;
            let j = bu.get(E);
            j === void 0 && (j = /* @__PURE__ */ new WeakMap(), bu.set(E, j)), j.get(this.G) !== void 0 && this.G.call(this.ht, void 0), j.set(this.G, Q), Q !== void 0 && this.G.call(this.ht, Q);
        } else this.G.value = Q;
    }
    get lt() {
        var Q, E;
        return typeof this.G == "function" ? (Q = bu.get(this.ht ?? globalThis)) == null ? void 0 : Q.get(this.G) : (E = this.G) == null ? void 0 : E.value;
    }
    disconnected() {
        this.lt === this.ct && this.rt(void 0);
    }
    reconnected() {
        this.rt(this.ct);
    }
}), sg = 8, og = { protomaps: { type: "vector", attribution: '<a href="https://github.com/protomaps/basemaps">Protomaps</a> Â© <a href="https://openstreetmap.org">OpenStreetMap</a>', tiles: ["https://webgis.geoinformation.dev/martin/planet_z10/{z}/{x}/{y}"] } }, lg = /* @__PURE__ */ JSON.parse('[{"id":"background","type":"background","paint":{"background-color":"#ffffff"}},{"id":"earth","type":"fill","filter":["==","$type","Polygon"],"source":"protomaps","source-layer":"earth","paint":{"fill-color":"#ffffff"}},{"id":"landuse_park","type":"fill","source":"protomaps","source-layer":"landuse","filter":["in","kind","national_park","park","cemetery","protected_area","nature_reserve","forest","golf_course","wood","nature_reserve","forest","scrub","grassland","grass","military","naval_base","airfield"],"paint":{"fill-opacity":["interpolate",["linear"],["zoom"],6,0,11,1],"fill-color":["case",["in",["get","kind"],["literal",["national_park","park","cemetery","protected_area","nature_reserve","forest","golf_course"]]],"#fcfcfc",["in",["get","kind"],["literal",["wood","nature_reserve","forest"]]],"#fafafa",["in",["get","kind"],["literal",["scrub","grassland","grass"]]],"#fafafa",["in",["get","kind"],["literal",["glacier"]]],"#fcfcfc",["in",["get","kind"],["literal",["sand"]]],"#fafafa",["in",["get","kind"],["literal",["military","naval_base","airfield"]]],"#f7f7f7","#ffffff"]}},{"id":"landuse_urban_green","type":"fill","source":"protomaps","source-layer":"landuse","filter":["in","kind","allotments","village_green","playground"],"paint":{"fill-color":"#fcfcfc","fill-opacity":0.7}},{"id":"landuse_hospital","type":"fill","source":"protomaps","source-layer":"landuse","filter":["==","kind","hospital"],"paint":{"fill-color":"#f8f8f8"}},{"id":"landuse_industrial","type":"fill","source":"protomaps","source-layer":"landuse","filter":["==","kind","industrial"],"paint":{"fill-color":"#fcfcfc"}},{"id":"landuse_school","type":"fill","source":"protomaps","source-layer":"landuse","filter":["in","kind","school","university","college"],"paint":{"fill-color":"#f8f8f8"}},{"id":"landuse_beach","type":"fill","source":"protomaps","source-layer":"landuse","filter":["in","kind","beach"],"paint":{"fill-color":"#f6f6f6"}},{"id":"landuse_zoo","type":"fill","source":"protomaps","source-layer":"landuse","filter":["in","kind","zoo"],"paint":{"fill-color":"#f7f7f7"}},{"id":"landuse_aerodrome","type":"fill","source":"protomaps","source-layer":"landuse","filter":["in","kind","aerodrome"],"paint":{"fill-color":"#fdfdfd"}},{"id":"roads_runway","type":"line","source":"protomaps","source-layer":"roads","filter":["==","kind_detail","runway"],"paint":{"line-color":"#efefef","line-width":["interpolate",["exponential",1.6],["zoom"],10,0,12,4,18,30]}},{"id":"roads_taxiway","type":"line","source":"protomaps","source-layer":"roads","minzoom":13,"filter":["==","kind_detail","taxiway"],"paint":{"line-color":"#efefef","line-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1,15,6]}},{"id":"landuse_runway","type":"fill","source":"protomaps","source-layer":"landuse","filter":["any",["in","kind","runway","taxiway"]],"paint":{"fill-color":"#efefef"}},{"id":"water","type":"fill","filter":["==","$type","Polygon"],"source":"protomaps","source-layer":"water","paint":{"fill-color":"#dcdcdc"}},{"id":"water_stream","type":"line","source":"protomaps","source-layer":"water","minzoom":14,"filter":["in","kind","stream"],"paint":{"line-color":"#dcdcdc","line-width":0.5}},{"id":"water_river","type":"line","source":"protomaps","source-layer":"water","minzoom":9,"filter":["in","kind","river"],"paint":{"line-color":"#dcdcdc","line-width":["interpolate",["exponential",1.6],["zoom"],9,0,9.5,1,18,12]}},{"id":"landuse_pedestrian","type":"fill","source":"protomaps","source-layer":"landuse","filter":["==","kind","pedestrian"],"paint":{"fill-color":"#fdfdfd"}},{"id":"landuse_pier","type":"fill","source":"protomaps","source-layer":"landuse","filter":["==","kind","pier"],"paint":{"fill-color":"#efefef"}},{"id":"roads_tunnels_other_casing","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["in","kind","other","path"]],"paint":{"line-color":"#d6d6d6","line-gap-width":["interpolate",["exponential",1.6],["zoom"],14,0,20,7]}},{"id":"roads_tunnels_minor_casing","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["==","kind","minor_road"]],"paint":{"line-color":"#fcfcfc","line-dasharray":[3,2],"line-gap-width":["interpolate",["exponential",1.6],["zoom"],11,0,12.5,0.5,15,2,18,11],"line-width":["interpolate",["exponential",1.6],["zoom"],12,0,12.5,1]}},{"id":"roads_tunnels_link_casing","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["has","is_link"]],"paint":{"line-color":"#fcfcfc","line-dasharray":[3,2],"line-gap-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1,18,11],"line-width":["interpolate",["exponential",1.6],["zoom"],12,0,12.5,1]}},{"id":"roads_tunnels_major_casing","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","major_road"]],"paint":{"line-color":"#fcfcfc","line-dasharray":[3,2],"line-gap-width":["interpolate",["exponential",1.6],["zoom"],7,0,7.5,0.5,18,13],"line-width":["interpolate",["exponential",1.6],["zoom"],9,0,9.5,1]}},{"id":"roads_tunnels_highway_casing","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","highway"],["!has","is_link"]],"paint":{"line-color":"#fcfcfc","line-dasharray":[6,0.5],"line-gap-width":["interpolate",["exponential",1.6],["zoom"],3,0,3.5,0.5,18,15],"line-width":["interpolate",["exponential",1.6],["zoom"],7,0,7.5,1,20,15]}},{"id":"roads_tunnels_other","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["in","kind","other","path"]],"paint":{"line-color":"#d6d6d6","line-dasharray":[4.5,0.5],"line-width":["interpolate",["exponential",1.6],["zoom"],14,0,20,7]}},{"id":"roads_tunnels_minor","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["==","kind","minor_road"]],"paint":{"line-color":"#d6d6d6","line-width":["interpolate",["exponential",1.6],["zoom"],11,0,12.5,0.5,15,2,18,11]}},{"id":"roads_tunnels_link","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["has","is_link"]],"paint":{"line-color":"#d6d6d6","line-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1,18,11]}},{"id":"roads_tunnels_major","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["==","kind","major_road"]],"paint":{"line-color":"#d6d6d6","line-width":["interpolate",["exponential",1.6],["zoom"],6,0,12,1.6,15,3,18,13]}},{"id":"roads_tunnels_highway","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["==",["get","kind"],"highway"],["!",["has","is_link"]]],"paint":{"line-color":"#d6d6d6","line-width":["interpolate",["exponential",1.6],["zoom"],3,0,6,1.1,12,1.6,15,5,18,15]}},{"id":"buildings","type":"fill","source":"protomaps","source-layer":"buildings","paint":{"fill-color":"#efefef","fill-opacity":0.5}},{"id":"roads_pier","type":"line","source":"protomaps","source-layer":"roads","filter":["==","kind_detail","pier"],"paint":{"line-color":"#efefef","line-width":["interpolate",["exponential",1.6],["zoom"],12,0,12.5,0.5,20,16]}},{"id":"roads_minor_service_casing","type":"line","source":"protomaps","source-layer":"roads","minzoom":13,"filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","minor_road"],["==","kind_detail","service"]],"paint":{"line-color":"#ffffff","line-gap-width":["interpolate",["exponential",1.6],["zoom"],13,0,18,8],"line-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,0.8]}},{"id":"roads_minor_casing","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","minor_road"],["!=","kind_detail","service"]],"paint":{"line-color":"#ffffff","line-gap-width":["interpolate",["exponential",1.6],["zoom"],11,0,12.5,0.5,15,2,18,11],"line-width":["interpolate",["exponential",1.6],["zoom"],12,0,12.5,1]}},{"id":"roads_link_casing","type":"line","source":"protomaps","source-layer":"roads","minzoom":13,"filter":["has","is_link"],"paint":{"line-color":"#ffffff","line-gap-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1,18,11],"line-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1.5]}},{"id":"roads_major_casing_late","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","major_road"]],"paint":{"line-color":"#ffffff","line-gap-width":["interpolate",["exponential",1.6],["zoom"],6,0,12,1.6,15,3,18,13],"line-width":["interpolate",["exponential",1.6],["zoom"],9,0,9.5,1]}},{"id":"roads_highway_casing_late","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","highway"],["!has","is_link"]],"paint":{"line-color":"#ffffff","line-gap-width":["interpolate",["exponential",1.6],["zoom"],3,0,3.5,0.5,18,15],"line-width":["interpolate",["exponential",1.6],["zoom"],7,0,7.5,1,20,15]}},{"id":"roads_other","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["in","kind","other","path"],["!=","kind_detail","pier"]],"paint":{"line-color":"#f5f5f5","line-dasharray":[3,1],"line-width":["interpolate",["exponential",1.6],["zoom"],14,0,20,7]}},{"id":"roads_link","type":"line","source":"protomaps","source-layer":"roads","filter":["has","is_link"],"paint":{"line-color":"#ebebeb","line-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1,18,11]}},{"id":"roads_minor_service","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","minor_road"],["==","kind_detail","service"]],"paint":{"line-color":"#f5f5f5","line-width":["interpolate",["exponential",1.6],["zoom"],13,0,18,8]}},{"id":"roads_minor","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","minor_road"],["!=","kind_detail","service"]],"paint":{"line-color":["interpolate",["exponential",1.6],["zoom"],11,"#ebebeb",16,"#f5f5f5"],"line-width":["interpolate",["exponential",1.6],["zoom"],11,0,12.5,0.5,15,2,18,11]}},{"id":"roads_major_casing_early","type":"line","source":"protomaps","source-layer":"roads","maxzoom":12,"filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","major_road"]],"paint":{"line-color":"#ffffff","line-gap-width":["interpolate",["exponential",1.6],["zoom"],7,0,7.5,0.5,18,13],"line-width":["interpolate",["exponential",1.6],["zoom"],9,0,9.5,1]}},{"id":"roads_major","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","major_road"]],"paint":{"line-color":"#ebebeb","line-width":["interpolate",["exponential",1.6],["zoom"],6,0,12,1.6,15,3,18,13]}},{"id":"roads_highway_casing_early","type":"line","source":"protomaps","source-layer":"roads","maxzoom":12,"filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","highway"],["!has","is_link"]],"paint":{"line-color":"#ffffff","line-gap-width":["interpolate",["exponential",1.6],["zoom"],3,0,3.5,0.5,18,15],"line-width":["interpolate",["exponential",1.6],["zoom"],7,0,7.5,1]}},{"id":"roads_highway","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","highway"],["!has","is_link"]],"paint":{"line-color":"#ebebeb","line-width":["interpolate",["exponential",1.6],["zoom"],3,0,6,1.1,12,1.6,15,5,18,15]}},{"id":"roads_rail","type":"line","source":"protomaps","source-layer":"roads","filter":["==","kind","rail"],"paint":{"line-dasharray":[0.3,0.75],"line-opacity":0.5,"line-color":"#d6d6d6","line-width":["interpolate",["exponential",1.6],["zoom"],3,0,6,0.15,18,9]}},{"id":"boundaries_country","type":"line","source":"protomaps","source-layer":"boundaries","filter":["<=","kind_detail",2],"paint":{"line-color":"#adadad","line-width":0.7,"line-dasharray":["step",["zoom"],["literal",[2]],4,["literal",[2,1]]]}},{"id":"boundaries","type":"line","source":"protomaps","source-layer":"boundaries","filter":[">","kind_detail",2],"paint":{"line-color":"#adadad","line-width":0.4,"line-dasharray":["step",["zoom"],["literal",[2]],4,["literal",[2,1]]]}},{"id":"roads_bridges_other_casing","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["in","kind","other","path"]],"paint":{"line-color":"#ffffff","line-gap-width":["interpolate",["exponential",1.6],["zoom"],14,0,20,7]}},{"id":"roads_bridges_link_casing","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["has","is_link"]],"paint":{"line-color":"#ffffff","line-gap-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1,18,11],"line-width":["interpolate",["exponential",1.6],["zoom"],12,0,12.5,1.5]}},{"id":"roads_bridges_minor_casing","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["==","kind","minor_road"]],"paint":{"line-color":"#ffffff","line-gap-width":["interpolate",["exponential",1.6],["zoom"],11,0,12.5,0.5,15,2,18,11],"line-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,0.8]}},{"id":"roads_bridges_major_casing","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["==","kind","major_road"]],"paint":{"line-color":"#ffffff","line-gap-width":["interpolate",["exponential",1.6],["zoom"],7,0,7.5,0.5,18,10],"line-width":["interpolate",["exponential",1.6],["zoom"],9,0,9.5,1.5]}},{"id":"roads_bridges_other","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["in","kind","other","path"]],"paint":{"line-color":"#f5f5f5","line-dasharray":[2,1],"line-width":["interpolate",["exponential",1.6],["zoom"],14,0,20,7]}},{"id":"roads_bridges_minor","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["==","kind","minor_road"]],"paint":{"line-color":"#f5f5f5","line-width":["interpolate",["exponential",1.6],["zoom"],11,0,12.5,0.5,15,2,18,11]}},{"id":"roads_bridges_link","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["has","is_link"]],"paint":{"line-color":"#f5f5f5","line-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1,18,11]}},{"id":"roads_bridges_major","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["==","kind","major_road"]],"paint":{"line-color":"#ebebeb","line-width":["interpolate",["exponential",1.6],["zoom"],6,0,12,1.6,15,3,18,13]}},{"id":"roads_bridges_highway_casing","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["==","kind","highway"],["!has","is_link"]],"paint":{"line-color":"#ffffff","line-gap-width":["interpolate",["exponential",1.6],["zoom"],3,0,3.5,0.5,18,15],"line-width":["interpolate",["exponential",1.6],["zoom"],7,0,7.5,1,20,15]}},{"id":"roads_bridges_highway","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_bridge"],["==","kind","highway"],["!has","is_link"]],"paint":{"line-color":"#ebebeb","line-width":["interpolate",["exponential",1.6],["zoom"],3,0,6,1.1,12,1.6,15,5,18,15]}},{"id":"water_waterway_label","type":"symbol","source":"protomaps","source-layer":"water","minzoom":13,"filter":["in","kind","river","stream"],"layout":{"symbol-placement":"line","text-font":["Noto Sans Italic"],"text-field":["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]],"text-size":12,"text-letter-spacing":0.2},"paint":{"text-color":"#adadad","text-halo-color":"#dcdcdc","text-halo-width":1}},{"id":"roads_labels_minor","type":"symbol","source":"protomaps","source-layer":"roads","minzoom":15,"filter":["in","kind","minor_road","other","path"],"layout":{"symbol-sort-key":["get","min_zoom"],"symbol-placement":"line","text-font":["Noto Sans Regular"],"text-field":["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]],"text-size":12},"paint":{"text-color":"#adadad","text-halo-color":"#ffffff","text-halo-width":1}},{"id":"water_label_ocean","type":"symbol","source":"protomaps","source-layer":"water","filter":["in","kind","sea","ocean","bay","strait","fjord"],"layout":{"text-font":["Noto Sans Italic"],"text-field":["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]],"text-size":["interpolate",["linear"],["zoom"],3,10,10,12],"text-letter-spacing":0.1,"text-max-width":9,"text-transform":"uppercase"},"paint":{"text-color":"#adadad","text-halo-width":1,"text-halo-color":"#dcdcdc"}},{"id":"water_label_lakes","type":"symbol","source":"protomaps","source-layer":"water","filter":["in","kind","lake","water"],"layout":{"text-font":["Noto Sans Italic"],"text-field":["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]],"text-size":["interpolate",["linear"],["zoom"],3,10,6,12,10,12],"text-letter-spacing":0.1,"text-max-width":9},"paint":{"text-color":"#adadad","text-halo-color":"#dcdcdc","text-halo-width":1}},{"id":"roads_labels_major","type":"symbol","source":"protomaps","source-layer":"roads","minzoom":11,"filter":["in","kind","highway","major_road"],"layout":{"symbol-sort-key":["get","min_zoom"],"symbol-placement":"line","text-font":["Noto Sans Regular"],"text-field":["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]],"text-size":12},"paint":{"text-color":"#999999","text-halo-color":"#ffffff","text-halo-width":1}},{"id":"places_subplace","type":"symbol","source":"protomaps","source-layer":"places","filter":["==","kind","neighbourhood"],"layout":{"symbol-sort-key":["get","min_zoom"],"text-field":["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]],"text-font":["Noto Sans Regular"],"text-max-width":7,"text-letter-spacing":0.1,"text-padding":["interpolate",["linear"],["zoom"],5,2,8,4,12,18,15,20],"text-size":["interpolate",["exponential",1.2],["zoom"],11,8,14,14,18,24],"text-transform":"uppercase"},"paint":{"text-color":"#8f8f8f","text-halo-color":"#ffffff","text-halo-width":1}},{"id":"places_locality","type":"symbol","source":"protomaps","source-layer":"places","filter":["==","kind","locality"],"layout":{"icon-image":["step",["zoom"],"townspot",8,""],"icon-size":0.7,"text-field":["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]],"text-font":["case",["<=",["get","min_zoom"],5],["literal",["Noto Sans Medium"]],["literal",["Noto Sans Regular"]]],"text-padding":["interpolate",["linear"],["zoom"],5,3,8,7,12,11],"text-size":["interpolate",["linear"],["zoom"],2,["case",["<",["get","population_rank"],13],8,[">=",["get","population_rank"],13],13,0],4,["case",["<",["get","population_rank"],13],10,[">=",["get","population_rank"],13],15,0],6,["case",["<",["get","population_rank"],12],11,[">=",["get","population_rank"],12],17,0],8,["case",["<",["get","population_rank"],11],11,[">=",["get","population_rank"],11],18,0],10,["case",["<",["get","population_rank"],9],12,[">=",["get","population_rank"],9],20,0],15,["case",["<",["get","population_rank"],8],12,[">=",["get","population_rank"],8],22,0]],"icon-padding":["interpolate",["linear"],["zoom"],0,0,8,4,10,8,12,6,22,2],"text-justify":"auto","text-anchor":["step",["zoom"],"left",8,"center"],"text-radial-offset":0.4},"paint":{"text-color":"#5c5c5c","text-halo-color":"#ffffff","text-halo-width":1}},{"id":"places_region","type":"symbol","source":"protomaps","source-layer":"places","filter":["==","kind","region"],"layout":{"symbol-sort-key":["get","min_zoom"],"text-field":["step",["zoom"],["get","name:short"],6,["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]]],"text-font":["Noto Sans Regular"],"text-size":["interpolate",["linear"],["zoom"],3,11,7,16],"text-radial-offset":0.2,"text-anchor":"center","text-transform":"uppercase"},"paint":{"text-color":"#b3b3b3","text-halo-color":"#ffffff","text-halo-width":1}},{"id":"places_country","type":"symbol","source":"protomaps","source-layer":"places","filter":["==","kind","country"],"layout":{"symbol-sort-key":["get","min_zoom"],"text-field":["format",["coalesce",["get","name:en"],["get","name:en"]],{}],"text-font":["Noto Sans Medium"],"text-size":["interpolate",["linear"],["zoom"],2,["case",["<",["get","population_rank"],10],8,[">=",["get","population_rank"],10],12,0],6,["case",["<",["get","population_rank"],8],10,[">=",["get","population_rank"],8],18,0],8,["case",["<",["get","population_rank"],7],11,[">=",["get","population_rank"],7],20,0]],"icon-padding":["interpolate",["linear"],["zoom"],0,2,14,2,16,20,17,2,22,2],"text-transform":"uppercase"},"paint":{"text-color":"#b8b8b8","text-halo-color":"#ffffff","text-halo-width":1}}]'), cg = "https://protomaps.github.io/basemaps-assets/sprites/v4/white", hg = "https://protomaps.github.io/basemaps-assets/fonts/{fontstack}/{range}.pbf", ug = {
    version: sg,
    sources: og,
    layers: lg,
    sprite: cg,
    glyphs: hg
}, pg = 8, dg = { protomaps: { type: "vector", attribution: '<a href="https://github.com/protomaps/basemaps">Protomaps</a> Â© <a href="https://openstreetmap.org">OpenStreetMap</a>', tiles: ["https://webgis.geoinformation.dev/martin/planet_z10/{z}/{x}/{y}"] } }, fg = /* @__PURE__ */ JSON.parse('[{"id":"background","type":"background","paint":{"background-color":"#2b2b2b"}},{"id":"earth","type":"fill","filter":["==","$type","Polygon"],"source":"protomaps","source-layer":"earth","paint":{"fill-color":"#141414"}},{"id":"landuse_park","type":"fill","source":"protomaps","source-layer":"landuse","filter":["in","kind","national_park","park","cemetery","protected_area","nature_reserve","forest","golf_course","wood","nature_reserve","forest","scrub","grassland","grass","military","naval_base","airfield"],"paint":{"fill-opacity":["interpolate",["linear"],["zoom"],6,0,11,1],"fill-color":["case",["in",["get","kind"],["literal",["national_park","park","cemetery","protected_area","nature_reserve","forest","golf_course"]]],"#181818",["in",["get","kind"],["literal",["wood","nature_reserve","forest"]]],"#1a1a1a",["in",["get","kind"],["literal",["scrub","grassland","grass"]]],"#1c1c1c",["in",["get","kind"],["literal",["glacier"]]],"#191919",["in",["get","kind"],["literal",["sand"]]],"#161616",["in",["get","kind"],["literal",["military","naval_base","airfield"]]],"#191919","#141414"]}},{"id":"landuse_urban_green","type":"fill","source":"protomaps","source-layer":"landuse","filter":["in","kind","allotments","village_green","playground"],"paint":{"fill-color":"#181818","fill-opacity":0.7}},{"id":"landuse_hospital","type":"fill","source":"protomaps","source-layer":"landuse","filter":["==","kind","hospital"],"paint":{"fill-color":"#1d1d1d"}},{"id":"landuse_industrial","type":"fill","source":"protomaps","source-layer":"landuse","filter":["==","kind","industrial"],"paint":{"fill-color":"#101010"}},{"id":"landuse_school","type":"fill","source":"protomaps","source-layer":"landuse","filter":["in","kind","school","university","college"],"paint":{"fill-color":"#111111"}},{"id":"landuse_beach","type":"fill","source":"protomaps","source-layer":"landuse","filter":["in","kind","beach"],"paint":{"fill-color":"#1f1f1f"}},{"id":"landuse_zoo","type":"fill","source":"protomaps","source-layer":"landuse","filter":["in","kind","zoo"],"paint":{"fill-color":"#191919"}},{"id":"landuse_aerodrome","type":"fill","source":"protomaps","source-layer":"landuse","filter":["in","kind","aerodrome"],"paint":{"fill-color":"#191919"}},{"id":"roads_runway","type":"line","source":"protomaps","source-layer":"roads","filter":["==","kind_detail","runway"],"paint":{"line-color":"#323232","line-width":["interpolate",["exponential",1.6],["zoom"],10,0,12,4,18,30]}},{"id":"roads_taxiway","type":"line","source":"protomaps","source-layer":"roads","minzoom":13,"filter":["==","kind_detail","taxiway"],"paint":{"line-color":"#323232","line-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1,15,6]}},{"id":"landuse_runway","type":"fill","source":"protomaps","source-layer":"landuse","filter":["any",["in","kind","runway","taxiway"]],"paint":{"fill-color":"#323232"}},{"id":"water","type":"fill","filter":["==","$type","Polygon"],"source":"protomaps","source-layer":"water","paint":{"fill-color":"#333333"}},{"id":"water_stream","type":"line","source":"protomaps","source-layer":"water","minzoom":14,"filter":["in","kind","stream"],"paint":{"line-color":"#333333","line-width":0.5}},{"id":"water_river","type":"line","source":"protomaps","source-layer":"water","minzoom":9,"filter":["in","kind","river"],"paint":{"line-color":"#333333","line-width":["interpolate",["exponential",1.6],["zoom"],9,0,9.5,1,18,12]}},{"id":"landuse_pedestrian","type":"fill","source":"protomaps","source-layer":"landuse","filter":["==","kind","pedestrian"],"paint":{"fill-color":"#191919"}},{"id":"landuse_pier","type":"fill","source":"protomaps","source-layer":"landuse","filter":["==","kind","pier"],"paint":{"fill-color":"#0a0a0a"}},{"id":"roads_tunnels_other_casing","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["in","kind","other","path"]],"paint":{"line-color":"#101010","line-gap-width":["interpolate",["exponential",1.6],["zoom"],14,0,20,7]}},{"id":"roads_tunnels_minor_casing","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["==","kind","minor_road"]],"paint":{"line-color":"#101010","line-dasharray":[3,2],"line-gap-width":["interpolate",["exponential",1.6],["zoom"],11,0,12.5,0.5,15,2,18,11],"line-width":["interpolate",["exponential",1.6],["zoom"],12,0,12.5,1]}},{"id":"roads_tunnels_link_casing","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["has","is_link"]],"paint":{"line-color":"#101010","line-dasharray":[3,2],"line-gap-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1,18,11],"line-width":["interpolate",["exponential",1.6],["zoom"],12,0,12.5,1]}},{"id":"roads_tunnels_major_casing","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","major_road"]],"paint":{"line-color":"#101010","line-dasharray":[3,2],"line-gap-width":["interpolate",["exponential",1.6],["zoom"],7,0,7.5,0.5,18,13],"line-width":["interpolate",["exponential",1.6],["zoom"],9,0,9.5,1]}},{"id":"roads_tunnels_highway_casing","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","highway"],["!has","is_link"]],"paint":{"line-color":"#101010","line-dasharray":[6,0.5],"line-gap-width":["interpolate",["exponential",1.6],["zoom"],3,0,3.5,0.5,18,15],"line-width":["interpolate",["exponential",1.6],["zoom"],7,0,7.5,1,20,15]}},{"id":"roads_tunnels_other","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["in","kind","other","path"]],"paint":{"line-color":"#292929","line-dasharray":[4.5,0.5],"line-width":["interpolate",["exponential",1.6],["zoom"],14,0,20,7]}},{"id":"roads_tunnels_minor","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["==","kind","minor_road"]],"paint":{"line-color":"#292929","line-width":["interpolate",["exponential",1.6],["zoom"],11,0,12.5,0.5,15,2,18,11]}},{"id":"roads_tunnels_link","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["has","is_link"]],"paint":{"line-color":"#292929","line-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1,18,11]}},{"id":"roads_tunnels_major","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["==","kind","major_road"]],"paint":{"line-color":"#292929","line-width":["interpolate",["exponential",1.6],["zoom"],6,0,12,1.6,15,3,18,13]}},{"id":"roads_tunnels_highway","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_tunnel"],["==",["get","kind"],"highway"],["!",["has","is_link"]]],"paint":{"line-color":"#292929","line-width":["interpolate",["exponential",1.6],["zoom"],3,0,6,1.1,12,1.6,15,5,18,15]}},{"id":"buildings","type":"fill","source":"protomaps","source-layer":"buildings","paint":{"fill-color":"#0a0a0a","fill-opacity":0.5}},{"id":"roads_pier","type":"line","source":"protomaps","source-layer":"roads","filter":["==","kind_detail","pier"],"paint":{"line-color":"#0a0a0a","line-width":["interpolate",["exponential",1.6],["zoom"],12,0,12.5,0.5,20,16]}},{"id":"roads_minor_service_casing","type":"line","source":"protomaps","source-layer":"roads","minzoom":13,"filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","minor_road"],["==","kind_detail","service"]],"paint":{"line-color":"#141414","line-gap-width":["interpolate",["exponential",1.6],["zoom"],13,0,18,8],"line-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,0.8]}},{"id":"roads_minor_casing","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","minor_road"],["!=","kind_detail","service"]],"paint":{"line-color":"#141414","line-gap-width":["interpolate",["exponential",1.6],["zoom"],11,0,12.5,0.5,15,2,18,11],"line-width":["interpolate",["exponential",1.6],["zoom"],12,0,12.5,1]}},{"id":"roads_link_casing","type":"line","source":"protomaps","source-layer":"roads","minzoom":13,"filter":["has","is_link"],"paint":{"line-color":"#141414","line-gap-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1,18,11],"line-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1.5]}},{"id":"roads_major_casing_late","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","major_road"]],"paint":{"line-color":"#141414","line-gap-width":["interpolate",["exponential",1.6],["zoom"],6,0,12,1.6,15,3,18,13],"line-width":["interpolate",["exponential",1.6],["zoom"],9,0,9.5,1]}},{"id":"roads_highway_casing_late","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","highway"],["!has","is_link"]],"paint":{"line-color":"#141414","line-gap-width":["interpolate",["exponential",1.6],["zoom"],3,0,3.5,0.5,18,15],"line-width":["interpolate",["exponential",1.6],["zoom"],7,0,7.5,1,20,15]}},{"id":"roads_other","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["in","kind","other","path"],["!=","kind_detail","pier"]],"paint":{"line-color":"#1f1f1f","line-dasharray":[3,1],"line-width":["interpolate",["exponential",1.6],["zoom"],14,0,20,7]}},{"id":"roads_link","type":"line","source":"protomaps","source-layer":"roads","filter":["has","is_link"],"paint":{"line-color":"#1f1f1f","line-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1,18,11]}},{"id":"roads_minor_service","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","minor_road"],["==","kind_detail","service"]],"paint":{"line-color":"#1f1f1f","line-width":["interpolate",["exponential",1.6],["zoom"],13,0,18,8]}},{"id":"roads_minor","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","minor_road"],["!=","kind_detail","service"]],"paint":{"line-color":["interpolate",["exponential",1.6],["zoom"],11,"#292929",16,"#1f1f1f"],"line-width":["interpolate",["exponential",1.6],["zoom"],11,0,12.5,0.5,15,2,18,11]}},{"id":"roads_major_casing_early","type":"line","source":"protomaps","source-layer":"roads","maxzoom":12,"filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","major_road"]],"paint":{"line-color":"#141414","line-gap-width":["interpolate",["exponential",1.6],["zoom"],7,0,7.5,0.5,18,13],"line-width":["interpolate",["exponential",1.6],["zoom"],9,0,9.5,1]}},{"id":"roads_major","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","major_road"]],"paint":{"line-color":"#292929","line-width":["interpolate",["exponential",1.6],["zoom"],6,0,12,1.6,15,3,18,13]}},{"id":"roads_highway_casing_early","type":"line","source":"protomaps","source-layer":"roads","maxzoom":12,"filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","highway"],["!has","is_link"]],"paint":{"line-color":"#141414","line-gap-width":["interpolate",["exponential",1.6],["zoom"],3,0,3.5,0.5,18,15],"line-width":["interpolate",["exponential",1.6],["zoom"],7,0,7.5,1]}},{"id":"roads_highway","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["!has","is_tunnel"],["!has","is_bridge"],["==","kind","highway"],["!has","is_link"]],"paint":{"line-color":"#292929","line-width":["interpolate",["exponential",1.6],["zoom"],3,0,6,1.1,12,1.6,15,5,18,15]}},{"id":"roads_rail","type":"line","source":"protomaps","source-layer":"roads","filter":["==","kind","rail"],"paint":{"line-dasharray":[0.3,0.75],"line-opacity":0.5,"line-color":"#292929","line-width":["interpolate",["exponential",1.6],["zoom"],3,0,6,0.15,18,9]}},{"id":"boundaries_country","type":"line","source":"protomaps","source-layer":"boundaries","filter":["<=","kind_detail",2],"paint":{"line-color":"#707070","line-width":0.7,"line-dasharray":["step",["zoom"],["literal",[2]],4,["literal",[2,1]]]}},{"id":"boundaries","type":"line","source":"protomaps","source-layer":"boundaries","filter":[">","kind_detail",2],"paint":{"line-color":"#707070","line-width":0.4,"line-dasharray":["step",["zoom"],["literal",[2]],4,["literal",[2,1]]]}},{"id":"roads_bridges_other_casing","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["in","kind","other","path"]],"paint":{"line-color":"#141414","line-gap-width":["interpolate",["exponential",1.6],["zoom"],14,0,20,7]}},{"id":"roads_bridges_link_casing","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["has","is_link"]],"paint":{"line-color":"#141414","line-gap-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1,18,11],"line-width":["interpolate",["exponential",1.6],["zoom"],12,0,12.5,1.5]}},{"id":"roads_bridges_minor_casing","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["==","kind","minor_road"]],"paint":{"line-color":"#141414","line-gap-width":["interpolate",["exponential",1.6],["zoom"],11,0,12.5,0.5,15,2,18,11],"line-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,0.8]}},{"id":"roads_bridges_major_casing","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["==","kind","major_road"]],"paint":{"line-color":"#141414","line-gap-width":["interpolate",["exponential",1.6],["zoom"],7,0,7.5,0.5,18,10],"line-width":["interpolate",["exponential",1.6],["zoom"],9,0,9.5,1.5]}},{"id":"roads_bridges_other","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["in","kind","other","path"]],"paint":{"line-color":"#1f1f1f","line-dasharray":[2,1],"line-width":["interpolate",["exponential",1.6],["zoom"],14,0,20,7]}},{"id":"roads_bridges_minor","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["==","kind","minor_road"]],"paint":{"line-color":"#1f1f1f","line-width":["interpolate",["exponential",1.6],["zoom"],11,0,12.5,0.5,15,2,18,11]}},{"id":"roads_bridges_link","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["has","is_link"]],"paint":{"line-color":"#1f1f1f","line-width":["interpolate",["exponential",1.6],["zoom"],13,0,13.5,1,18,11]}},{"id":"roads_bridges_major","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["==","kind","major_road"]],"paint":{"line-color":"#292929","line-width":["interpolate",["exponential",1.6],["zoom"],6,0,12,1.6,15,3,18,13]}},{"id":"roads_bridges_highway_casing","type":"line","source":"protomaps","source-layer":"roads","minzoom":12,"filter":["all",["has","is_bridge"],["==","kind","highway"],["!has","is_link"]],"paint":{"line-color":"#141414","line-gap-width":["interpolate",["exponential",1.6],["zoom"],3,0,3.5,0.5,18,15],"line-width":["interpolate",["exponential",1.6],["zoom"],7,0,7.5,1,20,15]}},{"id":"roads_bridges_highway","type":"line","source":"protomaps","source-layer":"roads","filter":["all",["has","is_bridge"],["==","kind","highway"],["!has","is_link"]],"paint":{"line-color":"#292929","line-width":["interpolate",["exponential",1.6],["zoom"],3,0,6,1.1,12,1.6,15,5,18,15]}},{"id":"water_waterway_label","type":"symbol","source":"protomaps","source-layer":"water","minzoom":13,"filter":["in","kind","river","stream"],"layout":{"symbol-placement":"line","text-font":["Noto Sans Italic"],"text-field":["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]],"text-size":12,"text-letter-spacing":0.2},"paint":{"text-color":"#707070","text-halo-color":"#333333","text-halo-width":1}},{"id":"roads_labels_minor","type":"symbol","source":"protomaps","source-layer":"roads","minzoom":15,"filter":["in","kind","minor_road","other","path"],"layout":{"symbol-sort-key":["get","min_zoom"],"symbol-placement":"line","text-font":["Noto Sans Regular"],"text-field":["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]],"text-size":12},"paint":{"text-color":"#525252","text-halo-color":"#141414","text-halo-width":1}},{"id":"water_label_ocean","type":"symbol","source":"protomaps","source-layer":"water","filter":["in","kind","sea","ocean","bay","strait","fjord"],"layout":{"text-font":["Noto Sans Italic"],"text-field":["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]],"text-size":["interpolate",["linear"],["zoom"],3,10,10,12],"text-letter-spacing":0.1,"text-max-width":9,"text-transform":"uppercase"},"paint":{"text-color":"#707070","text-halo-width":1,"text-halo-color":"#333333"}},{"id":"water_label_lakes","type":"symbol","source":"protomaps","source-layer":"water","filter":["in","kind","lake","water"],"layout":{"text-font":["Noto Sans Italic"],"text-field":["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]],"text-size":["interpolate",["linear"],["zoom"],3,10,6,12,10,12],"text-letter-spacing":0.1,"text-max-width":9},"paint":{"text-color":"#707070","text-halo-color":"#333333","text-halo-width":1}},{"id":"roads_labels_major","type":"symbol","source":"protomaps","source-layer":"roads","minzoom":11,"filter":["in","kind","highway","major_road"],"layout":{"symbol-sort-key":["get","min_zoom"],"symbol-placement":"line","text-font":["Noto Sans Regular"],"text-field":["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]],"text-size":12},"paint":{"text-color":"#5c5c5c","text-halo-color":"#141414","text-halo-width":1}},{"id":"places_subplace","type":"symbol","source":"protomaps","source-layer":"places","filter":["==","kind","neighbourhood"],"layout":{"symbol-sort-key":["get","min_zoom"],"text-field":["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]],"text-font":["Noto Sans Regular"],"text-max-width":7,"text-letter-spacing":0.1,"text-padding":["interpolate",["linear"],["zoom"],5,2,8,4,12,18,15,20],"text-size":["interpolate",["exponential",1.2],["zoom"],11,8,14,14,18,24],"text-transform":"uppercase"},"paint":{"text-color":"#5c5c5c","text-halo-color":"#141414","text-halo-width":1}},{"id":"places_locality","type":"symbol","source":"protomaps","source-layer":"places","filter":["==","kind","locality"],"layout":{"icon-image":["step",["zoom"],"townspot",8,""],"icon-size":0.7,"text-field":["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]],"text-font":["case",["<=",["get","min_zoom"],5],["literal",["Noto Sans Medium"]],["literal",["Noto Sans Regular"]]],"text-padding":["interpolate",["linear"],["zoom"],5,3,8,7,12,11],"text-size":["interpolate",["linear"],["zoom"],2,["case",["<",["get","population_rank"],13],8,[">=",["get","population_rank"],13],13,0],4,["case",["<",["get","population_rank"],13],10,[">=",["get","population_rank"],13],15,0],6,["case",["<",["get","population_rank"],12],11,[">=",["get","population_rank"],12],17,0],8,["case",["<",["get","population_rank"],11],11,[">=",["get","population_rank"],11],18,0],10,["case",["<",["get","population_rank"],9],12,[">=",["get","population_rank"],9],20,0],15,["case",["<",["get","population_rank"],8],12,[">=",["get","population_rank"],8],22,0]],"icon-padding":["interpolate",["linear"],["zoom"],0,0,8,4,10,8,12,6,22,2],"text-justify":"auto","text-anchor":["step",["zoom"],"left",8,"center"],"text-radial-offset":0.4},"paint":{"text-color":"#999999","text-halo-color":"#141414","text-halo-width":1}},{"id":"places_region","type":"symbol","source":"protomaps","source-layer":"places","filter":["==","kind","region"],"layout":{"symbol-sort-key":["get","min_zoom"],"text-field":["step",["zoom"],["get","name:short"],6,["case",["all",["any",["has","name"],["has","pgf:name"]],["!",["any",["has","name2"],["has","pgf:name2"]]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["has","script"],["case",["any",["is-supported-script",["get","name"]],["has","pgf:name"]],["format",["coalesce",["get","name:en"],["get","name:en"]],{},"\\n",{},["case",["all",["!",["has","name:en"]],["has","name:en"],["!",["has","script"]]],"",["coalesce",["get","pgf:name"],["get","name"]]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["get","name:en"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{}]],["all",["any",["has","name"],["has","pgf:name"]],["any",["has","name2"],["has","pgf:name2"]],["!",["any",["has","name3"],["has","pgf:name3"]]]],["case",["all",["has","script"],["has","script2"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["has","script2"],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]],["case",["all",["has","script"],["has","script2"],["has","script3"]],["format",["get","name:en"],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["case",["!",["has","script"]],["format",["coalesce",["get","name:en"],["get","pgf:name"],["get","name"]],{},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["!",["has","script2"]],["format",["coalesce",["get","name:en"],["get","pgf:name2"],["get","name2"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name3"],["get","name3"]],{"text-font":["case",["==",["get","script3"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}],["format",["coalesce",["get","name:en"],["get","pgf:name3"],["get","name3"]],{},"\\n",{},["coalesce",["get","pgf:name"],["get","name"]],{"text-font":["case",["==",["get","script"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]},"\\n",{},["coalesce",["get","pgf:name2"],["get","name2"]],{"text-font":["case",["==",["get","script2"],"Devanagari"],["literal",["Noto Sans Devanagari Regular v1"]],["literal",["Noto Sans Regular"]]]}]]]]],"text-font":["Noto Sans Regular"],"text-size":["interpolate",["linear"],["zoom"],3,11,7,16],"text-radial-offset":0.2,"text-anchor":"center","text-transform":"uppercase"},"paint":{"text-color":"#3d3d3d","text-halo-color":"#141414","text-halo-width":1}},{"id":"places_country","type":"symbol","source":"protomaps","source-layer":"places","filter":["==","kind","country"],"layout":{"symbol-sort-key":["get","min_zoom"],"text-field":["format",["coalesce",["get","name:en"],["get","name:en"]],{}],"text-font":["Noto Sans Medium"],"text-size":["interpolate",["linear"],["zoom"],2,["case",["<",["get","population_rank"],10],8,[">=",["get","population_rank"],10],12,0],6,["case",["<",["get","population_rank"],8],10,[">=",["get","population_rank"],8],18,0],8,["case",["<",["get","population_rank"],7],11,[">=",["get","population_rank"],7],20,0]],"icon-padding":["interpolate",["linear"],["zoom"],0,2,14,2,16,20,17,2,22,2],"text-transform":"uppercase"},"paint":{"text-color":"#707070","text-halo-color":"#141414","text-halo-width":1}}]'), mg = "https://protomaps.github.io/basemaps-assets/sprites/v4/black", gg = "https://protomaps.github.io/basemaps-assets/fonts/{fontstack}/{range}.pbf", _g = {
    version: pg,
    sources: dg,
    layers: fg,
    sprite: mg,
    glyphs: gg
}, yg = Id`
  .maplibregl-map {
    font:
      12px/20px "Helvetica Neue",
      Arial,
      Helvetica,
      sans-serif;
    overflow: hidden;
    position: relative;
    -webkit-tap-highlight-color: rgb(0 0 0 / 0%);
  }

  .maplibregl-canvas {
    position: absolute;
    left: 0;
    top: 0;
  }

  .maplibregl-map:fullscreen {
    width: 100%;
    height: 100%;
  }

  .maplibregl-ctrl-group button.maplibregl-ctrl-compass {
    touch-action: none;
  }

  .maplibregl-canvas-container.maplibregl-interactive,
  .maplibregl-ctrl-group button.maplibregl-ctrl-compass {
    cursor: grab;
    user-select: none;
  }

  .maplibregl-canvas-container.maplibregl-interactive.maplibregl-track-pointer {
    cursor: pointer;
  }

  .maplibregl-canvas-container.maplibregl-interactive:active,
  .maplibregl-ctrl-group button.maplibregl-ctrl-compass:active {
    cursor: grabbing;
  }

  .maplibregl-canvas-container.maplibregl-touch-zoom-rotate,
  .maplibregl-canvas-container.maplibregl-touch-zoom-rotate .maplibregl-canvas {
    touch-action: pan-x pan-y;
  }

  .maplibregl-canvas-container.maplibregl-touch-drag-pan,
  .maplibregl-canvas-container.maplibregl-touch-drag-pan .maplibregl-canvas {
    touch-action: pinch-zoom;
  }

  .maplibregl-canvas-container.maplibregl-touch-zoom-rotate.maplibregl-touch-drag-pan,
  .maplibregl-canvas-container.maplibregl-touch-zoom-rotate.maplibregl-touch-drag-pan
    .maplibregl-canvas {
    touch-action: none;
  }

  .maplibregl-canvas-container.maplibregl-touch-drag-pan.maplibregl-cooperative-gestures,
  .maplibregl-canvas-container.maplibregl-touch-drag-pan.maplibregl-cooperative-gestures
    .maplibregl-canvas {
    touch-action: pan-x pan-y;
  }

  .maplibregl-ctrl-top-left,
  .maplibregl-ctrl-top-right,
  .maplibregl-ctrl-bottom-left,
  .maplibregl-ctrl-bottom-right {
    position: absolute;
    pointer-events: none;
    z-index: 2;
  }

  .maplibregl-ctrl-top-left {
    top: 0;
    left: 0;
  }

  .maplibregl-ctrl-top-right {
    top: 0;
    right: 0;
  }

  .maplibregl-ctrl-bottom-left {
    bottom: 0;
    left: 0;
  }

  .maplibregl-ctrl-bottom-right {
    right: 0;
    bottom: 0;
  }

  .maplibregl-ctrl {
    clear: both;
    pointer-events: auto;

    /* workaround for a Safari bug https://github.com/mapbox/mapbox-gl-js/issues/8185 */
    transform: translate(0, 0);
  }

  .maplibregl-ctrl-top-left .maplibregl-ctrl {
    margin: 10px 0 0 10px;
    float: left;
  }

  .maplibregl-ctrl-top-right .maplibregl-ctrl {
    margin: 10px 10px 0 0;
    float: right;
  }

  .maplibregl-ctrl-bottom-left .maplibregl-ctrl {
    margin: 0 0 10px 10px;
    float: left;
  }

  .maplibregl-ctrl-bottom-right .maplibregl-ctrl {
    margin: 0 10px 10px 0;
    float: right;
  }

  .maplibregl-ctrl-group {
    border-radius: 4px;
    background: #fff;
  }

  .maplibregl-ctrl-group:not(:empty) {
    box-shadow: 0 0 0 2px rgb(0 0 0 / 10%);
  }

  @media (forced-colors: active) {
    .maplibregl-ctrl-group:not(:empty) {
      box-shadow: 0 0 0 2px ButtonText;
    }
  }

  .maplibregl-ctrl-group button {
    width: 29px;
    height: 29px;
    display: block;
    padding: 0;
    outline: none;
    border: 0;
    box-sizing: border-box;
    background-color: transparent;
    cursor: pointer;
  }

  .maplibregl-ctrl-group button + button {
    border-top: 1px solid #ddd;
  }

  .maplibregl-ctrl button .maplibregl-ctrl-icon {
    display: block;
    width: 100%;
    height: 100%;
    background-repeat: no-repeat;
    background-position: center center;
  }

  @media (forced-colors: active) {
    .maplibregl-ctrl-icon {
      background-color: transparent;
    }

    .maplibregl-ctrl-group button + button {
      border-top: 1px solid ButtonText;
    }
  }

  /* https://bugzilla.mozilla.org/show_bug.cgi?id=140562 */
  .maplibregl-ctrl button::-moz-focus-inner {
    border: 0;
    padding: 0;
  }

  .maplibregl-ctrl-attrib-button:focus,
  .maplibregl-ctrl-group button:focus {
    box-shadow: 0 0 2px 2px rgb(0 150 255 / 100%);
  }

  .maplibregl-ctrl button:disabled {
    cursor: not-allowed;
  }

  .maplibregl-ctrl button:disabled .maplibregl-ctrl-icon {
    opacity: 0.25;
  }

  @media (hover: hover) {
    .maplibregl-ctrl button:not(:disabled):hover {
      background-color: rgb(0 0 0/5%);
    }
  }

  .maplibregl-ctrl button:not(:disabled):active {
    background-color: rgb(0 0 0/5%);
  }

  .maplibregl-ctrl-group button:focus:focus-visible {
    box-shadow: 0 0 2px 2px rgb(0 150 255 / 100%);
  }

  .maplibregl-ctrl-group button:focus:not(:focus-visible) {
    box-shadow: none;
  }

  .maplibregl-ctrl-group button:focus:first-child {
    border-radius: 4px 4px 0 0;
  }

  .maplibregl-ctrl-group button:focus:last-child {
    border-radius: 0 0 4px 4px;
  }

  .maplibregl-ctrl-group button:focus:only-child {
    border-radius: inherit;
  }

  .maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon {
    background-image: svg-load("svg/maplibregl-ctrl-zoom-out.svg", fill: #333);
  }

  .maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon {
    background-image: svg-load("svg/maplibregl-ctrl-zoom-in.svg", fill: #333);
  }

  @media (forced-colors: active) {
    .maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon {
      background-image: svg-load(
        "svg/maplibregl-ctrl-zoom-out.svg",
        fill: #fff
      );
    }

    .maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon {
      background-image: svg-load("svg/maplibregl-ctrl-zoom-in.svg", fill: #fff);
    }
  }

  @media (forced-colors: active) and (prefers-color-scheme: light) {
    .maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon {
      background-image: svg-load(
        "svg/maplibregl-ctrl-zoom-out.svg",
        fill: #000
      );
    }

    .maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon {
      background-image: svg-load("svg/maplibregl-ctrl-zoom-in.svg", fill: #000);
    }
  }

  .maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon {
    background-image: svg-load(
      "svg/maplibregl-ctrl-fullscreen.svg",
      fill: #333
    );
  }

  .maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon {
    background-image: svg-load("svg/maplibregl-ctrl-shrink.svg");
  }

  @media (forced-colors: active) {
    .maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon {
      background-image: svg-load(
        "svg/maplibregl-ctrl-fullscreen.svg",
        fill: #fff
      );
    }

    .maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon {
      background-image: svg-load("svg/maplibregl-ctrl-shrink.svg", fill: #fff);
    }
  }

  @media (forced-colors: active) and (prefers-color-scheme: light) {
    .maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon {
      background-image: svg-load(
        "svg/maplibregl-ctrl-fullscreen.svg",
        fill: #000
      );
    }

    .maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon {
      background-image: svg-load("svg/maplibregl-ctrl-shrink.svg", fill: #000);
    }
  }

  .maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon {
    background-image: svg-load("svg/maplibregl-ctrl-compass.svg", fill: #333);
  }

  @media (forced-colors: active) {
    .maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon {
      @svg-load ctrl-compass-white url("svg/maplibregl-ctrl-compass.svg") {
        fill: #fff;
        #south {
          fill: #999;
        }
      }

      background-image: svg-inline(ctrl-compass-white);
    }
  }

  @media (forced-colors: active) and (prefers-color-scheme: light) {
    .maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon {
      background-image: svg-load("svg/maplibregl-ctrl-compass.svg", fill: #000);
    }
  }

  @svg-load ctrl-globe url("svg/maplibregl-ctrl-globe.svg") {
    stroke: #333;
  }

  @svg-load ctrl-globe-enabled url("svg/maplibregl-ctrl-globe.svg") {
    stroke: #33b5e5;
  }

  .maplibregl-ctrl button.maplibregl-ctrl-globe .maplibregl-ctrl-icon {
    background-image: svg-inline(ctrl-globe);
  }

  .maplibregl-ctrl button.maplibregl-ctrl-globe-enabled .maplibregl-ctrl-icon {
    background-image: svg-inline(ctrl-globe-enabled);
  }

  @svg-load ctrl-terrain url("svg/maplibregl-ctrl-terrain.svg") {
    fill: #333;
  }

  @svg-load ctrl-terrain-enabled url("svg/maplibregl-ctrl-terrain.svg") {
    fill: #33b5e5;
  }

  .maplibregl-ctrl button.maplibregl-ctrl-terrain .maplibregl-ctrl-icon {
    background-image: svg-inline(ctrl-terrain);
  }

  .maplibregl-ctrl
    button.maplibregl-ctrl-terrain-enabled
    .maplibregl-ctrl-icon {
    background-image: svg-inline(ctrl-terrain-enabled);
  }

  @svg-load ctrl-geolocate url("svg/maplibregl-ctrl-geolocate.svg") {
    fill: #333;
    #stroke {
      display: none;
    }
  }

  @svg-load ctrl-geolocate-white url("svg/maplibregl-ctrl-geolocate.svg") {
    fill: #fff;
    #stroke {
      display: none;
    }
  }

  @svg-load ctrl-geolocate-black url("svg/maplibregl-ctrl-geolocate.svg") {
    fill: #000;
    #stroke {
      display: none;
    }
  }

  @svg-load ctrl-geolocate-disabled url("svg/maplibregl-ctrl-geolocate.svg") {
    fill: #aaa;
    #stroke {
      fill: #f00;
    }
  }

  @svg-load ctrl-geolocate-disabled-white url("svg/maplibregl-ctrl-geolocate.svg") {
    fill: #999;
    #stroke {
      fill: #f00;
    }
  }

  @svg-load ctrl-geolocate-disabled-black url("svg/maplibregl-ctrl-geolocate.svg") {
    fill: #666;
    #stroke {
      fill: #f00;
    }
  }

  @svg-load ctrl-geolocate-active url("svg/maplibregl-ctrl-geolocate.svg") {
    fill: #33b5e5;
    #stroke {
      display: none;
    }
  }

  @svg-load ctrl-geolocate-active-error url("svg/maplibregl-ctrl-geolocate.svg") {
    fill: #e58978;
    #stroke {
      display: none;
    }
  }

  @svg-load ctrl-geolocate-background url("svg/maplibregl-ctrl-geolocate.svg") {
    fill: #33b5e5;
    #stroke {
      display: none;
    }
    #dot {
      display: none;
    }
  }

  @svg-load ctrl-geolocate-background-error url("svg/maplibregl-ctrl-geolocate.svg") {
    fill: #e54e33;
    #stroke {
      display: none;
    }
    #dot {
      display: none;
    }
  }

  .maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon {
    background-image: svg-inline(ctrl-geolocate);
  }

  .maplibregl-ctrl
    button.maplibregl-ctrl-geolocate:disabled
    .maplibregl-ctrl-icon {
    background-image: svg-inline(ctrl-geolocate-disabled);
  }

  .maplibregl-ctrl
    button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active
    .maplibregl-ctrl-icon {
    background-image: svg-inline(ctrl-geolocate-active);
  }

  .maplibregl-ctrl
    button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active-error
    .maplibregl-ctrl-icon {
    background-image: svg-inline(ctrl-geolocate-active-error);
  }

  .maplibregl-ctrl
    button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background
    .maplibregl-ctrl-icon {
    background-image: svg-inline(ctrl-geolocate-background);
  }

  .maplibregl-ctrl
    button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background-error
    .maplibregl-ctrl-icon {
    background-image: svg-inline(ctrl-geolocate-background-error);
  }

  .maplibregl-ctrl
    button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-waiting
    .maplibregl-ctrl-icon {
    animation: maplibregl-spin 2s infinite linear;
  }

  @media (forced-colors: active) {
    .maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon {
      background-image: svg-inline(ctrl-geolocate-white);
    }

    .maplibregl-ctrl
      button.maplibregl-ctrl-geolocate:disabled
      .maplibregl-ctrl-icon {
      background-image: svg-inline(ctrl-geolocate-disabled-white);
    }

    .maplibregl-ctrl
      button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active
      .maplibregl-ctrl-icon {
      background-image: svg-inline(ctrl-geolocate-active);
    }

    .maplibregl-ctrl
      button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active-error
      .maplibregl-ctrl-icon {
      background-image: svg-inline(ctrl-geolocate-active-error);
    }

    .maplibregl-ctrl
      button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background
      .maplibregl-ctrl-icon {
      background-image: svg-inline(ctrl-geolocate-background);
    }

    .maplibregl-ctrl
      button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background-error
      .maplibregl-ctrl-icon {
      background-image: svg-inline(ctrl-geolocate-background-error);
    }
  }

  @media (forced-colors: active) and (prefers-color-scheme: light) {
    .maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon {
      background-image: svg-inline(ctrl-geolocate-black);
    }

    .maplibregl-ctrl
      button.maplibregl-ctrl-geolocate:disabled
      .maplibregl-ctrl-icon {
      background-image: svg-inline(ctrl-geolocate-disabled-black);
    }
  }

  @keyframes maplibregl-spin {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }

  a.maplibregl-ctrl-logo {
    width: 88px;
    height: 23px;
    margin: 0 0 -4px -4px;
    display: block;
    background-repeat: no-repeat;
    cursor: pointer;
    overflow: hidden;
    background-image: svg-load("svg/maplibregl-ctrl-logo.svg");
  }

  a.maplibregl-ctrl-logo.maplibregl-compact {
    width: 14px;
  }

  @media (forced-colors: active) {
    a.maplibregl-ctrl-logo {
      @svg-load ctrl-logo-white url("svg/maplibregl-ctrl-logo.svg") {
        #outline {
          opacity: 1;
        }
        #fill {
          opacity: 1;
        }
      }

      background-color: transparent;
      background-image: svg-inline(ctrl-logo-white);
    }
  }

  @media (forced-colors: active) and (prefers-color-scheme: light) {
    a.maplibregl-ctrl-logo {
      @svg-load ctrl-logo-black url("svg/maplibregl-ctrl-logo.svg") {
        #outline {
          opacity: 1;
          fill: #fff;
          stroke: #fff;
        }
        #fill {
          opacity: 1;
          fill: #000;
        }
      }

      background-image: svg-inline(ctrl-logo-black);
    }
  }

  .maplibregl-ctrl.maplibregl-ctrl-attrib {
    padding: 0 5px;
    background-color: rgb(255 255 255 / 50%);
    margin: 0;
  }

  @media screen {
    .maplibregl-ctrl-attrib.maplibregl-compact {
      min-height: 20px;
      padding: 2px 24px 2px 0;
      margin: 10px;
      position: relative;
      background-color: #fff;
      color: #000;
      border-radius: 12px;
      box-sizing: content-box;
    }

    .maplibregl-ctrl-attrib.maplibregl-compact-show {
      padding: 2px 28px 2px 8px;
      visibility: visible;
    }

    .maplibregl-ctrl-top-left > .maplibregl-ctrl-attrib.maplibregl-compact-show,
    .maplibregl-ctrl-bottom-left
      > .maplibregl-ctrl-attrib.maplibregl-compact-show {
      padding: 2px 8px 2px 28px;
      border-radius: 12px;
    }

    .maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-inner {
      display: none;
    }

    .maplibregl-ctrl-attrib-button {
      display: none;
      cursor: pointer;
      position: absolute;
      background-image: svg-load("svg/maplibregl-ctrl-attrib.svg");
      background-color: rgb(255 255 255 / 50%);
      width: 24px;
      height: 24px;
      box-sizing: border-box;
      border-radius: 12px;
      outline: none;
      top: 0;
      right: 0;
      border: 0;
    }

    .maplibregl-ctrl-attrib summary.maplibregl-ctrl-attrib-button {
      appearance: none;
      list-style: none;
    }

    .maplibregl-ctrl-attrib
      summary.maplibregl-ctrl-attrib-button::-webkit-details-marker {
      display: none;
    }

    .maplibregl-ctrl-top-left .maplibregl-ctrl-attrib-button,
    .maplibregl-ctrl-bottom-left .maplibregl-ctrl-attrib-button {
      left: 0;
    }

    .maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-button,
    .maplibregl-ctrl-attrib.maplibregl-compact-show
      .maplibregl-ctrl-attrib-inner {
      display: block;
    }

    .maplibregl-ctrl-attrib.maplibregl-compact-show
      .maplibregl-ctrl-attrib-button {
      background-color: rgb(0 0 0 / 5%);
    }

    .maplibregl-ctrl-bottom-right
      > .maplibregl-ctrl-attrib.maplibregl-compact::after {
      bottom: 0;
      right: 0;
    }

    .maplibregl-ctrl-top-right
      > .maplibregl-ctrl-attrib.maplibregl-compact::after {
      top: 0;
      right: 0;
    }

    .maplibregl-ctrl-top-left
      > .maplibregl-ctrl-attrib.maplibregl-compact::after {
      top: 0;
      left: 0;
    }

    .maplibregl-ctrl-bottom-left
      > .maplibregl-ctrl-attrib.maplibregl-compact::after {
      bottom: 0;
      left: 0;
    }
  }

  @media screen and (forced-colors: active) {
    .maplibregl-ctrl-attrib.maplibregl-compact::after {
      background-image: svg-load("svg/maplibregl-ctrl-attrib.svg", fill=#fff);
    }
  }

  @media screen and (forced-colors: active) and (prefers-color-scheme: light) {
    .maplibregl-ctrl-attrib.maplibregl-compact::after {
      background-image: svg-load("svg/maplibregl-ctrl-attrib.svg");
    }
  }

  .maplibregl-ctrl-attrib a {
    color: rgb(0 0 0 / 75%);
    text-decoration: none;
  }

  .maplibregl-ctrl-attrib a:hover {
    color: inherit;
    text-decoration: underline;
  }

  .maplibregl-attrib-empty {
    display: none;
  }

  .maplibregl-ctrl-scale {
    background-color: rgb(255 255 255 / 75%);
    font-size: 10px;
    border-width: medium 2px 2px;
    border-style: none solid solid;
    border-color: #333;
    padding: 0 5px;
    color: #333;
    box-sizing: border-box;
  }

  .maplibregl-popup {
    position: absolute;
    top: 0;
    left: 0;
    display: flex;
    will-change: transform;
    pointer-events: none;
  }

  .maplibregl-popup-anchor-top,
  .maplibregl-popup-anchor-top-left,
  .maplibregl-popup-anchor-top-right {
    flex-direction: column;
  }

  .maplibregl-popup-anchor-bottom,
  .maplibregl-popup-anchor-bottom-left,
  .maplibregl-popup-anchor-bottom-right {
    flex-direction: column-reverse;
  }

  .maplibregl-popup-anchor-left {
    flex-direction: row;
  }

  .maplibregl-popup-anchor-right {
    flex-direction: row-reverse;
  }

  .maplibregl-popup-tip {
    width: 0;
    height: 0;
    border: 10px solid transparent;
    z-index: 1;
  }

  .maplibregl-popup-anchor-top .maplibregl-popup-tip {
    align-self: center;
    border-top: none;
    border-bottom-color: #fff;
  }

  .maplibregl-popup-anchor-top-left .maplibregl-popup-tip {
    align-self: flex-start;
    border-top: none;
    border-left: none;
    border-bottom-color: #fff;
  }

  .maplibregl-popup-anchor-top-right .maplibregl-popup-tip {
    align-self: flex-end;
    border-top: none;
    border-right: none;
    border-bottom-color: #fff;
  }

  .maplibregl-popup-anchor-bottom .maplibregl-popup-tip {
    align-self: center;
    border-bottom: none;
    border-top-color: #fff;
  }

  .maplibregl-popup-anchor-bottom-left .maplibregl-popup-tip {
    align-self: flex-start;
    border-bottom: none;
    border-left: none;
    border-top-color: #fff;
  }

  .maplibregl-popup-anchor-bottom-right .maplibregl-popup-tip {
    align-self: flex-end;
    border-bottom: none;
    border-right: none;
    border-top-color: #fff;
  }

  .maplibregl-popup-anchor-left .maplibregl-popup-tip {
    align-self: center;
    border-left: none;
    border-right-color: #fff;
  }

  .maplibregl-popup-anchor-right .maplibregl-popup-tip {
    align-self: center;
    border-right: none;
    border-left-color: #fff;
  }

  .maplibregl-popup-close-button {
    position: absolute;
    right: 0;
    top: 0;
    border: 0;
    border-radius: 0 3px 0 0;
    cursor: pointer;
    background-color: transparent;
  }

  .maplibregl-popup-close-button:hover {
    background-color: rgb(0 0 0 / 5%);
  }

  .maplibregl-popup-content {
    position: relative;
    background: #fff;
    border-radius: 3px;
    box-shadow: 0 1px 2px rgb(0 0 0 / 10%);
    padding: 15px 10px;
    pointer-events: auto;
  }

  .maplibregl-popup-anchor-top-left .maplibregl-popup-content {
    border-top-left-radius: 0;
  }

  .maplibregl-popup-anchor-top-right .maplibregl-popup-content {
    border-top-right-radius: 0;
  }

  .maplibregl-popup-anchor-bottom-left .maplibregl-popup-content {
    border-bottom-left-radius: 0;
  }

  .maplibregl-popup-anchor-bottom-right .maplibregl-popup-content {
    border-bottom-right-radius: 0;
  }

  .maplibregl-popup-track-pointer {
    display: none;
  }

  .maplibregl-popup-track-pointer * {
    pointer-events: none;
    user-select: none;
  }

  .maplibregl-map:hover .maplibregl-popup-track-pointer {
    display: flex;
  }

  .maplibregl-map:active .maplibregl-popup-track-pointer {
    display: none;
  }

  .maplibregl-marker {
    position: absolute;
    top: 0;
    left: 0;
    will-change: transform;
    transition: opacity 0.2s;
  }

  .maplibregl-user-location-dot {
    background-color: #1da1f2;
    width: 15px;
    height: 15px;
    border-radius: 50%;
  }

  .maplibregl-user-location-dot::before {
    background-color: #1da1f2;
    content: "";
    width: 15px;
    height: 15px;
    border-radius: 50%;
    position: absolute;
    animation: maplibregl-user-location-dot-pulse 2s infinite;
  }

  .maplibregl-user-location-dot::after {
    border-radius: 50%;
    border: 2px solid #fff;
    content: "";
    height: 19px;
    left: -2px;
    position: absolute;
    top: -2px;
    width: 19px;
    box-sizing: border-box;
    box-shadow: 0 0 3px rgb(0 0 0 / 35%);
  }

  @keyframes maplibregl-user-location-dot-pulse {
    0% {
      transform: scale(1);
      opacity: 1;
    }
    70% {
      transform: scale(3);
      opacity: 0;
    }
    100% {
      transform: scale(1);
      opacity: 0;
    }
  }

  .maplibregl-user-location-dot-stale {
    background-color: #aaa;
  }

  .maplibregl-user-location-dot-stale::after {
    display: none;
  }

  .maplibregl-user-location-accuracy-circle {
    background-color: #1da1f233;
    width: 1px;
    height: 1px;
    border-radius: 100%;
  }

  .maplibregl-crosshair,
  .maplibregl-crosshair .maplibregl-interactive,
  .maplibregl-crosshair .maplibregl-interactive:active {
    cursor: crosshair;
  }

  .maplibregl-boxzoom {
    position: absolute;
    top: 0;
    left: 0;
    width: 0;
    height: 0;
    background: #fff;
    border: 2px dotted #202020;
    opacity: 0.5;
  }

  .maplibregl-cooperative-gesture-screen {
    background: rgba(0 0 0 / 40%);
    position: absolute;
    inset: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    padding: 1rem;
    font-size: 1.4em;
    line-height: 1.2;
    opacity: 0;
    pointer-events: none;
    transition: opacity 1s ease 1s;
    z-index: 99999;
  }

  .maplibregl-cooperative-gesture-screen.maplibregl-show {
    opacity: 1;
    transition: opacity 0.05s;
  }

  .maplibregl-cooperative-gesture-screen .maplibregl-mobile-message {
    display: none;
  }

  @media (hover: none), (pointer: coarse) {
    .maplibregl-cooperative-gesture-screen .maplibregl-desktop-message {
      display: none;
    }

    .maplibregl-cooperative-gesture-screen .maplibregl-mobile-message {
      display: block;
    }
  }

  .maplibregl-pseudo-fullscreen {
    position: fixed !important;
    width: 100% !important;
    height: 100% !important;
    top: 0 !important;
    left: 0 !important;
    z-index: 99999;
  }
`, vg = Id`
  :host {
    width: 100%;
    height: 100%;
    color: var(--data-viewer-text-color, black);
  }
  .maplibregl-popup-content ul {
    display: flex;
    flex-direction: column;
    gap: 5px;
    list-style-type: none;
    padding-inline: 5px;
    margin-block: 0px;
  }
  #map {
    width: 100%;
    height: 100%;
  }
`, as = "https://resource.geosphere.at/graphdb/repositories/thes", xg = "https://resource.geosphere.at/thes/geolunit", bg = "https://resource.geosphere.at/thes/tect", wg = "https://resource.geosphere.at/thes/lith", Sg = "https://resource.geosphere.at/thes/time", Tg = "https://resource.geosphere.at/thes/fault", Pg = "https://resource.geosphere.at/thes/minres", Mg = "https://resource.geosphere.at/thes/mineral", Ig = "http://resource.geolba.ac.at/structure", Yc = /* @__PURE__ */ new Map([
    [
        "f",
        {
            baseUri: Tg,
            endpoint: as,
            deprecatedBaseUri: Ig
        }
    ],
    [
        "g",
        {
            baseUri: xg,
            endpoint: as,
            deprecatedBaseUri: null
        }
    ],
    [
        "l",
        {
            baseUri: wg,
            endpoint: as,
            deprecatedBaseUri: null
        }
    ],
    [
        "a",
        {
            baseUri: Sg,
            endpoint: as,
            deprecatedBaseUri: null
        }
    ],
    [
        "t",
        {
            baseUri: bg,
            endpoint: as,
            deprecatedBaseUri: null
        }
    ],
    [
        "m",
        {
            baseUri: Pg,
            endpoint: as,
            deprecatedBaseUri: null
        }
    ],
    [
        "i",
        {
            baseUri: Mg,
            endpoint: as,
            deprecatedBaseUri: null
        }
    ]
]);
async function Dd(Q, E) {
    let j = 3;
    for (; j > 0;)
        try {
            const K = await fetch(Q, {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    Accept: "application/sparql-results+json"
                },
                body: `query=${encodeURIComponent(E)}&format=application%2Fjson`
            });
            if (!K.ok)
                throw new Error(`Error ${K.status}: ${K.statusText}`);
            return await K.json();
        } catch (K) {
            j -= 1, j === 0 && console.error("Error querying SPARQL endpoint: ", K);
        }
}
async function Cg(Q, E) {
    const j = `
        PREFIX skos:<http://www.w3.org/2004/02/skos/core#>
        SELECT ?parentURI ?parentPrefLabel ?childUri ?childPrefLabel 
        WHERE {
          <${E}> skos:narrower* ?parentURI .
          ?parentURI skos:narrower ?childUri .

          ?childUri skos:prefLabel ?childPrefLabel .
          ?parentURI skos:prefLabel ?parentPrefLabel .

          # Select only German labels
          FILTER(LANG(?parentPrefLabel) = "de") .
          FILTER(LANG(?childPrefLabel) = "de")
        }
        `, K = await Dd(Q, j);
    let se = [];
    return K && (se = K.results.bindings.map(
        (Te) => ({
            parentURI: Te.parentURI.value,
            parentPrefLabel: Te.parentPrefLabel.value,
            childUri: Te.childUri.value,
            childPrefLabel: Te.childPrefLabel.value
        })
    )), se;
}
async function Ag(Q, E) {
    const j = `
        PREFIX skos:<http://www.w3.org/2004/02/skos/core#>
        SELECT ?prefLabel
        WHERE {
          <${E}> skos:prefLabel ?prefLabel .

          # Select only German labels
          FILTER(LANG(?prefLabel) = "de") .
        }
        `, K = await Dd(Q, j), se = { prefLabel: null };
    return K && K.results.bindings.length > 0 && (se.prefLabel = K.results.bindings[0].prefLabel.value), se;
}
async function kg(Q) {
    const E = Rl(Q);
    if (E) {
        const j = Yc.get(E[0]);
        if (j)
            return await Ag(j.endpoint, Q);
    }
}
async function zg(Q) {
    const E = [];
    for (const j of Q) {
        const K = await kg(j);
        K && E.push(K);
    }
    return E;
}
async function Eg(Q) {
    const E = Rl(Q), j = [];
    if (E && E.length > 0) {
        const K = Yc.get(E[0]);
        if (K) {
            const se = await Cg(K.endpoint, Q);
            j.push(
                ...se.map((Te) => ({
                    uri: Te.childUri,
                    prefLabel: Te.childPrefLabel,
                    key: Rl(Te.childUri)
                }))
            );
        }
    }
    return j;
}
async function Rg(Q) {
    const E = [];
    for (const j of Q) {
        const K = await Eg(j);
        E.push(...K);
    }
    return E;
}
var Dg = Object.defineProperty, Lg = Object.getOwnPropertyDescriptor, ls = (Q, E, j, K) => {
    for (var se = K > 1 ? void 0 : K ? Lg(E, j) : E, Te = Q.length - 1, M; Te >= 0; Te--)
        (M = Q[Te]) && (se = (K ? M(E, j, se) : M(se)) || se);
    return K && se && Dg(E, j, se), se;
};
const Td = {
    "data-light": ug,
    "data-dark": _g
}, Jr = /* @__PURE__ */ new Map([
    [
        "geologic-units",
        {
            url: "https://gis.geosphere.at/maps/rest/services/Hosted/geologie_50_gu_keys/VectorTileServer/tile/{z}/{y}/{x}.pbf",
            featureLayerUrl: "https://gis.geosphere.at/maps/rest/services/Hosted/geologie_50_gu_keys/FeatureServer/0",
            sourceLayer: "geologie_50_info",
            sourceType: "vector",
            layerType: "fill",
            filterAttribute: "GU_KEY",
            delimiter: "-",
            cluster: !1,
            queryMode: 1,
            filterMode: 0,
            outFields: null
        }
    ],
    [
        "geologic-units-centroids",
        {
            url: "https://gis.geosphere.at/maps/rest/services/Hosted/geologie_50_centroids/FeatureServer/0",
            featureLayerUrl: null,
            sourceLayer: null,
            sourceType: "geojson",
            layerType: "circle",
            filterAttribute: "GU_KEY",
            delimiter: "-",
            cluster: !0,
            queryMode: 1,
            filterMode: 0,
            outFields: null
        }
    ],
    [
        "tectonic-lines",
        {
            url: "https://gis.geosphere.at/maps/rest/services/geologie/tektonische_linien_1m/MapServer/4",
            featureLayerUrl: "https://gis.geosphere.at/maps/rest/services/geologie/tektonische_linien_1m/MapServer/4",
            sourceLayer: null,
            sourceType: "geojson",
            layerType: "line",
            filterAttribute: "THESURL",
            delimiter: "",
            cluster: !1,
            queryMode: 0,
            filterMode: 1,
            outFields: "THESURL,F_NAME_DT"
        }
    ],
    [
        "mineral-resources",
        {
            url: "https://gis.geosphere.at/maps/rest/services/IRIS/Lagerstaetten/MapServer/0",
            featureLayerUrl: "https://gis.geosphere.at/maps/rest/services/IRIS/Lagerstaetten/MapServer/0",
            sourceLayer: null,
            sourceType: "geojson",
            layerType: "circle",
            filterAttribute: "WERTSTOFFE",
            delimiter: "",
            cluster: !1,
            queryMode: 1,
            filterMode: 2,
            outFields: "VORK_NAME,WERTSTOFFE"
        }
    ],
    [
        "minerals",
        {
            url: "https://gis.geosphere.at/maps/rest/services/IRIS/Lagerstaetten/MapServer/0",
            featureLayerUrl: "https://gis.geosphere.at/maps/rest/services/IRIS/Lagerstaetten/MapServer/0",
            sourceLayer: null,
            sourceType: "geojson",
            layerType: "circle",
            filterAttribute: "MINERALIEN",
            delimiter: "",
            cluster: !1,
            queryMode: 1,
            filterMode: 2,
            outFields: "VORK_NAME,MINERALIEN"
        }
    ]
]);
let wa = class extends Cl {
    constructor() {
        super(...arguments), this.conceptUris = [], this.includeNarrower = !1, this.basemapStyle = "data-light", this.color = "#0284c7", this.secondaryColor = "#ef4444", this.opacity = 0.8, this._mapContainerRef = rg(), this._layerIds = [], this._keys = [], this._defaultColor = "#22c55e", this._createFilterTerms = (Q) => {
            var K, se, Te;
            const E = Jr.get(Q);
            if (!E) return [];
            let j;
            return E.filterMode === 0 ? this.includeNarrower ? j = [
                ...this._keys,
                ...((K = this._narrower) == null ? void 0 : K.map((M) => M.key)) || []
            ] : j = [...this._keys] : E.filterMode === 1 ? this.includeNarrower ? j = [
                ...this.conceptUris,
                ...((se = this._narrower) == null ? void 0 : se.map((M) => M.uri)) || []
            ] : j = [...this.conceptUris] : this.includeNarrower ? j = [
                ...this._prefLabels || [],
                ...((Te = this._narrower) == null ? void 0 : Te.map((M) => M.prefLabel)) || []
            ] : j = [...this._prefLabels || []], j;
        }, this._createWhereClause = (Q) => {
            const E = Jr.get(Q);
            if (!E) return;
            const j = this._createFilterTerms(Q);
            return E.queryMode === 1 ? j.map(
                (K) => `${E.filterAttribute} LIKE '%${K}${E.delimiter}%'`
            ).join(" OR ") : j.map((K) => `${E.filterAttribute} = '${K}'`).join(" OR ");
        }, this._createFilter = (Q, E) => {
            const j = Jr.get(Q);
            if (!j) return !1;
            const K = ["any"];
            return E.forEach(
                (se) => K.push([
                    "in",
                    `${se}${j.delimiter}`,
                    ["get", j.filterAttribute]
                ])
            ), K;
        }, this._queryExtent = async (Q) => {
            try {
                const E = Jr.get(Q);
                if (!E) return;
                const j = this._createWhereClause(Q), K = `${E.featureLayerUrl}/query?where=${j}&outSR=4326&returnExtentOnly=true&f=pjson`, Te = await (await fetch(K)).json(), { xmin: M, ymin: c, xmax: Fe, ymax: ht } = Te.extent;
                return [
                    [M, c],
                    [Fe, ht]
                ];
            } catch {
                throw new Error("Failed to fetch features");
            }
        };
    }
    // Create paint expression for feature rendering
    _createPaintExpression(Q) {
        var se, Te, M;
        const E = Jr.get(Q);
        if (!E) return "";
        const j = [], K = [];
        return E.filterMode === 0 ? (j.push(...this._keys), K.push(...((se = this._narrower) == null ? void 0 : se.map((c) => c.key)) || [])) : E.filterMode === 1 ? (j.push(...this.conceptUris), K.push(...((Te = this._narrower) == null ? void 0 : Te.map((c) => c.uri)) || [])) : (j.push(...this._prefLabels || []), K.push(
            ...((M = this._narrower) == null ? void 0 : M.map((c) => c.prefLabel)) || []
        )), [
                "case",
                this._createFilter(Q, j),
                this.color,
                this._createFilter(Q, K),
                this.secondaryColor,
                this._defaultColor
            ];
    }
    // Add a single data source given by its id
    _addSource(Q) {
        var j, K;
        const E = Jr.get(Q);
        if (E)
            switch (E.sourceType) {
                case "vector": {
                    const se = `${Q}-source`;
                    (j = this._map) == null || j.addSource(se, {
                        type: E.sourceType,
                        tiles: [E.url]
                    });
                    break;
                }
                case "geojson": {
                    const se = `${Q}-source`, Te = this._createWhereClause(Q);
                    (K = this._map) == null || K.addSource(se, {
                        type: E.sourceType,
                        data: `${E.url}/query?f=geojson&returnGeometry=true&where=${Te}&outFields=${E.outFields}`,
                        cluster: E.cluster,
                        clusterMaxZoom: 8
                    });
                }
            }
    }
    // Add data sources
    _addSources() {
        for (const Q of this._layerIds)
            this._addSource(Q);
    }
    // Add layer given by its id to map
    _addLayer(Q) {
        var j, K, se, Te, M, c;
        const E = Jr.get(Q);
        if (E) {
            switch (E.layerType) {
                case "fill": {
                    (j = this._map) == null || j.addLayer({
                        id: Q,
                        type: E.layerType,
                        source: `${Q}-source`,
                        "source-layer": E.sourceType === "vector" ? E.sourceLayer : "",
                        paint: {
                            "fill-color": this._createPaintExpression(Q),
                            "fill-opacity": this.opacity,
                            "fill-outline-color": "white"
                        }
                    });
                    break;
                }
                case "line": {
                    (K = this._map) == null || K.addLayer({
                        id: Q,
                        type: E.layerType,
                        source: `${Q}-source`,
                        "source-layer": E.sourceType === "vector" ? E.sourceLayer : "",
                        paint: {
                            "line-color": this._createPaintExpression(Q),
                            "line-opacity": this.opacity
                        }
                    });
                    break;
                }
                case "circle": {
                    (se = this._map) == null || se.addLayer({
                        id: Q,
                        type: E.layerType,
                        source: `${Q}-source`,
                        "source-layer": E.sourceType === "vector" ? E.sourceLayer : "",
                        paint: {
                            "circle-color": this._createPaintExpression(Q),
                            "circle-opacity": this.opacity
                        }
                    });
                    break;
                }
            }
            if (E.sourceType === "vector" && this._setFilter(Q), this._queryExtent(Q).then((Fe) => {
                Fe && this._map.fitBounds(Fe, { padding: 20 });
            }).catch(() => console.log("Failed to fetch features")), Q === "geologic-units") {
                const Fe = `${Q}-centroids`, ht = `${Q}-clusters`;
                this._addSource(Fe), (Te = this._map) == null || Te.addLayer({
                    id: ht,
                    type: "circle",
                    source: `${Fe}-source`,
                    filter: ["has", "point_count"],
                    paint: {
                        // Use step expressions (https://maplibre.org/maplibre-style-spec/#expressions-step)
                        // with three steps to implement three types of circles:
                        //   * Blue, 20px circles when point count is less than 100
                        //   * Yellow, 30px circles when point count is between 100 and 750
                        //   * Pink, 40px circles when point count is greater than or equal to 750
                        "circle-color": [
                            "step",
                            ["get", "point_count"],
                            "#51bbd6",
                            50,
                            "#f1f075",
                            350,
                            "#f28cb1"
                        ],
                        "circle-radius": [
                            "step",
                            ["get", "point_count"],
                            20,
                            50,
                            30,
                            350,
                            40
                        ],
                        "circle-opacity": 0.8
                    }
                }), (M = this._map) == null || M.addLayer({
                    id: "cluster-count",
                    type: "symbol",
                    source: `${Fe}-source`,
                    filter: ["has", "point_count"],
                    layout: {
                        "text-field": "{point_count_abbreviated}",
                        "text-font": ["Noto Sans Regular"],
                        "text-size": 15
                    }
                }), (c = this._map) == null || c.on("click", ht, async (ct) => {
                    var de, $e, lr;
                    const Ue = (de = this._map) == null ? void 0 : de.queryRenderedFeatures(ct.point, {
                        layers: [ht]
                    });
                    if (Ue && Ue.length > 0) {
                        const cr = Ue[0].properties.cluster_id, wr = await (($e = this._map) == null ? void 0 : $e.getSource(Q)).getClusterExpansionZoom(cr);
                        (lr = this._map) == null || lr.easeTo({
                            center: Ue[0].geometry.coordinates,
                            zoom: wr
                        });
                    }
                }), this._map.on("mousemove", ht, (ct) => {
                    this._map.queryRenderedFeatures(ct.point, {
                        layers: [ht]
                    }).length && (this._map.getCanvas().style.cursor = "pointer");
                }), this._map.on("mouseleave", ht, () => {
                    this._map.getCanvas().style.cursor = "";
                });
            }
        }
    }
    // Add layers to map
    _addLayers() {
        for (const Q of this._layerIds)
            this._addLayer(Q);
    }
    // Set filter for vector tile layer
    _setFilter(Q) {
        var K;
        const E = this._createFilterTerms(Q), j = this._createFilter(Q, E);
        j && ((K = this._map) == null || K.setFilter(Q, j));
    }
    _setFilters() {
        for (const Q of this._layerIds)
            this._setFilter(Q);
    }
    // Get narrower concepts from Thesaurus
    async _getNarrower() {
        this._narrower = await Rg(this.conceptUris);
    }
    _initMap() {
        this._addSources(), this._addLayers();
    }
    // Initialize concept data used for queries, currently necessary for mineral resources which only include prefLabels in the data source
    async _initConceptData() {
        for (const Q of this._layerIds) {
            const E = Jr.get(Q);
            E && E.filterMode === 2 && (this._prefLabels = (await zg(this.conceptUris)).map((j) => j.prefLabel).filter((j) => j !== null));
        }
    }
    // Update concept URIs for sources that still use old concept URIs, currently only fault systems
    _updateConceptUris() {
        for (const [Q, E] of this.conceptUris.entries()) {
            const j = Rl(E);
            if (j && j.startsWith("f")) {
                const K = Yc.get(j[0]), se = K == null ? void 0 : K.deprecatedBaseUri, Te = K == null ? void 0 : K.baseUri;
                Te && se && (this.conceptUris[Q] = E.replace(Te, se));
            }
        }
        if (this._narrower)
            for (const Q of this._narrower) {
                const E = Q.key;
                if (E && E.startsWith("f")) {
                    const j = Yc.get(E[0]), K = j == null ? void 0 : j.deprecatedBaseUri, se = j == null ? void 0 : j.baseUri;
                    se && K && (Q.uri = Q.uri.replace(se, K));
                }
            }
    }
    // Get layer ids from concept URIs
    _getLayerIds() {
        this.conceptUris.forEach((Q) => {
            const E = Wm(Q);
            E && this._layerIds.push(E);
        });
    }
    // Called after the templated DOM is rendered the first time but before the browser paints
    firstUpdated() {
        this._getLayerIds(), this._map = new Sd.Map({
            container: this._mapContainerRef.value,
            style: Td[this.basemapStyle],
            center: [13.7, 47.5],
            zoom: 5,
            maxZoom: 10,
            attributionControl: !1
        }), this._map.once("load", async () => {
            this._keys = Hm(this.conceptUris);
            const E = [];
            this.includeNarrower && E.push(this._getNarrower()), E.push(this._initConceptData()), await Promise.all(E), this._updateConceptUris(), this._initMap();
        });
        const Q = new Sd.Popup({
            closeButton: !1,
            closeOnClick: !1
        });
        this._layerIds.forEach((E) => {
            this._map.on("mousemove", E, (j) => {
                const K = this._map.queryRenderedFeatures(j.point, {
                    layers: [E]
                });
                if (!K.length) {
                    Q.remove();
                    return;
                }
                this._map.getCanvas().style.cursor = "pointer";
                const se = K[0], Te = se == null ? void 0 : se.properties;
                if (Te) {
                    const M = Object.keys(Te).map((c) => {
                        let Fe;
                        return Te[c] && typeof Te[c] == "string" && Te[c].startsWith("http") ? Fe = `<br/><a href="${Te[c]}" target="_blank">${Te[c]}</a>` : Fe = Te[c], `<li><strong>${c}: </strong>${Fe}</li>`;
                    });
                    Q.setLngLat(j.lngLat).setHTML(`<ul>${M.join("")}</ul>`).addTo(this._map);
                }
            }), this._map.on("mouseleave", E, () => {
                this._map.getCanvas().style.cursor = "", Q.remove();
            });
        });
    }
    // Remove map when component gets disconnected
    disconnectedCallback() {
        var Q;
        (Q = this._map) == null || Q.remove(), super.disconnectedCallback();
    }
    // Update properties when HTML attributes change
    willUpdate(Q) {
        var E;
        for (const j of Q.keys())
            switch (j) {
                case "basemapStyle": {
                    if (Q.get(j)) {
                        const K = Td[this.basemapStyle];
                        K && ((E = this._map) == null || E.setStyle(K), this._addLayers());
                    }
                    break;
                }
                case "color":
                case "secondaryColor": {
                    Q.get(j) && this._layerIds.forEach((K) => {
                        var Te;
                        const se = Jr.get(K);
                        switch (se == null ? void 0 : se.layerType) {
                            case "fill": {
                                (Te = this._map) == null || Te.setPaintProperty(
                                    K,
                                    "fill-color",
                                    this._createPaintExpression(K)
                                );
                                break;
                            }
                        }
                    });
                    break;
                }
                case "opacity": {
                    Q.get(j) && this._layerIds.forEach((K) => {
                        var Te;
                        const se = Jr.get(K);
                        switch (se == null ? void 0 : se.layerType) {
                            case "fill": {
                                (Te = this._map) == null || Te.setPaintProperty(K, "fill-opacity", this.opacity);
                                break;
                            }
                        }
                    });
                    break;
                }
                case "includeNarrower": {
                    Q.get(j) && this._setFilters();
                    break;
                }
            }
    }
    render() {
        return Em`<div ${ng(this._mapContainerRef)} id="map"></div>`;
    }
};
wa.styles = [vg, yg];
ls([
    fo({
        type: String,
        attribute: "concept-uris",
        converter: {
            fromAttribute: (Q) => Q == null ? void 0 : Q.split(","),
            toAttribute: (Q) => Q.join(",")
        }
    })
], wa.prototype, "conceptUris", 2);
ls([
    fo({ type: Boolean, attribute: "include-narrower" })
], wa.prototype, "includeNarrower", 2);
ls([
    fo({ type: String, attribute: "basemap-style" })
], wa.prototype, "basemapStyle", 2);
ls([
    fo({ type: String, attribute: "color" })
], wa.prototype, "color", 2);
ls([
    fo({ type: String, attribute: "secondary-color" })
], wa.prototype, "secondaryColor", 2);
ls([
    fo({ type: Number, attribute: "opacity" })
], wa.prototype, "opacity", 2);
wa = ls([
    jm("data-viewer")
], wa);
export {
    wa as DataViewer
};
